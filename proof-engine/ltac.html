

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Ltac &mdash; Coq 8.17.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Ltac2" href="ltac2.html" />
    <link rel="prev" title="Creating new tactics" href="../proofs/creating-tactics/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.17.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption"><span class="caption-text">Specification language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/core/index.html">Core language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/core/basic.html">Basic notions and conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#syntax-and-lexical-conventions">Syntax and lexical conventions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#syntax-conventions">Syntax conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#lexical-conventions">Lexical conventions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#essential-vocabulary">Essential vocabulary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#settings">Settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#flags-options-and-tables">Flags, Options and Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sorts.html">Sorts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/assumptions.html">Functions and assumptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#functions-fun-and-function-types-forall">Functions (fun) and function types (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#function-application">Function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#assumptions">Assumptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/definitions.html">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#top-level-definitions">Top-level definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/conversion.html">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#conversion">α-conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#delta-reduction-sect">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id4">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id7">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html">Typing rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#id6">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/variants.html">Variants and the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#id1">Variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/variants.html#private-matching-inductive-types">Private (matching) inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#definition-by-cases-match">Definition by cases: match</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#defining-record-types">Defining record types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#constructing-records">Constructing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#accessing-fields-projections">Accessing fields (projections)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#settings-for-printing-records">Settings for printing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#compatibility-projections-and-match">Compatibility Projections and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/inductive.html">Inductive types and recursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#inductive-types">Inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#recursive-functions-fix">Recursive functions: fix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#top-level-recursive-functions">Top-level recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#theory-of-inductive-definitions">Theory of inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/coinductive.html">Coinductive types and corecursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#coinductive-types">Coinductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/coinductive.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#co-recursive-functions-cofix">Co-recursive functions: cofix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#top-level-definitions-of-corecursive-functions">Top-level definitions of corecursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sections.html">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/modules.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#using-modules">Using modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/modules.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#typing-modules">Typing Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#controlling-the-scope-of-commands-with-locality-attributes">Controlling the scope of commands with locality attributes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/primitive.html">Primitive objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-arrays">Primitive Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#specifying-cumulativity">Specifying cumulativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#printing-universes">Printing universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#definitional-uip">Definitional UIP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/sprop.html#non-termination-with-uip">Non Termination with UIP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/evars.html">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#e-tactics-that-can-create-existential-variables">e* tactics that can create existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#automatic-resolution-of-existential-variables">Automatic resolution of existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#explicit-display-of-existential-instances-for-pretty-printing">Explicit display of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments">Maximal and non-maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/match.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#conventions-about-unused-pattern-matching-variables">Conventions about unused pattern-matching variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and notation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#use-of-notations-for-printing">Use of notations for printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#enabling-and-disabling-notations">Enabling and disabling notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax">Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes">Notation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes-used-in-the-standard-library-of-coq">Notation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numbers-and-strings">Numbers and strings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#number-notations">Number notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/arguments-command.html">Setting properties of a function's arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#manual-declaration-of-implicit-arguments">Manual declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#binding-arguments-to-scopes">Binding arguments to scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#effects-of-arguments-on-unfolding">Effects of <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code> on unfolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#id1">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#reversible-coercions">Reversible Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/canonical.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#declaration-of-canonical-structures">Declaration of canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#load-paths">Load paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#extra-dependencies">Extra Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Proofs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../proofs/writing-proofs/index.html">Basic proof writing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html">Proof mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-state">Proof State</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#entering-and-exiting-proof-mode">Entering and exiting proof mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-modes">Proof modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#managing-goals">Managing goals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#focusing-goals">Focusing goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#shelving-goals">Shelving goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#reordering-goals">Reordering goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proving-a-subgoal-as-a-separate-lemma-abstract">Proving a subgoal as a separate lemma: abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-diffs-are-calculated">How diffs are calculated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#show-proof-differences">&quot;Show Proof&quot; differences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-proof-mode">Controlling proof mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#reserved-keywords">Reserved keywords</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#occurrence-clauses">Occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/equality.html">Reasoning with equalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#tactics-for-simple-equalities">Tactics for simple equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-leibniz-and-setoid-equality">Rewriting with Leibniz and setoid equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-definitional-equality">Rewriting with definitional equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#applying-conversion-rules">Applying conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#fast-reduction-tactics-vm-compute-and-native-compute">Fast reduction tactics: vm_compute and native_compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#computing-in-a-term-eval-and-eval">Computing in a term: eval and Eval</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#controlling-reduction-strategies-and-the-conversion-algorithm">Controlling reduction strategies and the conversion algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html">Reasoning with inductive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#applying-constructors">Applying constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#case-analysis">Case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#induction">Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#equality-of-inductive-types">Equality of inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#helper-tactics">Helper tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#examples-of-dependent-destruction-dependent-induction">Examples of <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> / <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#a-larger-example">A larger example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#gallina-extensions">Gallina extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/automatic-tactics/index.html">Automatic solvers and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/logic.html">Solvers for logic and equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html">Micromega: solvers for arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html">ring and field: solvers for polynomial and rational equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: a solver for equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/auto.html">Programmable proof search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases">Hint databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hint-databases">Creating Hint databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hints">Creating Hints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations">Rewriting and nonreflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonsymmetric-relations">Rewriting and nonsymmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-with-type-valued-relations">Rewriting with <code class="docutils literal notranslate"><span class="pre">Type</span></code> valued relations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#declaring-rewrite-relations">Declaring rewrite relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../proofs/creating-tactics/index.html">Creating new tactics</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#values">Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#syntactic-values">Syntactic values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#substitution">Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-definitions-let">Local definitions: let</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-construction-and-application">Function construction and application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tactics-in-terms">Tactics in terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processing-multiple-goals">Processing multiple goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#branching-and-backtracking">Branching and backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sequence">Sequence: ;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#do-loop">Do loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#catching-errors-try">Catching errors: try</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conditional-branching-tryif">Conditional branching: tryif</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#branching-with-backtracking">Branching with backtracking: +</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-application-of-tactics">Local application of tactics: [&gt; ... ]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#first-tactic-to-succeed">First tactic to succeed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="#first-tactic-to-make-progress">First tactic to make progress: ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="#detecting-progress">Detecting progress</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#success-and-failure">Success and failure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#checking-for-success-assert-succeeds">Checking for success: assert_succeeds</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checking-for-failure-assert-fails">Checking for failure: assert_fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#soft-cut-once">Soft cut: once</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checking-for-a-single-success-exactly-once">Checking for a single success: exactly_once</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#manipulating-values">Manipulating values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pattern-matching-on-terms-match">Pattern matching on terms: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pattern-matching-on-goals-and-hypotheses-match-goal">Pattern matching on goals and hypotheses: match goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computing-in-a-term-eval">Computing in a term: eval</a></li>
<li class="toctree-l4"><a class="reference internal" href="#getting-the-type-of-a-term">Getting the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="#manipulating-untyped-terms-type-term">Manipulating untyped terms: type_term</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counting-goals-numgoals">Counting goals: numgoals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing-boolean-expressions-guard">Testing boolean expressions: guard</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checking-properties-of-terms">Checking properties of terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#timing">Timing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timing-a-tactic-that-evaluates-to-a-term-time-constr">Timing a tactic that evaluates to a term: time_constr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#print-identity-tactic-idtac">Print/identity tactic: idtac</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-ltac-symbols">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tracing-execution">Tracing execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-definitions">Ltac2 Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#printing-ltac2-tactics">Printing Ltac2 tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#quotations">Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-goals">Match over goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-on-values">Match on values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#defining-tactics">Defining tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntactic-classes">Syntactic classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html">The Coq library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-prelude">The prelude</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between Coq and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/writing.html">Writing Coq libraries and plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/writing.html#deprecating-library-objects-or-tactics">Deprecating library objects or tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html">Building Coq Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coq-configuration-basics">Coq configuration basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installing-coq-and-coq-packages-with-opam">Installing Coq and Coq packages with opam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#setup-for-working-on-your-own-projects">Setup for working on your own projects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-project-with-coqproject-overview">Building a project with _CoqProject (overview)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#logical-paths-and-the-load-path">Logical paths and the load path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#modifying-multiple-interdependent-projects-at-the-same-time">Modifying multiple interdependent projects at the same time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installed-and-uninstalled-packages">Installed and uninstalled packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#upgrading-to-a-new-version-of-coq">Upgrading to a new version of Coq</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile-details">Building a Coq project with coq_makefile (details)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a Coq project with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coqdep-computing-module-dependencies">coqdep: Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#split-compilation-of-native-computation-files">Split compilation of native computation files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html">Coq commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#command-parameters">Command parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#coqrc-start-up-script"><code class="docutils literal notranslate"><span class="pre">coqrc</span></code> start up script</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#environment-variables">Environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/tools/coqdoc.html">Documenting Coq files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#coq-material-inside-documentation">Coq material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html">CoqIDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#running-coq-scripts">Running Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#asynchronous-mode">Asynchronous mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#commands-and-templates">Commands and templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#preferences">Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#key-bindings">Key bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#debugger">Debugger</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#breakpoints">Breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#call-stack-and-variables">Call Stack and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#supported-use-cases">Supported use cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id3">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-17">Version 8.17</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-0">Changes in 8.17.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-1">Changes in 8.17.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-16">Version 8.16</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-0">Changes in 8.16.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-1">Changes in 8.16.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-15">Version 8.15</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id316">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-0">Changes in 8.15.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-1">Changes in 8.15.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-2">Changes in 8.15.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-14">Version 8.14</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id544">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-0">Changes in 8.14.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-1">Changes in 8.14.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-13">Version 8.13</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id740">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-beta1">Changes in 8.13+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-0">Changes in 8.13.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-1">Changes in 8.13.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-2">Changes in 8.13.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-12">Version 8.12</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id904">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-beta1">Changes in 8.12+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-0">Changes in 8.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-1">Changes in 8.12.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-2">Changes in 8.12.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1210">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-2">Changes in 8.11.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1348">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1495">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1497">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1498">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1499">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1500">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1501">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1502">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1504">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1505">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1506">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1507">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1508">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1509">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-attrindex.html">Attribute index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../genindex.html">General index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../proofs/creating-tactics/index.html">Creating new tactics</a> &raquo;</li>
        
      <li>Ltac</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/ltac.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<div class="section" id="ltac">
<span id="id1"></span><h1>Ltac<a class="headerlink" href="#ltac" title="Permalink to this headline">¶</a></h1>
<p>This chapter documents the tactic language <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>.</p>
<p>We start by giving the syntax followed by the informal
semantics. To learn more about the language and
especially about its foundations, please refer to <a class="reference internal" href="../zebibliography.html#del00" id="id2">[Del00]</a>.
(Note the examples in the paper won't work as-is; Coq has evolved
since the paper was written.)</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic tactic macros</p>
<p>Here are some examples of simple tactic macros you can create with <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">reduce_and_try_to_solve</span><span> := </span><span class="coqdoc-tactic">simpl</span><span>; </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">auto</span><span>.</span><span>
</span><span>
</span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">destruct_bool_and_rewrite</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span> :=</span><span>
  </span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">b</span><span>; [ </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H1</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> | </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H2</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> ].</span><span>
</span></span></div>
<p>See Section <a class="reference internal" href="#ltac-examples"><span class="std std-ref">Examples of using Ltac</span></a> for more advanced examples.</p>
</div>
<div class="section" id="syntax">
<span id="ltac-syntax"></span><h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>The syntax of the tactic language is given below.</p>
<p>The main entry of the grammar is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>, which is used in proof mode
as well as to define new tactics with the <a class="reference internal" href="#coq:cmd.Ltac" title="Ltac"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Ltac</span></code></a> command.</p>
<p>The grammar uses multiple <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ltac</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">expr*</span></span></span></span></code> nonterminals to express how subexpressions
are grouped when they're not fully parenthesized.  For example, in many programming
languages, <code class="docutils literal notranslate"><span class="pre">a*b+c</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(a*b)+c</span></code> because <code class="docutils literal notranslate"><span class="pre">*</span></code> has
higher precedence than <code class="docutils literal notranslate"><span class="pre">+</span></code>.  Usually <code class="docutils literal notranslate"><span class="pre">a/b/c</span></code> is given the <span class="term-defn"><span class="target" id="term-left-associative"></span>left associative</span>
interpretation <code class="docutils literal notranslate"><span class="pre">(a/b)/c</span></code> rather than the <span class="term-defn"><span class="target" id="term-right-associative"></span>right associative</span> interpretation
<code class="docutils literal notranslate"><span class="pre">a/(b/c)</span></code>.</p>
<p>In Coq, the expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">try</span></span></span> <span><span><span class="pre">repeat</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span><span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">4</span></sub></span></a></span></code>
is interpreted as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(try</span></span></span> <span><span><span class="pre">(repeat</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span><span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">));</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">);</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">4</span></sub></span></a></span></code>
because <code class="docutils literal notranslate"><span class="pre">||</span></code> is part of <a class="reference internal" href="#grammar-token-ltac_expr2"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr2</span></code></a>, which has higher precedence than
<a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a> and <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a> (at the level of <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a>), which
in turn have higher precedence than <code class="docutils literal notranslate"><span class="pre">;</span></code>, which is part of <a class="reference internal" href="#grammar-token-ltac_expr4"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr4</span></code></a>.
(A <em>lower</em> number in the nonterminal name means <em>higher</em> precedence in this grammar.)</p>
<p>The constructs in <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> are <a class="reference internal" href="#term-left-associative"><span class="xref std std-term">left associative</span></a>.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr4"><span class="hole">ltac_expr4</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr4"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr4"><span class="hole">ltac_expr4</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a> <span><span>;</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a> <span><span>;</span></span> <span><span>[</span></span> <a class="reference internal" href="#grammar-token-for_each_goal"><span class="hole">for_each_goal</span></a> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr3"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-l3_tactic"><span class="hole">l3_tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr2"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a> <span><span>+</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a> <span><span>||</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-l2_tactic"><span class="hole">l2_tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr1"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic_value"><span class="hole">tactic_value</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-tactic_arg"><span class="hole">tactic_arg</span></a></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-l1_tactic"><span class="hole">l1_tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr0"><span class="hole">ltac_expr0</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic_value"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tactic_value"><span class="hole">tactic_value</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-value_tactic"><span class="hole">value_tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-syn_value"><span class="hole">syn_value</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic_arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tactic_arg"><span class="hole">tactic_arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic_value"><span class="hole">tactic_value</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>()</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ltac_expr0"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr0"><span class="hole">ltac_expr0</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[&gt;</span></span> <a class="reference internal" href="#grammar-token-for_each_goal"><span class="hole">for_each_goal</span></a> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic_atom"><span class="hole">tactic_atom</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic_atom"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tactic_atom"><span class="hole">tactic_atom</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><span class="hole">integer</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>()</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Tactics described in other chapters of the documentation are <span class="inline-grammar-production"><span class="target" id="grammar-token-simple_tactic"></span><code class="docutils literal notranslate"><span class="pre">simple_tactic</span></code></span>s,
which only modify the proof state.  <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> provides additional constructs that can generally
be used wherever a <a class="reference internal" href="#grammar-token-simple_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">simple_tactic</span></code></a> can appear, even though they don't modify the proof
state and that syntactically they're at
varying levels in <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>.  For simplicity of presentation, the <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> constructs
are documented as tactics.  Tactics are grouped as follows:</p>
<ul class="simple">
<li><p><span class="inline-grammar-production"><span class="target" id="grammar-token-binder_tactic"></span><code class="docutils literal notranslate"><span class="pre">binder_tactic</span></code></span>s are: <a class="reference internal" href="#coq:tacn.fun" title="fun"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fun</span></code></a> and <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a></p></li>
<li><p><span class="inline-grammar-production"><span class="target" id="grammar-token-l3_tactic"></span><code class="docutils literal notranslate"><span class="pre">l3_tactic</span></code></span>s include <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics: <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>,
<a class="reference internal" href="#coq:tacn.do" title="do"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">do</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.timeout" title="timeout"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">timeout</span></code></a>, <a class="reference internal" href="#coq:tacn.time" title="time"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">time</span></code></a>, <a class="reference internal" href="#coq:tacn.progress" title="progress"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">progress</span></code></a>, <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a>,
<a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a>, <a class="reference internal" href="#coq:tacn.only" title="only"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">only</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#coq:tacn.abstract" title="abstract"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">abstract</span></code></a></p></li>
<li><p><span class="inline-grammar-production"><span class="target" id="grammar-token-l2_tactic"></span><code class="docutils literal notranslate"><span class="pre">l2_tactic</span></code></span>s are: <a class="reference internal" href="#coq:tacn.tryif" title="tryif"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tryif</span></code></a></p></li>
<li><p><span class="inline-grammar-production"><span class="target" id="grammar-token-l1_tactic"></span><code class="docutils literal notranslate"><span class="pre">l1_tactic</span></code></span>s are the <a class="reference internal" href="#grammar-token-simple_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">simple_tactic</span></code></a>s, <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a>, <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a>,
<a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>, <a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> and
<a class="reference internal" href="#coq:tacn.gfail" title="gfail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">gfail</span></code></a> as well as <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> and their <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">lazymatch</span></span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">multimatch</span></span></span></span></code> variants.</p></li>
<li><p><span class="inline-grammar-production"><span class="target" id="grammar-token-value_tactic"></span><code class="docutils literal notranslate"><span class="pre">value_tactic</span></code></span>s, which return values rather than change the proof state.
They are: <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.eval" title="eval"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eval</span></code></a>, <a class="reference internal" href="#coq:tacn.context" title="context"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">context</span></code></a>, <a class="reference internal" href="#coq:tacn.numgoals" title="numgoals"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">numgoals</span></code></a>, <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a>, <a class="reference internal" href="#coq:tacn.type-of" title="type of"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">type</span> <span class="pre">of</span></code></a>
and <a class="reference internal" href="#coq:tacn.type_term" title="type_term"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">type_term</span></code></a>.</p></li>
</ul>
<p>The documentation for these <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> constructs mentions which group they belong to.</p>
<p>The difference is only relevant in some compound tactics where
extra parentheses may be needed.  For example, parentheses are required in
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">idtac</span></span></span> <span><span><span class="pre">+</span></span></span> <span><span><span class="pre">(once</span></span></span> <span><span><span class="pre">idtac)</span></span></span></span></code> because <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>, which the
production <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span></span></a> <span><span><span class="pre">::=</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole"><span class="pre">ltac_expr1</span></span></a> <span><span><span class="pre">+</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole"><span class="pre">binder_tactic</span></span></a></span></span></span></code> doesn't
accept after the <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The grammar reserves the token <code class="docutils literal notranslate"><span class="pre">||</span></code>.</p></li>
</ul>
</div>
</div>
<div class="section" id="values">
<h2>Values<a class="headerlink" href="#values" title="Permalink to this headline">¶</a></h2>
<p>An <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> value can be an integer, string, unit (written as &quot;<code class="docutils literal notranslate"><span class="pre">()</span></code>&quot; ), syntactic value
or tactic.
Syntactic values correspond to certain nonterminal symbols in the grammar,
each of which is a distinct type of value.
Most commonly, the value of an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> expression is a tactic that can be executed.</p>
<p>While there are a number of constructs that let you combine multiple tactics into
compound tactics, there are no operations for combining most other types of values.
For example, there's no function to add two integers.  Syntactic values are entered
with the <a class="reference internal" href="#grammar-token-syn_value"><code class="xref std std-token docutils literal notranslate"><span class="pre">syn_value</span></code></a> construct.  Values of all types can be assigned to toplevel
symbols with the <a class="reference internal" href="#coq:cmd.Ltac" title="Ltac"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Ltac</span></code></a> command or to local symbols with the <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> tactic.
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> <a class="reference internal" href="#coq:tacn.fun" title="fun"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">functions</span></code></a> can return values of any type.</p>
<div class="section" id="syntactic-values">
<h3>Syntactic values<a class="headerlink" href="#syntactic-values" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-syn_value"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-syn_value"><span class="hole">syn_value</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:</span></span> <span><span>(</span></span> <a class="reference internal" href="#grammar-token-nonterminal"><span class="hole">nonterminal</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Provides a way to use the syntax and semantics of a grammar nonterminal as a
value in an <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>.  The table below describes the most useful of
these.  You can see the others by running &quot;<a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.Print-Grammar" title="Print Grammar"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Grammar</span></code></a> <code class="docutils literal notranslate"><span class="pre">tactic</span></code>&quot; and
examining the part at the end under &quot;Entry tactic:tactic_value&quot;.</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a></dt><dd><p>name of a grammar nonterminal listed in the table</p>
</dd>
<dt><span class="inline-grammar-production"><span class="target" id="grammar-token-nonterminal"></span><code class="docutils literal notranslate"><span class="pre">nonterminal</span></code></span></dt><dd><p>represents syntax described by <a class="reference internal" href="#grammar-token-nonterminal"><code class="xref std std-token docutils literal notranslate"><span class="pre">nonterminal</span></code></a>.</p>
</dd>
</dl>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Specified <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a></p></th>
<th class="head"><p>Parsed as</p></th>
<th class="head"><p>Interpreted as</p></th>
<th class="head"><p>as in tactic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a></p></td>
<td><p>a user-specified name</p></td>
<td><p><a class="reference internal" href="tactics.html#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a></p></td>
<td><p>a string</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">integer</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><code class="xref std std-token docutils literal notranslate"><span class="pre">integer</span></code></a></p></td>
<td><p>an integer</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">reference</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a></p></td>
<td><p>a qualified identifier</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uconstr</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a></p></td>
<td><p>an untyped term</p></td>
<td><p><a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">constr</span></code></p></td>
<td><p><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a></p></td>
<td><p>a term</p></td>
<td><p><a class="reference internal" href="tactics.html#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ltac</span></code></p></td>
<td><p><a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a></p></td>
<td><p>a tactic</p></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ltac:(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a><span><span><span class="pre">)</span></span></span></span></code> can be used to indicate that the parenthesized item
should be interpreted as a tactic and not as a term.  The constructs can also
be used to pass parameters to tactics written in OCaml.  (While all
of the <a class="reference internal" href="#grammar-token-syn_value"><code class="xref std std-token docutils literal notranslate"><span class="pre">syn_value</span></code></a>s can appear at the beginning of an <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>,
the others are not useful because they will not evaluate to tactics.)</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">uconstr:(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> can be used to build untyped terms.
Terms built in <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> are well-typed by default.  Building large
terms in recursive <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions may give very slow behavior because
terms must be fully type checked at each step.  In this case, using
an untyped term may avoid most of the repetitive type checking for the term,
improving performance.</p>
<p>Untyped terms built using <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">uconstr:(…)</span></span></span></span></code> can be used as arguments to the
<a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic, for example. In that case the untyped term is type
checked against the conclusion of the goal, and the holes which are not solved
by the typing procedure are turned into new subgoals.</p>
</div>
<div class="section" id="substitution">
<h3>Substitution<a class="headerlink" href="#substitution" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><code class="xref std std-token docutils literal notranslate"><span class="pre">name</span></code></a>s within <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> expressions are used to represent both terms and
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variables.  If the <a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><code class="xref std std-token docutils literal notranslate"><span class="pre">name</span></code></a> corresponds to
an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variable or tactic name, <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> substitutes the value before applying
the expression.  Generally it's best to choose distinctive names for <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variables
that won't clash with term names.  You can use <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ltac:(</span></span></span><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a><span><span><span class="pre">)</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a><span><span><span class="pre">)</span></span></span></span></code>
to control whether a <a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><code class="xref std std-token docutils literal notranslate"><span class="pre">name</span></code></a> is interpreted as, respectively, an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>
variable or a term.</p>
<p>Note that values from toplevel symbols, unlike locally-defined symbols, are
substituted only when they appear at the beginning of an <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> or
as a <a class="reference internal" href="#grammar-token-tactic_arg"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic_arg</span></code></a>.  Local symbols are also substituted into tactics:</p>
<div class="admonition note">
<p class="admonition-title">Example: Substitution of global and local symbols</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">n</span><span> := 1.</span><span>
</span></dt><dd><span>n is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">n2</span><span> := </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-tactic">idtac</span><span> </span><span class="coqdoc-var">n2</span><span>.</span><span>
</span></dt><dd><span>1
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">idtac</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
n not found.
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="local-definitions-let">
<h3>Local definitions: let<a class="headerlink" href="#local-definitions-let" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.let">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>let</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>rec</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-let_clause"><span class="hole">let_clause</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-let_clause"><span class="hole">let_clause</span></a></span><span class="notation-sup">*</span></span> <span><span>in</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:tacn.let" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-let_clause"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-let_clause"><span class="hole">let_clause</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Binds symbols within <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>.  <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> evaluates each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-let_clause"><span class="hole"><span class="pre">let_clause</span></span></a></span></code>, substitutes
the bound variables into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> and then evaluates <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>.  There are
no dependencies between the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-let_clause"><span class="hole"><span class="pre">let_clause</span></span></a></span></code>s.</p>
<p>Use <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> <code class="docutils literal notranslate"><span class="pre">rec</span></code> to create recursive or mutually recursive bindings, which
causes the definitions to be evaluated lazily.</p>
<p><a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> is a <a class="reference internal" href="#grammar-token-binder_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="function-construction-and-application">
<h3>Function construction and application<a class="headerlink" href="#function-construction-and-application" title="Permalink to this headline">¶</a></h3>
<p>A parameterized tactic can be built anonymously (without resorting to
local definitions) with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.fun">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>fun</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span><span>=&gt;</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:tacn.fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Indeed, local definitions of functions are syntactic sugar for binding
a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span></span></code> tactic to an identifier.</p>
<p><a class="reference internal" href="#coq:tacn.fun" title="fun"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fun</span></code></a> is a <a class="reference internal" href="#grammar-token-binder_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder_tactic</span></code></a>.</p>
</dd></dl>

<p>Functions can return values of any type.</p>
<p>A function application is an expression of the form:</p>
<dl class="coq tacn">
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-tactic_arg"><span class="hole">tactic_arg</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> must be bound to a <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> function
with at least as many arguments as the provided <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic_arg"><span class="hole"><span class="pre">tactic_arg</span></span></a></span></code>s.
The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic_arg"><span class="hole"><span class="pre">tactic_arg</span></span></a></span></code>s are evaluated before the function is applied
or partially applied.</p>
<p>Functions may be defined with the <a class="reference internal" href="#coq:tacn.fun" title="fun"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fun</span></code></a> and <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> tactics
and with the <a class="reference internal" href="#coq:cmd.Ltac" title="Ltac"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Ltac</span></code></a> command.</p>
</dd></dl>

</div>
<div class="section" id="tactics-in-terms">
<h3>Tactics in terms<a class="headerlink" href="#tactics-in-terms" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_ltac"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_ltac"><span class="hole">term_ltac</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>ltac</span></span> <span><span>:</span></span> <span><span>(</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Allows including an <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> within a term.  Semantically,
it's the same as the <a class="reference internal" href="#grammar-token-syn_value"><code class="xref std std-token docutils literal notranslate"><span class="pre">syn_value</span></code></a> for <code class="docutils literal notranslate"><span class="pre">ltac</span></code>, but these are
distinct in the grammar.</p>
</div>
</div>
<div class="section" id="goal-selectors">
<span id="id3"></span><h2>Goal selectors<a class="headerlink" href="#goal-selectors" title="Permalink to this headline">¶</a></h2>
<p>By default, tactic expressions are applied only to the first goal.  Goal
selectors provide a way to apply a tactic expression to another goal or multiple
goals.  (The <a class="reference internal" href="tactics.html#coq:opt.Default-Goal-Selector" title="Default Goal Selector"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Default</span> <span class="pre">Goal</span> <span class="pre">Selector</span></code></a> option can be used to change the default
behavior.)</p>
<dl class="coq tacn">
<dt id="coq:tacn.…-:-…-(goal-selector)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-toplevel_selector"><span class="hole">toplevel_selector</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:tacn.…-:-…-(goal-selector)" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-toplevel_selector"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-toplevel_selector"><span class="hole">toplevel_selector</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-selector"><span class="hole">selector</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>all</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>!</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>par</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Reorders the goals and applies <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> to the selected goals.  It can
only be used at the top level of a tactic expression; it cannot be used within a
tactic expression.  The selected goals are reordered so they appear after the
lowest-numbered selected goal, ordered by goal number.  <a class="reference internal" href="#reordering-goals-ex"><span class="std std-ref">Example</span></a>.  If the selector applies
to a single goal or to all goals, the reordering will not be apparent.  The order of
the goals in the <a class="reference internal" href="#grammar-token-selector"><code class="xref std std-token docutils literal notranslate"><span class="pre">selector</span></code></a> is irrelevant.  (This may not be what you expect;
see <a class="reference external" href="https://github.com/coq/coq/issues/8481">#8481</a>.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code></dt><dd><p>Selects all focused goals.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!</span></code></dt><dd><p>If exactly one goal is in focus, apply <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> to it.
Otherwise the tactic fails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">par</span></code></dt><dd><p>Applies <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> to all focused goals in parallel.
The number of workers can be controlled via the command line option
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">-async-proofs-tac-j</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> to specify the desired number of workers.
In the special case where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> is 0, this completely prevents
Coq from spawning any new process, and <code class="docutils literal notranslate"><span class="pre">par</span></code> blocks are treated as a
variant of <code class="docutils literal notranslate"><span class="pre">all</span></code> that additionally checks that each subgoal is solved.
Limitations: <code class="docutils literal notranslate"><span class="pre">par:</span></code> only works on goals that don't contain existential
variables.  <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> must either solve the goal completely or do
nothing (i.e. it cannot make some progress).</p>
</dd>
</dl>
</dd></dl>

<p>Selectors can also be used nested within a tactic expression with the
<a class="reference internal" href="#coq:tacn.only" title="only"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">only</span></code></a> tactic:</p>
<dl class="coq tacn">
<dt id="coq:tacn.only">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>only</span></span> <a class="reference internal" href="#grammar-token-selector"><span class="hole">selector</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.only" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-selector"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-selector"><span class="hole">selector</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-range_selector"><span class="hole">range_selector</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-range_selector"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-range_selector"><span class="hole">range_selector</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <span><span>-</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Applies <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a> to the selected goals.  (At the beginning of a
sentence, use the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-selector"><span class="hole"><span class="pre">selector</span></span></a><span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code> rather than <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">only</span></span></span> <a class="reference internal" href="#grammar-token-selector"><span class="hole"><span class="pre">selector</span></span></a><span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code>.
In the latter, the <a class="reference internal" href="tactics.html#coq:opt.Default-Goal-Selector" title="Default Goal Selector"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Default</span> <span class="pre">Goal</span> <span class="pre">Selector</span></code></a> (by default set to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">1:</span></span></span></span></code>)
is applied before <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">only</span></span></span></span></code> is interpreted.  This is probably not what you
want.)</p>
<p><a class="reference internal" href="#coq:tacn.only" title="only"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">only</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-range_selector"><span class="hole"><span class="pre">range_selector</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code></dt><dd><p>The selected goals are the union of the specified <a class="reference internal" href="#grammar-token-range_selector"><code class="xref std std-token docutils literal notranslate"><span class="pre">range_selector</span></code></a>s.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p>Limits the application of <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a> to the goal previously named
<a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> by the user (see <a class="reference internal" href="../language/extensions/evars.html#existential-variables"><span class="std std-ref">Existential variables</span></a>).  This works
even when the goal is not in focus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code></dt><dd><p>Selects a single goal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">-</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span><sub><span class="pre">2</span></sub></span></a></span></code></dt><dd><p>Selects the goals <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span><sub><span class="pre">1</span></sub></span></a></span></code> through <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span><sub><span class="pre">2</span></sub></span></a></span></code>, inclusive.</p>
</dd>
</dl>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.No-such-goal.-(Goal-selector)">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>such</span></span> <span><span>goal.</span></span></span></code><a class="headerlink" href="#coq:exn.No-such-goal.-(Goal-selector)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note" id="reordering-goals-ex">
<p class="admonition-title">Example: Selector reordering goals</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> 1=0 /\ 2=0 /\ 3=0.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  1</span><span> =</span><span> 0</span><span> /\</span><span> 2</span><span> =</span><span> 0</span><span> /\</span><span> 3</span><span> =</span><span> 0
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">split</span><span>.</span><span>
</span></dt><dd><span>3 goals
  
  ============================
  1</span><span> =</span><span> 0

goal 2 is:
 2</span><span> =</span><span> 0
goal 3 is:
 3</span><span> =</span><span> 0
</span></dd>
<dt><span>1,3: </span><span class="coqdoc-tactic">idtac</span><span>.</span><span>
</span></dt><dd><span>3 goals
  
  ============================
  1</span><span> =</span><span> 0

goal 2 is:
 3</span><span> =</span><span> 0
goal 3 is:
 2</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="processing-multiple-goals">
<h2>Processing multiple goals<a class="headerlink" href="#processing-multiple-goals" title="Permalink to this headline">¶</a></h2>
<p>When presented with multiple focused goals, most <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> constructs process each goal
separately.  They succeed only if there is a success for each goal.  For example:</p>
<div class="admonition note">
<p class="admonition-title">Example: Multiple focused goals</p>
<p>This tactic fails because there no match for the second goal (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True</span><span> /\</span><span> False
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">split</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  True

goal 2 is:
 False
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">numgoals</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-tactic">idtac</span><span> &quot;numgoals =&quot; </span><span class="coqdoc-var">n</span><span>;</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
| |- </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>numgoals = 2
The command has indeed failed with message:
No matching clauses for match.
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="branching-and-backtracking">
<span id="id5"></span><h2>Branching and backtracking<a class="headerlink" href="#branching-and-backtracking" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> provides several <span class="term-defn"><span class="target" id="term-branching"></span>branching</span> tactics that permit trying multiple alternative tactics
for a proof step.  For example, <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a>, which tries several alternatives and selects the first
that succeeds, or <a class="reference internal" href="#coq:tacn.tryif" title="tryif"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tryif</span></code></a>, which tests whether a given tactic would succeed or fail if it was
applied and then, depending on the result, applies one of two alternative tactics.  There
are also looping constructs <a class="reference internal" href="#coq:tacn.do" title="do"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">do</span></code></a> and <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>.  The order in which the subparts
of these tactics are evaluated is generally similar to
structured programming constructs in many languages.</p>
<p>The <a class="reference internal" href="#coq:tacn.+-(backtracking-branching)" title="+ (backtracking branching)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">+</span></code></a>, <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a> and <a class="reference internal" href="#coq:tacn.multimatch-goal" title="multimatch goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span> <span class="pre">goal</span></code></a> tactics
provide more complex capability.  Rather than applying a single successful
tactic, these tactics generate a series of successful tactic alternatives that are tried sequentially
when subsequent tactics outside these constructs fail.  For example:</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Example: Backtracking</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-var">multimatch</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 1&quot;</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 2&quot;</span><span>
</span><span class="coqdoc-keyword">end</span><span> ;</span><span>
</span><span class="coqdoc-tactic">idtac</span><span> &quot;branch A&quot;; </span><span class="coqdoc-tactic">fail</span><span>.</span><span>
</span></dt><dd><span>branch 1
branch A
branch 2
branch A
The command has indeed failed with message:
Tactic failure.
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<p>These constructs are evaluated using <span class="term-defn"><span class="target" id="term-backtracking"></span>backtracking</span>.  Each  creates a
<span class="term-defn"><span class="target" id="term-backtracking-point"></span>backtracking point</span>.  When a subsequent tactic fails, evaluation continues from the nearest
prior backtracking point with the next successful alternative and repeats the tactics after
the backtracking point.  When a backtracking point has
no more successful alternatives, evaluation continues from the next prior backtracking point.
If there are no more prior backtracking points, the overall tactic fails.</p>
<p>Thus, backtracking tactics can have multiple successes.  Non-backtracking constructs that appear
after a backtracking point are reprocessed after backtracking, as in the example
above, in which the <a class="reference internal" href="#coq:tacn.ltac-seq" title="ltac-seq"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">;</span></code></a> construct is reprocessed after backtracking.  When a
backtracking construct is within
a non-backtracking construct, the latter uses the <span class="term-defn"><span class="target" id="term-first-success"></span>first success</span>.  Backtracking to
a point within a non-backtracking construct won't change the branch that was selected by the
non-backtracking construct.</p>
<p>The <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> tactic stops further backtracking to backtracking points within that tactic.</p>
</div>
<div class="section" id="control-flow">
<h2>Control flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sequence">
<h3>Sequence: ;<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h3>
<p>A sequence is an expression of the following form:</p>
<dl class="coq tacn">
<dt id="coq:tacn.ltac-seq">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3<sub>1</sub></span></a> <span><span>;</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3<sub>2</sub></span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></code><a class="headerlink" href="#coq:tacn.ltac-seq" title="Permalink to this definition">¶</a></dt>
<dd><p>The expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span><sub><span class="pre">1</span></sub></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">v</span></span><sub><span class="pre">1</span></sub></span></span></code>, which must be
a tactic value. The tactic <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">v</span></span><sub><span class="pre">1</span></sub></span></span></code> is applied to the current goals,
possibly producing more goals. Then the right-hand side is evaluated to
produce <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">v</span></span><sub><span class="pre">2</span></sub></span></span></code>, which must be a tactic value. The tactic
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">v</span></span><sub><span class="pre">2</span></sub></span></span></code> is applied to all the goals produced by the prior
application. Sequence is associative.</p>
<p>This construct uses backtracking: if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span><sub><span class="pre">2</span></sub></span></a></span></code> fails, Coq will
try each alternative success (if any) for <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span><sub><span class="pre">1</span></sub></span></a></span></code>, retrying
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span><sub><span class="pre">2</span></sub></span></a></span></code> for each until both tactics succeed or all alternatives
have failed.  See <a class="reference internal" href="#branching-and-backtracking"><span class="std std-ref">Branching and backtracking</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If you want <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></a></span></code> to be fully applied to the first
subgoal generated by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a></span></code> before applying it to the other
subgoals, then you should write:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">[&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></a> <span><span><span class="pre">..</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> rather than</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">)</span></span></span></span></code>.</p></li>
</ul>
</li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="do-loop">
<h3>Do loop<a class="headerlink" href="#do-loop" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.do">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>do</span></span> <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><span class="hole">nat_or_var</span></a> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.do" title="Permalink to this definition">¶</a></dt>
<dd><p>The do loop repeats a tactic <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><code class="xref std std-token docutils literal notranslate"><span class="pre">nat_or_var</span></code></a> times:</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code>, which must be a tactic value. This tactic
value <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><code class="xref std std-token docutils literal notranslate"><span class="pre">nat_or_var</span></code></a> times. If <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><code class="xref std std-token docutils literal notranslate"><span class="pre">nat_or_var</span></code></a> &gt; 1, after the
first application of <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied, at least once, to the generated
subgoals and so on. It fails if the application of <code class="docutils literal notranslate"><span class="pre">v</span></code> fails before <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><code class="xref std std-token docutils literal notranslate"><span class="pre">nat_or_var</span></code></a>
applications have been completed.</p>
<p><a class="reference internal" href="#coq:tacn.do" title="do"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">do</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="repeat-loop">
<h3>Repeat loop<a class="headerlink" href="#repeat-loop" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.repeat">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>repeat</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>The repeat loop repeats a tactic until it fails or doesn't change the proof context.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> denotes a tactic, this tactic is
applied to each focused goal independently. If the application succeeds, the
tactic is applied recursively to all the generated subgoals until it eventually
fails. The recursion stops in a subgoal when the tactic has failed <em>to make
progress</em>. The tactic <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> itself never fails.</p>
<p><a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="catching-errors-try">
<h3>Catching errors: try<a class="headerlink" href="#catching-errors-try" title="Permalink to this headline">¶</a></h3>
<p>We can catch the tactic errors with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.try">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>try</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.try" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic
value <code class="docutils literal notranslate"><span class="pre">v</span></code> is applied to each focused goal independently. If the application of
<code class="docutils literal notranslate"><span class="pre">v</span></code> fails in a goal, it catches the error and leaves the goal unchanged. If the
level of the exception is positive, then the exception is re-raised with its
level decremented.</p>
<p><a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="conditional-branching-tryif">
<h3>Conditional branching: tryif<a class="headerlink" href="#conditional-branching-tryif" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.tryif">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>tryif</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr<sub>test</sub></span></a> <span><span>then</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr<sub>then</sub></span></a> <span><span>else</span></span> <a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2<sub>else</sub></span></a></span></code><a class="headerlink" href="#coq:tacn.tryif" title="Permalink to this definition">¶</a></dt>
<dd><p>For each focused goal, independently: Evaluate and apply <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">test</span></sub></span></a></span></code>.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">test</span></sub></span></a></span></code> succeeds at least once, evaluate and apply <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">then</span></sub></span></a></span></code>
to all the subgoals generated by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">test</span></sub></span></a></span></code>.  Otherwise, evaluate and apply
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span><sub><span class="pre">else</span></sub></span></a></span></code> to all the subgoals generated by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">test</span></sub></span></a></span></code>.</p>
<p><a class="reference internal" href="#coq:tacn.tryif" title="tryif"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tryif</span></code></a> is an <a class="reference internal" href="#grammar-token-l2_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l2_tactic</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="branching-with-backtracking">
<h3>Branching with backtracking: +<a class="headerlink" href="#branching-with-backtracking" title="Permalink to this headline">¶</a></h3>
<p>We can branch with backtracking with the following structure:</p>
<dl class="coq tacn">
<dt id="coq:tacn.+-(backtracking-branching)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a> <span><span>+</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></code><a class="headerlink" href="#coq:tacn.+-(backtracking-branching)" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates and applies <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole"><span class="pre">ltac_expr1</span></span></a></span></code> to each focused goal independently.  If it fails
(i.e. there is no initial success), then evaluates and applies the right-hand side.  If the
right-hand side fails, the construct fails.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ltac</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">expr1</span></span></span></span></code> has an initial success and a subsequent tactic (outside the <code class="docutils literal notranslate"><span class="pre">+</span></code> construct)
fails, <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> backtracks and selects the next success for <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ltac</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">expr1</span></span></span></span></code>.  If there are
no more successes, then <code class="docutils literal notranslate"><span class="pre">+</span></code> similarly evaluates and applies (and backtracks in) the right-hand side.
To prevent evaluation of further alternatives after an initial success for a tactic, use <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">+</span></code> is left-associative.</p>
<p>In all cases, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">+</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">);</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></a></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">)</span></span></span> <span><span><span class="pre">+</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">;</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">)</span></span></span></span></code>.</p>
<p>Additionally, in most cases, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">+</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">)</span></span></span> <span><span><span class="pre">+</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></a></span></code> is
equivalent to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">+</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">2</span></sub></span></a> <span><span><span class="pre">+</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">3</span></sub></span></a><span><span><span class="pre">)</span></span></span></span></code>.
Here's an example where the behavior differs slightly:</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> (</span><span class="coqdoc-tactic">fail</span><span> 2 + </span><span class="coqdoc-tactic">idtac</span><span>) + </span><span class="coqdoc-tactic">idtac</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Tactic failure.
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">fail</span><span> 2 + (</span><span class="coqdoc-tactic">idtac</span><span> + </span><span class="coqdoc-tactic">idtac</span><span>).</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Tactic failure (level 1).
</span></dd>
</dl>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example: Backtracking branching with +</p>
<p>In the first tactic, <code class="docutils literal notranslate"><span class="pre">idtac</span> <span class="pre">&quot;2&quot;</span></code> is not executed.  In the second, the subsequent <code class="docutils literal notranslate"><span class="pre">fail</span></code> causes
backtracking and the execution of <code class="docutils literal notranslate"><span class="pre">idtac</span> <span class="pre">&quot;B&quot;</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">idtac</span><span> &quot;1&quot; + </span><span class="coqdoc-tactic">idtac</span><span> &quot;2&quot;.</span><span>
</span></dt><dd><span>1
</span></dd>
<dt><span></span><span class="coqdoc-var">assert_fails</span><span> ((</span><span class="coqdoc-tactic">idtac</span><span> &quot;A&quot; + </span><span class="coqdoc-tactic">idtac</span><span> &quot;B&quot;); </span><span class="coqdoc-tactic">fail</span><span>).</span><span>
</span></dt><dd><span>A
B
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="local-application-of-tactics">
<h3>Local application of tactics: [&gt; ... ]<a class="headerlink" href="#local-application-of-tactics" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.[&gt;-…-|-…-|-…-]-(dispatch)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>[&gt;</span></span> <a class="reference internal" href="#grammar-token-for_each_goal"><span class="hole">for_each_goal</span></a> <span><span>]</span></span></span></code><a class="headerlink" href="#coq:tacn.[>-…-|-…-|-…-]-(dispatch)" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-for_each_goal"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-for_each_goal"><span class="hole">for_each_goal</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole">goal_tactics</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole">goal_tactics</span></a> <span><span>|</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span><span class="notation-sup">?</span></span> <span><span>..</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span> <a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole">goal_tactics</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-goal_tactics"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole">goal_tactics</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Applies a different <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> to each of the focused goals.  In the first
form of <a class="reference internal" href="#grammar-token-for_each_goal"><code class="xref std std-token docutils literal notranslate"><span class="pre">for_each_goal</span></code></a> (without <code class="docutils literal notranslate"><span class="pre">..</span></code>), the construct fails if the number of specified
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> is not the same as the number of focused goals.  Omitting an
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> leaves the corresponding goal unchanged.</p>
<p>In the second form (with <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">..</span></span></span></span></code>), the left and right <a class="reference internal" href="#grammar-token-goal_tactics"><code class="xref std std-token docutils literal notranslate"><span class="pre">goal_tactics</span></code></a>
are applied respectively to a prefix or suffix of the list of focused goals.
The <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> before the <code class="docutils literal notranslate"><span class="pre">..</span></code> is applied to any focused goals in the middle
(possibly none) that are not covered by the <a class="reference internal" href="#grammar-token-goal_tactics"><code class="xref std std-token docutils literal notranslate"><span class="pre">goal_tactics</span></code></a>.  The number of
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> in the <a class="reference internal" href="#grammar-token-goal_tactics"><code class="xref std std-token docutils literal notranslate"><span class="pre">goal_tactics</span></code></a> must be no more than the number of
focused goals.</p>
<p>In particular:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole"><span class="pre">goal_tactics</span></span></a> <span class="pre">|</span> <span><span><span class="pre">..</span></span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-goal_tactics"><span class="hole"><span class="pre">goal_tactics</span></span></a></span></code></dt><dd><p>The goals not covered by the two <a class="reference internal" href="#grammar-token-goal_tactics"><code class="xref std std-token docutils literal notranslate"><span class="pre">goal_tactics</span></code></a> are left unchanged.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[&gt;</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a> <span><span><span class="pre">..</span></span></span> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is applied independently to each of
the goals, rather than globally. In particular, if there are no goals, the
tactic is not run at all. A tactic which expects multiple goals, such as
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#coq:tacn.swap" title="swap"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">swap</span></code></a>, would act as if a single goal is focused.</p>
</dd>
</dl>
<p>Note that <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">[</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> is a convenient idiom to
process the goals generated by applying <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.[-…-|-…-|-…-]-(dispatch)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a> <span><span>;</span></span> <span><span>[</span></span> <a class="reference internal" href="#grammar-token-for_each_goal"><span class="hole">for_each_goal</span></a> <span><span>]</span></span></span></code><a class="headerlink" href="#coq:tacn.[-…-|-…-|-…-]-(dispatch)" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">[</span></span></span> <span><span><span class="pre">...</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[&gt;</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">[&gt;</span></span></span> <span><span><span class="pre">...</span></span></span> <span><span><span class="pre">]</span></span></span> <span><span><span class="pre">..</span></span></span> <span><span><span class="pre">]</span></span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="first-tactic-to-succeed">
<h3>First tactic to succeed<a class="headerlink" href="#first-tactic-to-succeed" title="Permalink to this headline">¶</a></h3>
<p>In some cases backtracking may be too expensive.</p>
<dl class="coq tacn">
<dt id="coq:tacn.first">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>first</span></span> <span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></code><a class="headerlink" href="#coq:tacn.first" title="Permalink to this definition">¶</a></dt>
<dd><p>For each focused goal, independently apply the first <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> that succeeds.
The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>s must evaluate to tactic values.
Failures in tactics after the <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> won't cause backtracking.
(To allow backtracking, use the <a class="reference internal" href="#coq:tacn.+-(backtracking-branching)" title="+ (backtracking branching)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">+</span></code></a>
construct above instead.)</p>
<p>If the <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> contains a tactic that can backtrack, &quot;success&quot; means
the first success of that tactic.  Consider the following:</p>
<div class="admonition note">
<p class="admonition-title">Example: Backtracking inside a non-backtracking construct</p>
<div class="coqtop literal-block coqtop-hidden docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
</div>
<p>The <a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> doesn't trigger the second <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">assert_fails</span><span> (</span><span class="coqdoc-tactic">first</span><span> [ </span><span class="coqdoc-tactic">idtac</span><span> &quot;1&quot; | </span><span class="coqdoc-tactic">idtac</span><span> &quot;2&quot; ]; </span><span class="coqdoc-tactic">fail</span><span>).</span><span>
</span></dt><dd><span>1
</span></dd>
</dl>
</div>
<p>This backtracks within <code class="docutils literal notranslate"><span class="pre">(idtac</span> <span class="pre">&quot;1A&quot;</span> <span class="pre">+</span> <span class="pre">idtac</span> <span class="pre">&quot;1B&quot;</span> <span class="pre">+</span> <span class="pre">fail)</span></code> but
<a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> won't consider the <code class="docutils literal notranslate"><span class="pre">idtac</span> <span class="pre">&quot;2&quot;</span></code> alternative:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">assert_fails</span><span> (</span><span class="coqdoc-tactic">first</span><span> [ (</span><span class="coqdoc-tactic">idtac</span><span> &quot;1A&quot; + </span><span class="coqdoc-tactic">idtac</span><span> &quot;1B&quot; + </span><span class="coqdoc-tactic">fail</span><span>) | </span><span class="coqdoc-tactic">idtac</span><span> &quot;2&quot; ]; </span><span class="coqdoc-tactic">fail</span><span>).</span><span>
</span></dt><dd><span>1A
1B
</span></dd>
</dl>
</div>
</div>
<p><a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> is an <a class="reference internal" href="#grammar-token-l1_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l1_tactic</span></code></a>.</p>
<dl class="coq exn">
<dt id="coq:exn.No-applicable-tactic">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>applicable</span></span> <span><span>tactic.</span></span></span></code><a class="headerlink" href="#coq:exn.No-applicable-tactic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>first</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code></dt>
<dd><p>This is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> alias that gives a primitive access to the first
tactical as an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> definition without going through a parsing rule. It
expects to be given a list of tactics through a <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.Tactic-Notation" title="Tactic Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Tactic</span> <span class="pre">Notation</span></code></a> command,
permitting notations with the following form to be written:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Tactic Notation</span><span> &quot;foo&quot; </span><span class="coqdoc-var">tactic_list</span><span>(</span><span class="coqdoc-var">tacs</span><span>) := </span><span class="coqdoc-tactic">first</span><span> </span><span class="coqdoc-var">tacs</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="solving">
<h3>Solving<a class="headerlink" href="#solving" title="Permalink to this headline">¶</a></h3>
<p>Selects and applies the first tactic that solves each goal (i.e. leaves no subgoal)
in a series of alternative tactics:</p>
<dl class="coq tacn">
<dt id="coq:tacn.solve">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>solve</span></span> <span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr<sub>i</sub></span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></code><a class="headerlink" href="#coq:tacn.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>For each current subgoal: evaluates and applies each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> in order
until one is found that solves the subgoal.</p>
<p>If any of the subgoals are not solved, then the overall <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a> fails.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a> and <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a>, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>s that don't
evaluate to tactic values are ignored.  So <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a> <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">()</span> <span class="pre">|</span> <span class="pre">1</span> <span class="pre">|</span></code> <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a> <code class="docutils literal notranslate"><span class="pre">]</span></code>
is equivalent to <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a> <code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a> <code class="docutils literal notranslate"><span class="pre">]</span></code>.
This may make it harder to debug scripts that inadvertently include non-tactic values.</p>
</div>
<p><a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a> is an <a class="reference internal" href="#grammar-token-l1_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l1_tactic</span></code></a>.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>solve</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code></dt>
<dd><p>This is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> alias that gives a primitive access to the <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a>
tactic. See the <a class="reference internal" href="#coq:tacn.first" title="first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">first</span></code></a> tactic for more information.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="first-tactic-to-make-progress">
<h3>First tactic to make progress: ||<a class="headerlink" href="#first-tactic-to-make-progress" title="Permalink to this headline">¶</a></h3>
<p>Yet another way of branching without backtracking is the following
structure:</p>
<dl class="coq tacn">
<dt id="coq:tacn.||-(first-tactic-making-progress)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole">ltac_expr1</span></a> <span><span>||</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole">ltac_expr2</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-binder_tactic"><span class="hole">binder_tactic</span></a></span></span></span></code><a class="headerlink" href="#coq:tacn.||-(first-tactic-making-progress)" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole"><span class="pre">ltac_expr1</span></span></a> <span class="pre">|</span><span class="pre">|</span> <a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span></span></a></span></code> is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">first</span></span></span> <span><span><span class="pre">[</span></span></span> <span><span><span class="pre">progress</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr1"><span class="hole"><span class="pre">ltac_expr1</span></span></a> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span></span></a> <span><span><span class="pre">]</span></span></span></span></code>, except that
if it fails, it fails like <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr2"><span class="hole"><span class="pre">ltac_expr2</span></span></a><span><span><span class="pre">.</span></span></span> <span>`</span><span class="pre">|</span><span class="pre">|</span></span></code> is left-associative.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>s that don't evaluate to tactic values are ignored.  See the
note at <a class="reference internal" href="#coq:tacn.solve" title="solve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">solve</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="detecting-progress">
<h3>Detecting progress<a class="headerlink" href="#detecting-progress" title="Permalink to this headline">¶</a></h3>
<p>We can check if a tactic made progress with:</p>
<dl class="coq tacn">
<dt id="coq:tacn.progress">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>progress</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.progress" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value <code class="docutils literal notranslate"><span class="pre">v</span></code>
is applied to each focused subgoal independently. If the application of <code class="docutils literal notranslate"><span class="pre">v</span></code>
to one of the focused subgoal produced subgoals equal to the initial
goals (up to syntactical equality), then an error of level 0 is raised.</p>
<p><a class="reference internal" href="#coq:tacn.progress" title="progress"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">progress</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
<dl class="coq exn">
<dt id="coq:exn.Failed-to-progress">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Failed</span></span> <span><span>to</span></span> <span><span>progress.</span></span></span></code><a class="headerlink" href="#coq:exn.Failed-to-progress" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="success-and-failure">
<h2>Success and failure<a class="headerlink" href="#success-and-failure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="checking-for-success-assert-succeeds">
<h3>Checking for success: assert_succeeds<a class="headerlink" href="#checking-for-success-assert-succeeds" title="Permalink to this headline">¶</a></h3>
<p>Coq defines an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactic in <code class="docutils literal notranslate"><span class="pre">Init.Tactics</span></code> to check that a tactic has <em>at least one</em>
success:</p>
<dl class="coq tacn">
<dt id="coq:tacn.assert_succeeds">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>assert</span></span><span><span>_</span></span><span><span>succeeds</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.assert_succeeds" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> has at least one success, the proof state is unchanged and
no message is printed.  If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> fails, the tactic fails with the same error.</p>
</dd></dl>

</div>
<div class="section" id="checking-for-failure-assert-fails">
<h3>Checking for failure: assert_fails<a class="headerlink" href="#checking-for-failure-assert-fails" title="Permalink to this headline">¶</a></h3>
<p>Coq defines an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactic in <code class="docutils literal notranslate"><span class="pre">Init.Tactics</span></code> to check that a tactic <em>fails</em>:</p>
<dl class="coq tacn">
<dt id="coq:tacn.assert_fails">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>assert</span></span><span><span>_</span></span><span><span>fails</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.assert_fails" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> fails, the proof state is unchanged and no message is printed.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> unexpectedly has at least one success, the tactic performs
a <a class="reference internal" href="#coq:tacn.gfail" title="gfail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">gfail</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">0</span></span></span></span></code>, printing the following message:</p>
<dl class="coq exn">
<dt id="coq:exn.Tactic-failure:-&lt;tactic-closure&gt;-succeeds">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Tactic</span></span> <span><span>failure:</span></span> <span><span>&lt;tactic</span></span> <span><span>closure&gt;</span></span> <span><span>succeeds.</span></span></span></code><a class="headerlink" href="#coq:exn.Tactic-failure:-<tactic-closure>-succeeds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#coq:tacn.assert_fails" title="assert_fails"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_fails</span></code></a> and <a class="reference internal" href="#coq:tacn.assert_succeeds" title="assert_succeeds"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_succeeds</span></code></a> work as described when
<a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a> is a <a class="reference internal" href="#grammar-token-simple_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">simple_tactic</span></code></a>.  In some more complex expressions,
they may report an error from within <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a> when they shouldn't.
This is due to the order in which parts of the <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a>
are evaluated and executed.  For example:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">assert_fails</span><span> </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">fail</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>Toplevel input, characters 0-43:
&gt; assert_fails match True with _ =&gt; fail end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Tactic failure.
</span></dd>
</dl>
</div>
<p>should not show any message.  The issue is that <a class="reference internal" href="#coq:tacn.assert_fails" title="assert_fails"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_fails</span></code></a> is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>-defined
tactic.  That makes it a function that's processed in the evaluation phase, causing
the <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> to find its first success earlier.  One workaround
is to prefix <a class="reference internal" href="#grammar-token-ltac_expr3"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr3</span></code></a> with &quot;<code class="docutils literal notranslate"><span class="pre">idtac;</span></code>&quot;.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-var">assert_fails</span><span> (</span><span class="coqdoc-tactic">idtac</span><span>; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">fail</span><span> </span><span class="coqdoc-keyword">end</span><span>).</span><span>
</span></dt></dl>
</div>
<p>Alternatively, substituting the <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> into the definition of <a class="reference internal" href="#coq:tacn.assert_fails" title="assert_fails"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_fails</span></code></a> works
as expected:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-var">tryif</span><span> (</span><span class="coqdoc-var">once</span><span> </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">fail</span><span> </span><span class="coqdoc-keyword">end</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">gfail</span><span> 0 </span><span class="coqdoc-comment">(* tac *)</span><span> &quot;succeeds&quot; </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-tactic">idtac</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="failing">
<h3>Failing<a class="headerlink" href="#failing" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.fail">
<span id="coq:tacn.gfail"></span><em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>fail</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>gfail</span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><span class="hole">nat_or_var</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.fail" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> is the always-failing tactic: it does not solve any
goal. It is useful for defining other tactics since it can be caught by
<a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a>, or the branching tacticals.</p>
<p><a class="reference internal" href="#coq:tacn.gfail" title="gfail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">gfail</span></code></a> fails even when used after <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">;</span></span></span></span></code> and there are no goals left.
Similarly, <a class="reference internal" href="#coq:tacn.gfail" title="gfail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">gfail</span></code></a> fails even when used after <code class="docutils literal notranslate"><span class="pre">all:</span></code> and there are no
goals left.</p>
<p><a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> and <a class="reference internal" href="#coq:tacn.gfail" title="gfail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">gfail</span></code></a> are <a class="reference internal" href="#grammar-token-l1_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l1_tactic</span></code></a>s.</p>
<p>See the example for a comparison of the two constructs.</p>
<p>Note that if Coq terms have to be
printed as part of the failure, term construction always forces the
tactic into the goals, meaning that if there are no goals when it is
evaluated, a tactic call like <a class="reference internal" href="#coq:tacn.let" title="let"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">let</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x</span></span></span> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">H</span></span></span> <span><span><span class="pre">in</span></span></span></span></code> <a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">x</span></code> will succeed.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a></span></code></dt><dd><p>The failure level. If no level is specified, it defaults to 0.
The level is used by <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>, <a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> and the branching
tacticals. If 0, it makes <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> consider the next clause
(backtracking). If nonzero, the current <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> block, <a class="reference internal" href="#coq:tacn.try" title="try"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">try</span></code></a>,
<a class="reference internal" href="#coq:tacn.repeat" title="repeat"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">repeat</span></code></a>, or branching command is aborted and the level is decremented. In
the case of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">+</span></span></span></span></code>, a nonzero level skips the first backtrack point, even if
the call to <a class="reference internal" href="#coq:tacn.fail" title="fail"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fail</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> is not enclosed in a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">+</span></span></span></span></code> construct,
respecting the algebraic identity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code></dt><dd><p>The given tokens are used for printing the failure message.  If <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variable, its contents are printed; if not, it is an error.</p>
</dd>
</dl>
<dl class="coq exn">
<dt id="coq:exn.Tactic-failure">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Tactic</span></span> <span><span>failure.</span></span></span></code><a class="headerlink" href="#coq:exn.Tactic-failure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.Tactic-failure-(level-‘natural’)">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Tactic</span></span> <span><span>failure</span></span> <span><span>(level</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a><span><span>).</span></span></span></code><a class="headerlink" href="#coq:exn.Tactic-failure-(level-‘natural’)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.No-such-goal.-(fail)">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>such</span></span> <span><span>goal.</span></span></span></code><a class="headerlink" href="#coq:exn.No-such-goal.-(fail)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">fail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
Toplevel input, characters 7-12:
&gt; Proof. fail.
&gt;        ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Tactic failure.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>; </span><span class="coqdoc-tactic">fail</span><span>. </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd><span>
No more goals.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>. </span><span class="coqdoc-tactic">fail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
No more goals.

Toplevel input, characters 16-21:
&gt; Proof. trivial. fail.
&gt;                 ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> No such goal.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>. </span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-tactic">fail</span><span>. </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd><span>
No more goals.


</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-var">gfail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
Toplevel input, characters 7-13:
&gt; Proof. gfail.
&gt;        ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Tactic failure.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>; </span><span class="coqdoc-var">gfail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
Toplevel input, characters 7-22:
&gt; Proof. trivial; gfail.
&gt;        ^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Tactic failure.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>. </span><span class="coqdoc-var">gfail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
No more goals.

Toplevel input, characters 16-22:
&gt; Proof. trivial. gfail.
&gt;                 ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> No such goal.

</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">trivial</span><span>. </span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">gfail</span><span>. </span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dd><span>
No more goals.

Toplevel input, characters 16-27:
&gt; Proof. trivial. all: gfail.
&gt;                 ^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Tactic failure.

</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="soft-cut-once">
<h3>Soft cut: once<a class="headerlink" href="#soft-cut-once" title="Permalink to this headline">¶</a></h3>
<p>Another way of restricting backtracking is to restrict a tactic to a
single success:</p>
<dl class="coq tacn">
<dt id="coq:tacn.once">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>once</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.once" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied but only its first success is used. If <code class="docutils literal notranslate"><span class="pre">v</span></code> fails,
<a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> fails like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has at least one success,
<a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> succeeds once, but cannot produce more successes.</p>
<p><a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="checking-for-a-single-success-exactly-once">
<h3>Checking for a single success: exactly_once<a class="headerlink" href="#checking-for-a-single-success-exactly-once" title="Permalink to this headline">¶</a></h3>
<p>Coq provides an experimental way to check that a tactic has <em>exactly
one</em> success:</p>
<dl class="coq tacn">
<dt id="coq:tacn.exactly_once">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>exactly</span></span><span><span>_</span></span><span><span>once</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.exactly_once" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied if it has at most one success. If <code class="docutils literal notranslate"><span class="pre">v</span></code> fails,
<a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> fails like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has a exactly one success,
<a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> succeeds like <code class="docutils literal notranslate"><span class="pre">v</span></code>. If <code class="docutils literal notranslate"><span class="pre">v</span></code> has two or more
successes, <a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> fails.</p>
<p><a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The experimental status of this tactic pertains to the fact if <code class="docutils literal notranslate"><span class="pre">v</span></code>
has side effects, they may occur in an unpredictable way. Indeed,
normally <code class="docutils literal notranslate"><span class="pre">v</span></code> would only be executed up to the first success until
backtracking is needed, however <a class="reference internal" href="#coq:tacn.exactly_once" title="exactly_once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exactly_once</span></code></a> needs to look ahead to see
whether a second success exists, and may run further effects
immediately.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.This-tactic-has-more-than-one-success">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>This</span></span> <span><span>tactic</span></span> <span><span>has</span></span> <span><span>more</span></span> <span><span>than</span></span> <span><span>one</span></span> <span><span>success.</span></span></span></code><a class="headerlink" href="#coq:exn.This-tactic-has-more-than-one-success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="manipulating-values">
<h2>Manipulating values<a class="headerlink" href="#manipulating-values" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pattern-matching-on-terms-match">
<h3>Pattern matching on terms: match<a class="headerlink" href="#pattern-matching-on-terms-match" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.lazymatch">
<span id="coq:tacn.match"></span><span id="coq:tacn.multimatch"></span><em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-match_key"><span class="hole">match_key</span></a> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr<sub>term</sub></span></a> <span><span>with</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a> <span><span>=&gt;</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>end</span></span></span></code><a class="headerlink" href="#coq:tacn.lazymatch" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-match_key"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-match_key"><span class="hole">match_key</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>lazymatch</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>match</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>multimatch</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-match_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>context</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span><span>[</span></span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-cpattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole">cpattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p><a class="reference internal" href="#coq:tacn.lazymatch" title="lazymatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazymatch</span></code></a>, <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> and <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a> are <a class="reference internal" href="#grammar-token-ltac_expr1"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr1</span></code></a>s.</p>
<p>Evaluates <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">term</span></sub></span></a></span></code>, which must yield a term, and matches it
sequentially with the <a class="reference internal" href="#grammar-token-match_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_pattern</span></code></a>s, which may have
metavariables.  When a match is found, metavariable values are substituted
into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>, which is then applied.</p>
<p>Matching may continue depending on whether  <code class="docutils literal notranslate"><span class="pre">lazymatch</span></code>, <code class="docutils literal notranslate"><span class="pre">match</span></code> or <code class="docutils literal notranslate"><span class="pre">multimatch</span></code>
is specified.</p>
<p>In the <a class="reference internal" href="#grammar-token-match_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_pattern</span></code></a>s, metavariables have the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, whereas
in the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>s, the question mark is omitted.  Choose your metavariable
names with care to avoid name conflicts.  For example, if you use the metavariable <code class="docutils literal notranslate"><span class="pre">S</span></code>,
then the <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> can't use <code class="docutils literal notranslate"><span class="pre">S</span></code> to refer to the constructor of <code class="docutils literal notranslate"><span class="pre">nat</span></code>
without qualifying the constructor as <code class="docutils literal notranslate"><span class="pre">Datatypes.S</span></code>.</p>
<p>Matching is non-linear: if a
metavariable occurs more than once, each occurrence must match the same
expression.  Expressions match if they are syntactically equal or are
<a class="reference internal" href="../language/core/conversion.html#term-alpha-convertible"><span class="xref std std-term">α-convertible</span></a>.
Matching is first-order except on variables of the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&#64;</span></span></span><span><span><span class="pre">?</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
that occur in the head position of an application. For these variables,
matching is second-order and returns a functional term.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">lazymatch</span></code></dt><dd><p>Causes the match to commit to the first matching branch
rather than trying a new match if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> fails.
<a class="reference internal" href="#match-vs-lazymatch-ex"><span class="std std-ref">Example</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> fails, continue matching with the next branch.
Failures in subsequent tactics (after the <code class="docutils literal notranslate"><span class="pre">match</span></code>) will not cause selection
of a new branch.  Examples <a class="reference internal" href="#match-vs-lazymatch-ex"><span class="std std-ref">here</span></a> and
<a class="reference internal" href="#match-vs-multimatch-ex"><span class="std std-ref">here</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">multimatch</span></code></dt><dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> fails, continue matching with the next branch.
When an <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> succeeds for a branch, subsequent failures
(after the <code class="docutils literal notranslate"><span class="pre">multimatch</span></code>) causing consumption of all the successes
of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> trigger selection of a new matching branch.
<a class="reference internal" href="#match-vs-multimatch-ex"><span class="std std-ref">Example</span></a>.</p>
<p><a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">…</span></span></span></span></code> is, in fact, shorthand for <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a> <code class="docutils literal notranslate"><span class="pre">…</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-cpattern"><span class="hole"><span class="pre">cpattern</span></span></a></span></code></dt><dd><p>The syntax of <a class="reference internal" href="#grammar-token-cpattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">cpattern</span></code></a> is
the same as that of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>s, but it can contain pattern matching
metavariables in the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.  <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code> can be used to match
irrelevant terms.  <a class="reference internal" href="#match-with-holes-ex"><span class="std std-ref">Example</span></a>.</p>
<p>When a metavariable in the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?id</span></span></span></span></code> occurs under binders,
say <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x</span></span><sub><span class="pre">1</span></sub></span><span><span><span class="pre">,</span></span></span> <span><span><span class="pre">…,</span></span></span> <span><span><span class="pre">x</span></span><sub><span class="pre">n</span></sub></span></span></code> and the expression matches, the
metavariable is instantiated by a term which can then be used in any
context which also binds the variables <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x</span></span><sub><span class="pre">1</span></sub></span><span><span><span class="pre">,</span></span></span> <span><span><span class="pre">…,</span></span></span> <span><span><span class="pre">x</span></span><sub><span class="pre">n</span></sub></span></span></code> with
same types. This provides with a primitive form of matching under
context which does not require manipulating a functional term.</p>
<p>There is also a special notation for second-order pattern matching: in an
applicative pattern of the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&#64;</span></span></span><span><span><span class="pre">?</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">…</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">n</span></sub></span></a></span></code>,
the variable <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> matches any complex expression with (possible)
dependencies in the variables <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code> and returns a functional term
of the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">…</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd>
</dl>
<dl id="match-term-context">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">context</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-cpattern"><span class="hole"><span class="pre">cpattern</span></span></a> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p>Matches any term with a subterm matching <a class="reference internal" href="#grammar-token-cpattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">cpattern</span></code></a>. If there is a match
and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is present, it is assigned the &quot;matched
context&quot;, i.e. the initial term where the matched subterm is replaced by a
hole.  Note that <code class="docutils literal notranslate"><span class="pre">context</span></code>
(with very similar syntax) appearing after the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> is the <a class="reference internal" href="#coq:tacn.context" title="context"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">context</span></code></a> tactic.</p>
<p>For <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> and <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a>, if the evaluation of the <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>
fails, the next matching subterm is tried. If no further subterm matches, the next branch
is tried.  Matching subterms are considered from top to bottom and from left to
right (with respect to the raw printing obtained by setting the
<a class="reference internal" href="vernacular-commands.html#coq:flag.Printing-All" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag).  <a class="reference internal" href="#match-term-context-ex"><span class="std std-ref">Example</span></a>.</p>
</dd>
</dl>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code></dt><dd><p>The tactic to apply if the construct matches.  Metavariable values from the pattern
match are substituted
into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> before it's applied.  Note that metavariables are not
prefixed with the question mark as they are in <a class="reference internal" href="#grammar-token-cpattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">cpattern</span></code></a>.</p>
<p>If <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> evaluates to a tactic, then it is
applied. If the tactic succeeds, the result of the match expression is
<a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>.  If <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> does not evaluate
to a tactic, that value is the result of the match expression.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> is a tactic with backtracking points, then subsequent
failures after a <a class="reference internal" href="#coq:tacn.lazymatch" title="lazymatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazymatch</span></code></a> or <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a> (but not <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a>) can cause
backtracking into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> to select its next success.
(<a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">…</span></span></span></span></code> is equivalent to <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a> <code class="docutils literal notranslate"><span class="pre">…</span></code>.
The <a class="reference internal" href="#coq:tacn.once" title="once"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">once</span></code></a> prevents backtracking into the <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> after it has succeeded.)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> construct is processed in two phases: an evaluation phase and an execution phase.
In most cases, tactics that may change the proof state are applied in the second phase.
(Tactics that generate integer, string or syntactic values, such as <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a>,
are processed during the evaluation phase.)</p>
<p>Unlike other tactics, <code class="docutils literal notranslate"><span class="pre">*match*</span></code> tactics get their first success (applying tactics to do
so) as part of the evaluation phase.  Among other things, this can affect how early
failures are processed in <a class="reference internal" href="#coq:tacn.assert_fails" title="assert_fails"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_fails</span></code></a>.  Please see the note in <a class="reference internal" href="#coq:tacn.assert_fails" title="assert_fails"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert_fails</span></code></a>.</p>
</div>
<dl class="coq exn">
<dt id="coq:exn.Expression-does-not-evaluate-to-a-tactic">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Expression</span></span> <span><span>does</span></span> <span><span>not</span></span> <span><span>evaluate</span></span> <span><span>to</span></span> <span><span>a</span></span> <span><span>tactic.</span></span></span></code><a class="headerlink" href="#coq:exn.Expression-does-not-evaluate-to-a-tactic" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> must evaluate to a tactic.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.No-matching-clauses-for-match">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>matching</span></span> <span><span>clauses</span></span> <span><span>for</span></span> <span><span>match.</span></span></span></code><a class="headerlink" href="#coq:exn.No-matching-clauses-for-match" title="Permalink to this definition">¶</a></dt>
<dd><p>For at least one of the focused goals, there is no branch that matches
its pattern <em>and</em> gets at least one success for <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code>.</p>
</dd></dl>

<dl class="coq exn">
<dt id="coq:exn.Argument-of-match-does-not-evaluate-to-a-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Argument</span></span> <span><span>of</span></span> <span><span>match</span></span> <span><span>does</span></span> <span><span>not</span></span> <span><span>evaluate</span></span> <span><span>to</span></span> <span><span>a</span></span> <span><span>term.</span></span></span></code><a class="headerlink" href="#coq:exn.Argument-of-match-does-not-evaluate-to-a-term" title="Permalink to this definition">¶</a></dt>
<dd><p>This happens when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span><sub><span class="pre">term</span></sub></span></a></span></code> does not denote a term.</p>
</dd></dl>

</dd></dl>

<blockquote id="match-vs-lazymatch-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Comparison of lazymatch and match</p>
<p>In <a class="reference internal" href="#coq:tacn.lazymatch" title="lazymatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazymatch</span></code></a>, if <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> fails, the <a class="reference internal" href="#coq:tacn.lazymatch" title="lazymatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazymatch</span></code></a> fails;
it doesn't look for further matches.  In <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a>, if <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> fails
in a matching branch, it will try to match on subsequent branches.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">lazymatch</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 1&quot;; </span><span class="coqdoc-tactic">fail</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 2&quot;</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>branch 1
The command has indeed failed with message:
Tactic failure.
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 1&quot;; </span><span class="coqdoc-tactic">fail</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 2&quot;</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>branch 1
branch 2
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="match-vs-multimatch-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Comparison of match and multimatch</p>
<p><a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a> tactics are only evaluated once, whereas <a class="reference internal" href="#coq:tacn.multimatch" title="multimatch"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span></code></a>
tactics may be evaluated more than once if the following constructs trigger backtracking:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 1&quot;</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 2&quot;</span><span>
</span><span class="coqdoc-keyword">end</span><span> ;</span><span>
</span><span class="coqdoc-tactic">idtac</span><span> &quot;branch A&quot;; </span><span class="coqdoc-tactic">fail</span><span>.</span><span>
</span></dt><dd><span>branch 1
branch A
The command has indeed failed with message:
Tactic failure.
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-var">multimatch</span><span> </span><span class="coqdoc-var">True</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 1&quot;</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;branch 2&quot;</span><span>
</span><span class="coqdoc-keyword">end</span><span> ;</span><span>
</span><span class="coqdoc-tactic">idtac</span><span> &quot;branch A&quot;; </span><span class="coqdoc-tactic">fail</span><span>.</span><span>
</span></dt><dd><span>branch 1
branch A
branch 2
branch A
The command has indeed failed with message:
Tactic failure.
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="match-with-holes-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Matching a pattern with holes</p>
<p>Notice the <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> prints <code class="docutils literal notranslate"><span class="pre">(z</span> <span class="pre">+</span> <span class="pre">1)</span></code> while the <a class="reference internal" href="tactics.html#coq:tacn.pose" title="pose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a> substitutes
<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">constr</span><span>:(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; (</span><span class="coqdoc-var">x</span><span> + 1) * 3) </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">z</span><span> =&gt; ?</span><span class="coqdoc-var">y</span><span> * 3 =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;y =&quot; </span><span class="coqdoc-var">y</span><span>; </span><span class="coqdoc-tactic">pose</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">z</span><span>: </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">y</span><span> * 5)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>y = (z</span><span> +</span><span> 1)
1 goal
  
  n := </span><span class="ansi-bold">fun</span><span> x : nat =&gt; (x</span><span> +</span><span> 1)</span><span> *</span><span> 5 : nat</span><span> -&gt;</span><span> nat
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="match-term-context-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Multiple matches for a &quot;context&quot; pattern.</p>
<p>Internally &quot;x &lt;&gt; y&quot; is represented as &quot;(~ (x = y))&quot;, which produces the
first match.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-keyword">with</span><span>
           | </span><span class="coqdoc-keyword">context</span><span> [ (~ ?</span><span class="coqdoc-var">t</span><span>) ] =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;?t = &quot; </span><span class="coqdoc-var">t</span><span>; </span><span class="coqdoc-tactic">fail</span><span>
           | </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span>
           </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>f is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">f</span><span> ((~ </span><span class="coqdoc-var">True</span><span>) &lt;&gt; (~ </span><span class="coqdoc-var">False</span><span>)).</span><span>
</span></dt><dd><span>?t =  ((</span><span>~</span><span> True)</span><span> =</span><span> (</span><span>~</span><span> False))
?t =  True
?t =  False
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
</div>
<div class="section" id="pattern-matching-on-goals-and-hypotheses-match-goal">
<span id="ltac-match-goal"></span><h3>Pattern matching on goals and hypotheses: match goal<a class="headerlink" href="#pattern-matching-on-goals-and-hypotheses-match-goal" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.lazymatch-goal">
<span id="coq:tacn.match-goal"></span><span id="coq:tacn.multimatch-goal"></span><em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-match_key"><span class="hole">match_key</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>reverse</span></span></span><span class="notation-sup">?</span></span> <span><span>goal</span></span> <span><span>with</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-goal_pattern"><span class="hole">goal_pattern</span></a> <span><span>=&gt;</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>end</span></span></span></code><a class="headerlink" href="#coq:tacn.lazymatch-goal" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-goal_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-goal_pattern"><span class="hole">goal_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-match_hyp"><span class="hole">match_hyp</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>|-</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-match_hyp"><span class="hole">match_hyp</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>|-</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-match_hyp"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-match_hyp"><span class="hole">match_hyp</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a> <span><span>:=</span></span> <span><span>[</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a> <span><span>]</span></span> <span><span>:</span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole">match_pattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p><a class="reference internal" href="#coq:tacn.lazymatch-goal" title="lazymatch goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lazymatch</span> <span class="pre">goal</span></code></a>, <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> and <a class="reference internal" href="#coq:tacn.multimatch-goal" title="multimatch goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span> <span class="pre">goal</span></code></a> are <a class="reference internal" href="#grammar-token-l1_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l1_tactic</span></code></a>s.</p>
<p>Use this form to match hypotheses and/or goals in the local context.  These patterns have zero or
more subpatterns to match hypotheses followed by a subpattern to match the conclusion.  Except for the
differences noted below, this works the same as the corresponding <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-match_key"><span class="hole"><span class="pre">match_key</span></span></a> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code> construct
(see <a class="reference internal" href="#coq:tacn.match" title="match"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span></code></a>).  Each current goal is processed independently.</p>
<p>Matching is non-linear: if a
metavariable occurs more than once, each occurrence must match the same
expression.  Within a single term, expressions match if they are syntactically equal or
<a class="reference internal" href="../language/core/conversion.html#term-alpha-convertible"><span class="xref std std-term">α-convertible</span></a>.  When a metavariable is used across
multiple hypotheses or across a hypothesis and the current goal, the expressions match if
they are <a class="reference internal" href="../language/core/conversion.html#term-convertible"><span class="xref std std-term">convertible</span></a>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-match_hyp"><span class="hole"><span class="pre">match_hyp</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code></dt><dd><p>Patterns to match with hypotheses.  Each pattern must match a distinct hypothesis in order
for the branch to match.</p>
<p>Hypotheses have the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">binder</span></sub></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.  Patterns bind each of
these nonterminals separately:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pattern syntax</p></th>
<th class="head"><p>Example pattern</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole"><span class="pre">match_pattern</span><sub><span class="pre">type</span></sub></span></a></span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">?t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole"><span class="pre">match_pattern</span><sub><span class="pre">binder</span></sub></span></a></span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">?b</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">binder</span></sub></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">?b</span> <span class="pre">:</span> <span class="pre">?t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole"><span class="pre">match_pattern</span><sub><span class="pre">binder</span></sub></span></a> <span><span><span class="pre">]</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole"><span class="pre">match_pattern</span><sub><span class="pre">type</span></sub></span></a></span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">[</span> <span class="pre">?b</span> <span class="pre">]</span> <span class="pre">:</span> <span class="pre">?t</span></code></p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><code class="xref std std-token docutils literal notranslate"><span class="pre">name</span></code></a> can't have a <code class="docutils literal notranslate"><span class="pre">?</span></code>.  Note that the last two forms are equivalent except that:</p>
<ul class="simple">
<li><p>if the <code class="docutils literal notranslate"><span class="pre">:</span></code> in the third form has been bound to something else in a notation, you must use the fourth form.
Note that cmd:<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span></code> <code class="docutils literal notranslate"><span class="pre">ssreflect</span></code> loads a notation that does this.</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">binder</span></sub></span></a></span></code> such as <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">?l</span> <span class="pre">]</span></code> (e.g., denoting a singleton list after
<a class="reference internal" href="../language/core/modules.html#coq:cmd.Import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> <code class="docutils literal notranslate"><span class="pre">ListNotations</span></code>) must be parenthesized or, for the fourth form,
use double brackets: <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">[</span> <span class="pre">?l</span> <span class="pre">]</span> <span class="pre">]</span></code>.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">binder</span></sub></span></a></span></code>s in the form <code class="docutils literal notranslate"><span class="pre">[?x</span> <span class="pre">;</span> <span class="pre">?y]</span></code> for a list are not parsed correctly.  The workaround is
to add parentheses or to use the underlying term instead of the notation, i.e. <code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">?x</span> <span class="pre">?y)</span></code>.</p>
</div></blockquote>
<p>If there are multiple <a class="reference internal" href="#grammar-token-match_hyp"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_hyp</span></code></a>s in a branch, there may be multiple ways to match them to hypotheses.
For <a class="reference internal" href="#coq:tacn.match-goal" title="match goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code></a> and <a class="reference internal" href="#coq:tacn.multimatch-goal" title="multimatch goal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">multimatch</span> <span class="pre">goal</span></code></a>, if the evaluation of the <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> fails,
matching will continue with the next hypothesis combination.  When those are exhausted,
the next alternative from any <code class="docutils literal notranslate"><span class="pre">context</span></code> constructs in the <a class="reference internal" href="#grammar-token-match_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_pattern</span></code></a>s is tried and then,
when the context alternatives are exhausted, the next branch is tried.
<a class="reference internal" href="#match-goal-multiple-hyps-ex"><span class="std std-ref">Example</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reverse</span></code></dt><dd><p>Hypothesis matching for <a class="reference internal" href="#grammar-token-match_hyp"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_hyp</span></code></a>s normally begins by matching them from left to right,
to hypotheses, last to first.  Specifying <code class="docutils literal notranslate"><span class="pre">reverse</span></code> begins matching in the reverse order, from
first to last.  <a class="reference internal" href="#match-goal-hyps-ex"><span class="std std-ref">Normal</span></a> and <a class="reference internal" href="#match-goal-hyps-rev-ex"><span class="std std-ref">reverse</span></a> examples.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="pre">|</span><span><span><span class="pre">-</span></span></span> <a class="reference internal" href="#grammar-token-match_pattern"><span class="hole"><span class="pre">match_pattern</span></span></a></span></code></dt><dd><p>A pattern to match with the current goal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-goal_pattern"><span class="hole"><span class="pre">goal_pattern</span></span></a> <span><span><span class="pre">with</span></span></span> <span><span><span class="pre">[</span></span></span> <span><span><span class="pre">...</span></span></span> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p>The square brackets don't affect the semantics.  They are permitted for aesthetics.</p>
</dd>
</dl>
<dl class="coq exn">
<dt id="coq:exn.No-matching-clauses-for-match-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>matching</span></span> <span><span>clauses</span></span> <span><span>for</span></span> <span><span>match</span></span> <span><span>goal.</span></span></span></code><a class="headerlink" href="#coq:exn.No-matching-clauses-for-match-goal" title="Permalink to this definition">¶</a></dt>
<dd><p>No clause succeeds, i.e. all matching patterns, if any, fail at the
application of the <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>.</p>
</dd></dl>

</dd></dl>

<p>Examples:</p>
<blockquote id="match-goal-hyps-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Matching hypotheses</p>
<p>Hypotheses are matched from the last hypothesis (which is by default the newest
hypothesis) to the first until the <a class="reference internal" href="tactics.html#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> succeeds.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A
  H0 : B
  H1 : A
  ============================
  B
</span></dd>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;apply &quot; </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>apply  H1
apply  H0
No more goals.
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="match-goal-hyps-rev-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Matching hypotheses with reverse</p>
<p>Hypotheses are matched from the first hypothesis to the last until the <a class="reference internal" href="tactics.html#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> succeeds.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A
  H0 : B
  H1 : A
  ============================
  B
</span></dd>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">reverse</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;apply &quot; </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>apply  A
apply  B
apply  H
apply  H0
No more goals.
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="match-goal-multiple-hyps-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: Multiple ways to match hypotheses</p>
<p>Every possible match for the hypotheses is evaluated until the right-hand
side succeeds.  Note that <code class="docutils literal notranslate"><span class="pre">H1</span></code> and <code class="docutils literal notranslate"><span class="pre">H2</span></code> are never matched to the same hypothesis.
Observe that the number of permutations can grow as the factorial
of the number of hypotheses and hypothesis patterns.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A
  ============================
  B</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">H1</span><span> : </span><span class="coqdoc-var">_</span><span>, </span><span class="coqdoc-var">H2</span><span> : </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span> &quot;match &quot; </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>; </span><span class="coqdoc-tactic">fail</span><span>
| </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">idtac</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>match  B H
match  A H
match  H B
match  A B
match  H A
match  B A
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
</div>
<div class="section" id="filling-a-term-context">
<h3>Filling a term context<a class="headerlink" href="#filling-a-term-context" title="Permalink to this headline">¶</a></h3>
<p>The following expression is not a tactic in the sense that it does not
produce subgoals but generates a term to be used in tactic expressions:</p>
<dl class="coq tacn">
<dt id="coq:tacn.context">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>context</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>[</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>]</span></span></span></code><a class="headerlink" href="#coq:tacn.context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the term matched with the <code class="docutils literal notranslate"><span class="pre">context</span></code> pattern (described <a class="reference internal" href="ltac2.html#match-term-context"><span class="std std-ref">here</span></a>)
substituting <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> for the hole created by the pattern.</p>
<p><a class="reference internal" href="#coq:tacn.context" title="context"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">context</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
<dl class="coq exn">
<dt id="coq:exn.Not-a-context-variable">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>a</span></span> <span><span>context</span></span> <span><span>variable.</span></span></span></code><a class="headerlink" href="#coq:exn.Not-a-context-variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.Unbound-context-identifier-‘ident’">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Unbound</span></span> <span><span>context</span></span> <span><span>identifier</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a><span><span>.</span></span></span></code><a class="headerlink" href="#coq:exn.Unbound-context-identifier-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: Substituting a matched context</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True</span><span> /\</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
| |- </span><span class="coqdoc-keyword">context</span><span> </span><span class="coqdoc-var">G</span><span> [</span><span class="coqdoc-var">True</span><span>] =&gt; </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-keyword">context</span><span> </span><span class="coqdoc-var">G</span><span> [</span><span class="coqdoc-var">False</span><span>] </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-tactic">idtac</span><span> </span><span class="coqdoc-var">x</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>(False</span><span> /\</span><span> True)
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="generating-fresh-hypothesis-names">
<h3>Generating fresh hypothesis names<a class="headerlink" href="#generating-fresh-hypothesis-names" title="Permalink to this headline">¶</a></h3>
<p>Tactics sometimes need to generate new names for hypothesis.  Letting Coq
choose a name with the intro tactic is not so good since it is
very awkward to retrieve that name. The following
expression returns an identifier:</p>
<dl class="coq tacn">
<dt id="coq:tacn.fresh">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>fresh</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.fresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a fresh identifier name (i.e. one that is not already used in the local context
and not previously returned by <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> in the current <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>).
The fresh identifier is formed by concatenating the final <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> of each <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>
(dropping any qualified components) and each specified <a class="reference internal" href="../language/core/basic.html#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a>.
If the resulting name is already used, a number is appended to make it fresh.
If no arguments are given, the name is a fresh derivative of the name <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We recommend generating the fresh identifier immediately before
adding it to the local context.  Using <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> in a local function
may not work as you expect:</p>
<p>Successive calls to <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> give distinct names even if the names haven't
yet been added to the local context:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span> -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : True
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">a</span><span> := </span><span class="coqdoc-tactic">fresh</span><span> &quot;x&quot; </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">b</span><span> := </span><span class="coqdoc-tactic">fresh</span><span> &quot;x&quot; </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-tactic">idtac</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>x0 x1
</span></dd>
</dl>
</div>
<p>When applying <a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> in a function, the name is chosen based on the
tactic context at the point where the function was defined:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">a</span><span> := </span><span class="coqdoc-tactic">fresh</span><span> &quot;x&quot; </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">fresh</span><span> &quot;x&quot; </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">c</span><span> := </span><span class="coqdoc-var">f</span><span> () </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">d</span><span> := </span><span class="coqdoc-var">f</span><span> () </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-tactic">idtac</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">c</span><span> </span><span class="coqdoc-var">d</span><span>.</span><span>
</span></dt><dd><span>x0 x1 x1
</span></dd>
</dl>
</div>
</div>
<p><a class="reference internal" href="#coq:tacn.fresh" title="fresh"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="computing-in-a-term-eval">
<h3>Computing in a term: eval<a class="headerlink" href="#computing-in-a-term-eval" title="Permalink to this headline">¶</a></h3>
<p>Evaluation of a term can be performed with:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">eval</span></span></span> <a class="reference internal" href="../proofs/writing-proofs/equality.html#grammar-token-red_expr"><span class="hole"><span class="pre">red_expr</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></p>
<p>See <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.eval" title="eval"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eval</span></code></a>.  <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.eval" title="eval"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eval</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
</div>
<div class="section" id="getting-the-type-of-a-term">
<h3>Getting the type of a term<a class="headerlink" href="#getting-the-type-of-a-term" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.type-of">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>type</span></span> <span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.type-of" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic returns the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p><a class="reference internal" href="#coq:tacn.type-of" title="type of"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">type</span> <span class="pre">of</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="manipulating-untyped-terms-type-term">
<h3>Manipulating untyped terms: type_term<a class="headerlink" href="#manipulating-untyped-terms-type-term" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">uconstr</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></code> construct can be used to build an untyped term.
See <a class="reference internal" href="#grammar-token-syn_value"><code class="xref std std-token docutils literal notranslate"><span class="pre">syn_value</span></code></a>.</p>
<dl class="coq tacn">
<dt id="coq:tacn.type_term">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>type</span></span><span><span>_</span></span><span><span>term</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.type_term" title="Permalink to this definition">¶</a></dt>
<dd><p>In <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub>, an untyped term can contain references to hypotheses or to
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variables containing typed or untyped terms. An untyped term can be
type checked with <a class="reference internal" href="#coq:tacn.type_term" title="type_term"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">type_term</span></code></a> whose argument is parsed as an
untyped term and returns a well-typed term which can be used in tactics.</p>
<p><a class="reference internal" href="#coq:tacn.type_term" title="type_term"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">type_term</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="counting-goals-numgoals">
<h3>Counting goals: numgoals<a class="headerlink" href="#counting-goals-numgoals" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.numgoals">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>numgoals</span></span></span></code><a class="headerlink" href="#coq:tacn.numgoals" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of goals under focus can be recovered using the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">numgoals</span></span></span></span></code>
function. Combined with the <a class="reference internal" href="#coq:tacn.guard" title="guard"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">guard</span></code></a> tactic below, it can be used to
branch over the number of goals produced by previous tactics.</p>
<p><a class="reference internal" href="#coq:tacn.numgoals" title="numgoals"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">numgoals</span></code></a> is a <a class="reference internal" href="#grammar-token-value_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">value_tactic</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">pr_numgoals</span><span> := </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">numgoals</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-tactic">idtac</span><span> &quot;There are&quot; </span><span class="coqdoc-var">n</span><span> &quot;goals&quot;.</span><span>
</span></dt><dd class="coqtop-hidden"><span>pr_numgoals is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True</span><span> /\</span><span> True</span><span> /\</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">split</span><span>;[|</span><span class="coqdoc-tactic">split</span><span>].</span><span>
</span></dt><dd class="coqtop-hidden"><span>3 goals
  
  ============================
  True

goal 2 is:
 True
goal 3 is:
 True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">all</span><span>:</span><span class="coqdoc-var">pr_numgoals</span><span>.</span><span>
</span></dt><dd><span>There are 3 goals
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="testing-boolean-expressions-guard">
<h3>Testing boolean expressions: guard<a class="headerlink" href="#testing-boolean-expressions-guard" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.guard">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>guard</span></span> <a class="reference internal" href="#grammar-token-int_or_var"><span class="hole">int_or_var</span></a> <a class="reference internal" href="#grammar-token-comparison"><span class="hole">comparison</span></a> <a class="reference internal" href="#grammar-token-int_or_var"><span class="hole">int_or_var</span></a></span></code><a class="headerlink" href="#coq:tacn.guard" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-int_or_var"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-int_or_var"><span class="hole">int_or_var</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><span class="hole">integer</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-comparison"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-comparison"><span class="hole">comparison</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>=</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&lt;</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&lt;=</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&gt;</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&gt;=</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Tests a boolean expression.  If the expression evaluates to true,
it succeeds without affecting the proof.  The tactic fails if the
expression is false.</p>
<p>The accepted tests are simple integer comparisons.</p>
<div class="admonition note">
<p class="admonition-title">Example: guard</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">True</span><span> /\ </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True</span><span> /\</span><span> True</span><span> /\</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">split</span><span>;[|</span><span class="coqdoc-tactic">split</span><span>].</span><span>
</span></dt><dd class="coqtop-hidden"><span>3 goals
  
  ============================
  True

goal 2 is:
 True
goal 3 is:
 True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">all</span><span>:</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">n</span><span>:= </span><span class="coqdoc-var">numgoals</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">guard</span><span> </span><span class="coqdoc-var">n</span><span>&lt;4.</span><span>
</span></dt><dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-var">all</span><span>:</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">n</span><span>:= </span><span class="coqdoc-var">numgoals</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">guard</span><span> </span><span class="coqdoc-var">n</span><span>=2.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Condition not satisfied: 3=2
</span></dd>
</dl>
</div>
</div>
<dl class="coq exn">
<dt id="coq:exn.Condition-not-satisfied">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Condition</span></span> <span><span>not</span></span> <span><span>satisfied.</span></span></span></code><a class="headerlink" href="#coq:exn.Condition-not-satisfied" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="checking-properties-of-terms">
<h3>Checking properties of terms<a class="headerlink" href="#checking-properties-of-terms" title="Permalink to this headline">¶</a></h3>
<p>Each of the following tactics acts as the identity if the check
succeeds, and results in an error otherwise.</p>
<dl class="coq tacn">
<dt id="coq:tacn.constr_eq_strict">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>constr</span></span><span><span>_</span></span><span><span>eq</span></span><span><span>_</span></span><span><span>strict</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.constr_eq_strict" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if the arguments are equal modulo alpha conversion and ignoring casts.
Universes are considered equal when they are equal in the universe graph.</p>
<dl class="coq exn">
<dt id="coq:exn.Not-equal">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>equal.</span></span></span></code><a class="headerlink" href="#coq:exn.Not-equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="coq:exn.Not-equal-(due-to-universes)">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>equal</span></span> <span><span>(due</span></span> <span><span>to</span></span> <span><span>universes).</span></span></span></code><a class="headerlink" href="#coq:exn.Not-equal-(due-to-universes)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.constr_eq">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>constr</span></span><span><span>_</span></span><span><span>eq</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.constr_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#coq:tacn.constr_eq_strict" title="constr_eq_strict"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constr_eq_strict</span></code></a>, but may add constraints to make universes equal.</p>
<dl class="coq exn">
<dt id="id6">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>equal.</span></span></span></code><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt id="id7">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>equal</span></span> <span><span>(due</span></span> <span><span>to</span></span> <span><span>universes).</span></span></span></code><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.constr_eq_nounivs">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>constr</span></span><span><span>_</span></span><span><span>eq</span></span><span><span>_</span></span><span><span>nounivs</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.constr_eq_nounivs" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#coq:tacn.constr_eq_strict" title="constr_eq_strict"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constr_eq_strict</span></code></a>, but all universes are considered equal.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.unify">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>unify</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if the arguments are unifiable, potentially
instantiating existential variables, and fails otherwise.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, if specified, is the name of the <a class="reference internal" href="../proofs/automatic-tactics/auto.html#hintdatabases"><span class="std std-ref">hint database</span></a>
that specifies which definitions are transparent.
Otherwise, all definitions are considered transparent.  Unification only expands
transparent definitions while matching the two <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>s.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_evar">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>evar</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_evar" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is an existential
variable and otherwise fails. Existential variables are uninstantiated
variables generated
by <a class="reference internal" href="tactics.html#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and some other tactics.</p>
<dl class="coq exn">
<dt id="coq:exn.Not-an-evar">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>an</span></span> <span><span>evar.</span></span></span></code><a class="headerlink" href="#coq:exn.Not-an-evar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.not_evar">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span><span><span>_</span></span><span><span>evar</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.not_evar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.has_evar">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>has</span></span><span><span>_</span></span><span><span>evar</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.has_evar" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> has an existential variable as
a subterm and fails otherwise. Unlike context patterns combined with
<code class="docutils literal notranslate"><span class="pre">is_evar</span></code>, this tactic scans all subterms, including those under binders.</p>
<dl class="coq exn">
<dt id="coq:exn.No-evars">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>No</span></span> <span><span>evars.</span></span></span></code><a class="headerlink" href="#coq:exn.No-evars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_ground">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>ground</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_ground" title="Permalink to this definition">¶</a></dt>
<dd><p>The negation of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">has</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">evar</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.  Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
does not have an existential variable as a subterm and fails otherwise.</p>
<dl class="coq exn">
<dt id="coq:exn.Not-ground">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>ground.</span></span></span></code><a class="headerlink" href="#coq:exn.Not-ground" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_var">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>var</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a variable or hypothesis in
the current local context and fails otherwise.</p>
<dl class="coq exn">
<dt id="coq:exn.Not-a-variable-or-hypothesis">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Not</span></span> <span><span>a</span></span> <span><span>variable</span></span> <span><span>or</span></span> <span><span>hypothesis.</span></span></span></code><a class="headerlink" href="#coq:exn.Not-a-variable-or-hypothesis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_const">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>const</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a global constant that is neither a (co)inductive
type nor a constructor and fails otherwise.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-constant">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>a</span></span> <span><span>constant.</span></span></span></code><a class="headerlink" href="#coq:exn.not-a-constant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_fix">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>fix</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="pre">fix</span></code> construct (see <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/inductive.html#grammar-token-term_fix"><span class="hole"><span class="pre">term_fix</span></span></a></span></code>)
and fails otherwise.  Fails for <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">fix</span></code> forms.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-fix-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>a</span></span> <span><span>fix</span></span> <span><span>definition.</span></span></span></code><a class="headerlink" href="#coq:exn.not-a-fix-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: is_fix</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">is_fix</span><span> (</span><span class="coqdoc-keyword">fix</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> =&gt; </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">O</span><span> </span><span class="coqdoc-keyword">end</span><span>).</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_cofix">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>cofix</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_cofix" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="pre">cofix</span></code> construct (see <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/coinductive.html#grammar-token-term_cofix"><span class="hole"><span class="pre">term_cofix</span></span></a></span></code>)
and fails otherwise.  Fails for <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">cofix</span></code> forms.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-cofix-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>a</span></span> <span><span>cofix</span></span> <span><span>definition.</span></span></span></code><a class="headerlink" href="#coq:exn.not-a-cofix-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: is_cofix</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Lists.Streams</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">c</span><span> := </span><span class="coqdoc-keyword">constr</span><span>:(</span><span class="coqdoc-keyword">cofix</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">Stream</span><span> </span><span class="coqdoc-var">unit</span><span> := </span><span class="coqdoc-var">Cons</span><span> </span><span class="coqdoc-var">tt</span><span> </span><span class="coqdoc-var">f</span><span>) </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-var">is_cofix</span><span> </span><span class="coqdoc-var">c</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_constructor">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>constructor</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is the constructor of a (co)inductive type and fails
otherwise.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-constructor">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>a</span></span> <span><span>constructor.</span></span></span></code><a class="headerlink" href="#coq:exn.not-a-constructor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_ind">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>ind</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_ind" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a (co)inductive type (family) and fails otherwise.
Note that <code class="docutils literal notranslate"><span class="pre">is_ind</span> <span class="pre">(list</span> <span class="pre">nat)</span></code> fails even though <code class="docutils literal notranslate"><span class="pre">is_ind</span> <span class="pre">list</span></code> succeeds, because
<code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">nat</span></code> is an application.</p>
<dl class="coq exn">
<dt id="coq:exn.not-an-(co)inductive-datatype">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>an</span></span> <span><span>(co)inductive</span></span> <span><span>datatype.</span></span></span></code><a class="headerlink" href="#coq:exn.not-an-(co)inductive-datatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.is_proj">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>is</span></span><span><span>_</span></span><span><span>proj</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span></code><a class="headerlink" href="#coq:tacn.is_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Succeeds if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a primitive projection applied to a record argument
and fails otherwise.</p>
<dl class="coq exn">
<dt id="coq:exn.not-a-primitive-projection">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>not</span></span> <span><span>a</span></span> <span><span>primitive</span></span> <span><span>projection.</span></span></span></code><a class="headerlink" href="#coq:exn.not-a-primitive-projection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: is_proj</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Primitive</span><span> </span><span class="coqdoc-var">Projections</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">Box</span><span> {</span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>} := </span><span class="coqdoc-var">box</span><span> { </span><span class="coqdoc-var">unbox</span><span> : </span><span class="coqdoc-var">T</span><span> }.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Box is defined
unbox is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Arguments</span><span> </span><span class="coqdoc-var">box</span><span> {</span><span class="coqdoc-var">_</span><span>} </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">is_proj</span><span> (</span><span class="coqdoc-var">unbox</span><span> (</span><span class="coqdoc-var">box</span><span> 0)).</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="timing">
<h2>Timing<a class="headerlink" href="#timing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="timeout">
<h3>Timeout<a class="headerlink" href="#timeout" title="Permalink to this headline">¶</a></h3>
<p>We can force a tactic to stop if it has not finished after a certain
amount of time:</p>
<dl class="coq tacn">
<dt id="coq:tacn.timeout">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>timeout</span></span> <a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><span class="hole">nat_or_var</span></a> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> is evaluated to <code class="docutils literal notranslate"><span class="pre">v</span></code> which must be a tactic value. The tactic value
<code class="docutils literal notranslate"><span class="pre">v</span></code> is applied normally, except that it is interrupted after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="tactics.html#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a></span></code> seconds
if it is still running. In this case the outcome is a failure.</p>
<p><a class="reference internal" href="#coq:tacn.timeout" title="timeout"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">timeout</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For the moment, timeout is based on elapsed time in seconds,
which is very machine-dependent: a script that works on a quick machine
may fail on a slow one. The converse is even possible if you combine a
timeout with some other tacticals. This tactical is hence proposed only
for convenience during debugging or other development phases, we strongly
advise you to not leave any timeout in final scripts. Note also that
this tactical isn’t available on the native Windows port of Coq.</p>
</div>
</dd></dl>

</div>
<div class="section" id="timing-a-tactic">
<h3>Timing a tactic<a class="headerlink" href="#timing-a-tactic" title="Permalink to this headline">¶</a></h3>
<p>A tactic execution can be timed:</p>
<dl class="coq tacn">
<dt id="coq:tacn.time">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>time</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole">ltac_expr3</span></a></span></code><a class="headerlink" href="#coq:tacn.time" title="Permalink to this definition">¶</a></dt>
<dd><p>evaluates <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> and displays the running time of the tactic expression, whether it
fails or succeeds. In case of several successes, the time for each successive
run is displayed. Time is in seconds and is machine-dependent. The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>
argument is optional. When provided, it is used to identify this particular
occurrence of <a class="reference internal" href="#coq:tacn.time" title="time"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">time</span></code></a>.</p>
<p><a class="reference internal" href="#coq:tacn.time" title="time"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">time</span></code></a> is an <a class="reference internal" href="#grammar-token-l3_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l3_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="timing-a-tactic-that-evaluates-to-a-term-time-constr">
<h3>Timing a tactic that evaluates to a term: time_constr<a class="headerlink" href="#timing-a-tactic-that-evaluates-to-a-term-time-constr" title="Permalink to this headline">¶</a></h3>
<p>Tactic expressions that produce terms can be timed with the experimental
tactic</p>
<dl class="coq tacn">
<dt id="coq:tacn.time_constr">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>time</span></span><span><span>_</span></span><span><span>constr</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:tacn.time_constr" title="Permalink to this definition">¶</a></dt>
<dd><p>which evaluates <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a> <span><span><span class="pre">()</span></span></span></span></code> and displays the time the tactic expression
evaluated, assuming successful evaluation. Time is in seconds and is
machine-dependent.</p>
<p>This tactic currently does not support nesting, and will report times
based on the innermost execution. This is due to the fact that it is
implemented using the following internal tactics:</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.restart_timer">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>restart</span></span><span><span>_</span></span><span><span>timer</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.restart_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a timer</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.finish_timing">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>finish</span></span><span><span>_</span></span><span><span>timing</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a> <span><span>)</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.finish_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an optionally named timer. The parenthesized string argument
is also optional, and determines the label associated with the timer
for printing.</p>
</dd></dl>

<p>By copying the definition of <a class="reference internal" href="#coq:tacn.time_constr" title="time_constr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">time_constr</span></code></a> from the standard library,
users can achieve support for a fixed pattern of nesting by passing
different <a class="reference internal" href="../language/core/basic.html#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> parameters to <a class="reference internal" href="#coq:tacn.restart_timer" title="restart_timer"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">restart_timer</span></code></a> and
<a class="reference internal" href="#coq:tacn.finish_timing" title="finish_timing"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">finish_timing</span></code></a> at each level of nesting.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">time_constr1</span><span> </span><span class="coqdoc-var">tac</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">eval_early</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">restart_timer</span><span> &quot;(depth 1)&quot; </span><span class="coqdoc-keyword">end</span><span> </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">ret</span><span> := </span><span class="coqdoc-var">tac</span><span> () </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">eval_early</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">finish_timing</span><span> ( &quot;Tactic evaluation&quot; ) &quot;(depth 1)&quot; </span><span class="coqdoc-keyword">end</span><span> </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-var">ret</span><span>.</span><span>
</span></dt><dd><span>time_constr1 is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span>  </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">v</span><span> := </span><span class="coqdoc-var">time_constr</span><span>
       </span><span class="coqdoc-keyword">ltac</span><span>:(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
               </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">time_constr1</span><span> </span><span class="coqdoc-keyword">ltac</span><span>:(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-keyword">constr</span><span>:(10 * 10)) </span><span class="coqdoc-tactic">in</span><span>
               </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">time_constr1</span><span> </span><span class="coqdoc-keyword">ltac</span><span>:(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">x</span><span>) </span><span class="coqdoc-tactic">in</span><span>
               </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">v</span><span>.</span><span>
</span></dt><dd><span>Tactic evaluation (depth 1) ran for 0. secs (0.u,0.s)
Tactic evaluation (depth 1) ran for 0. secs (0.u,0.s)
Tactic evaluation ran for 0. secs (0.u,0.s)
1 goal
  
  n := 100 : nat
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="print-identity-tactic-idtac">
<h2>Print/identity tactic: idtac<a class="headerlink" href="#print-identity-tactic-idtac" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt id="coq:tacn.idtac">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>idtac</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.idtac" title="Permalink to this definition">¶</a></dt>
<dd><p>Leaves the proof unchanged and prints the given tokens. <a class="reference internal" href="../language/core/basic.html#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">String</span></code></a>s
and <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a>s are printed
literally. If <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> variable, its contents are printed; if not, it
is an error.</p>
<p><a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> is an <a class="reference internal" href="#grammar-token-l1_tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">l1_tactic</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="tactic-toplevel-definitions">
<h2>Tactic toplevel definitions<a class="headerlink" href="#tactic-toplevel-definitions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-ltac-symbols">
<h3>Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols<a class="headerlink" href="#defining-ltac-symbols" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> toplevel definitions are made as follows:</p>
<span class="target" id="index-0"></span><dl class="coq cmd">
<dt id="coq:cmd.Ltac">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <a class="reference internal" href="#grammar-token-tacdef_body"><span class="hole">tacdef_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-tacdef_body"><span class="hole">tacdef_body</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.Ltac" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tacdef_body"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tacdef_body"><span class="hole">tacdef_body</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">*</span></span> <span class="alternative"><span class="alternative-block"><span><span>:=</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>::=</span></span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Defines or redefines an <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbol.</p>
<p>If the <a class="reference internal" href="../language/core/modules.html#coq:attr.local" title="local"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">local</span></code></a> attribute is specified, definitions will not be
exported outside the current module and redefinitions only apply for the current module.</p>
<dl>
<dt><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a></dt><dd><p>Name of the symbol being defined or redefined.  For definitions, <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>
must be a simple <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code></dt><dd><p>If specified, the symbol defines a function with the given parameter names.
If no names are specified, <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> is assigned the value of <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">:=</span></code></dt><dd><p>Defines a user-defined symbol, but gives an error if the symbol has already
been defined.</p>
<dl class="coq exn">
<dt id="coq:exn.There-is-already-an-Ltac-named-‘qualid’">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>There</span></span> <span><span>is</span></span> <span><span>already</span></span> <span><span>an</span></span> <span><span>Ltac</span></span> <span><span>named</span></span> <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:exn.There-is-already-an-Ltac-named-‘qualid’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd>
<dt><code class="docutils literal notranslate"><span class="pre">::=</span></code></dt><dd><p>Redefines an existing user-defined symbol, but gives an error if the
symbol doesn't exist.  Note that <a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:cmd.Tactic-Notation" title="Tactic Notation"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Tactic</span> <span class="pre">Notation</span></code></a>s
do not count as user-defined tactics for <code class="docutils literal notranslate"><span class="pre">::=</span></code>.  If <a class="reference internal" href="../language/core/modules.html#coq:attr.local" title="local"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">local</span></code></a> is not
specified, the redefinition applies across module boundaries.</p>
<dl class="coq exn">
<dt id="coq:exn.There-is-no-Ltac-named-‘qualid’">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>There</span></span> <span><span>is</span></span> <span><span>no</span></span> <span><span>Ltac</span></span> <span><span>named</span></span> <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:exn.There-is-no-Ltac-named-‘qualid’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-tacdef_body"><span class="hole"><span class="pre">tacdef_body</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code></dt><dd><p>Permits definition of mutually recursive tactics.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following definitions are equivalent:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Ltac</span></span></span> <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Ltac</span></span></span> <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">fun</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole"><span class="pre">ltac_expr</span></span></a></span></code></p></li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="printing-ltac-tactics">
<h3>Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#printing-ltac-tactics" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.Print-Ltac">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Print</span></span> <span><span>Ltac</span></span> <a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmd.Print-Ltac" title="Permalink to this definition">¶</a></dt>
<dd><p>Defined <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> functions can be displayed using this command.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.Print-Ltac-Signatures">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Print</span></span> <span><span>Ltac</span></span> <span><span>Signatures</span></span></span></code><a class="headerlink" href="#coq:cmd.Print-Ltac-Signatures" title="Permalink to this definition">¶</a></dt>
<dd><p>This command displays a list of all user-defined tactics, with their arguments.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples-of-using-ltac">
<span id="ltac-examples"></span><h2>Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub><a class="headerlink" href="#examples-of-using-ltac" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proof-that-the-natural-numbers-have-at-least-two-elements">
<h3>Proof that the natural numbers have at least two elements<a class="headerlink" href="#proof-that-the-natural-numbers-have-at-least-two-elements" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Example: Proof that the natural numbers have at least two elements</p>
<p>The first example shows how to use pattern matching over the proof
context to prove that natural numbers have at least two
elements. This can be done as follows:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">card_nat</span><span> :</span><span>
  ~ </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span> \/ </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span>~</span><span> (</span><span>exists</span><span> x y : nat</span><span>,</span><span> </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-tactic">intros</span><span> (</span><span class="coqdoc-var">x</span><span> &amp; </span><span class="coqdoc-var">y</span><span> &amp; </span><span class="coqdoc-var">Hz</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  Hz : </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z
  ============================
  False
</span></dd>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> (</span><span class="coqdoc-var">Hz</span><span> 0), (</span><span class="coqdoc-var">Hz</span><span> 1), (</span><span class="coqdoc-var">Hz</span><span> 2).</span><span>
</span></dt><dd><span>8 goals
  
  x, y : nat
  Hz : </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z
  H : x</span><span> =</span><span> 0
  H0 : x</span><span> =</span><span> 1
  H1 : x</span><span> =</span><span> 2
  ============================
  False

goal 2 is:
 False
goal 3 is:
 False
goal 4 is:
 False
goal 5 is:
 False
goal 6 is:
 False
goal 7 is:
 False
goal 8 is:
 False
</span></dd>
</dl>
</div>
<p>At this point, the <a class="reference internal" href="../proofs/automatic-tactics/logic.html#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> tactic would finish the job:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-tactic">congruence</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>But for the purpose of the example, let's craft our own custom
tactic to solve this:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">card_nat</span><span> :</span><span>
  ~ </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span> \/ </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span>~</span><span> (</span><span>exists</span><span> x y : nat</span><span>,</span><span> </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z)
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> (</span><span class="coqdoc-var">x</span><span> &amp; </span><span class="coqdoc-var">y</span><span> &amp; </span><span class="coqdoc-var">Hz</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : nat
  Hz : </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z
  ============================
  False
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">destruct</span><span> (</span><span class="coqdoc-var">Hz</span><span> 0), (</span><span class="coqdoc-var">Hz</span><span> 1), (</span><span class="coqdoc-var">Hz</span><span> 2).</span><span>
</span></dt><dd class="coqtop-hidden"><span>8 goals
  
  x, y : nat
  Hz : </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z
  H : x</span><span> =</span><span> 0
  H0 : x</span><span> =</span><span> 1
  H1 : x</span><span> =</span><span> 2
  ============================
  False

goal 2 is:
 False
goal 3 is:
 False
goal 4 is:
 False
goal 5 is:
 False
goal 6 is:
 False
goal 7 is:
 False
goal 8 is:
 False
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
     | </span><span class="coqdoc-var">_</span><span> : ?</span><span class="coqdoc-var">a</span><span> = ?</span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">_</span><span> : ?</span><span class="coqdoc-var">a</span><span> = ?</span><span class="coqdoc-var">c</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">assert</span><span> (</span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">c</span><span>) </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-tactic">transitivity</span><span> </span><span class="coqdoc-var">a</span><span>
     </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>8 goals
  
  x, y : nat
  Hz : </span><span class="ansi-bold">forall</span><span> z : nat, x</span><span> =</span><span> z</span><span> \/</span><span> y</span><span> =</span><span> z
  H : x</span><span> =</span><span> 0
  H0 : x</span><span> =</span><span> 1
  H1 : x</span><span> =</span><span> 2
  H2 : 1</span><span> =</span><span> 2
  ============================
  False

goal 2 is:
 False
goal 3 is:
 False
goal 4 is:
 False
goal 5 is:
 False
goal 6 is:
 False
goal 7 is:
 False
goal 8 is:
 False
</span></dd>
<dt><span></span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-tactic">discriminate</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>Notice that all the (very similar) cases coming from the three
eliminations (with three distinct natural numbers) are successfully
solved by a <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code> structure and, in particular, with only one
pattern (use of non-linear matching).</p>
</div>
</div>
<div class="section" id="proving-that-a-list-is-a-permutation-of-a-second-list">
<h3>Proving that a list is a permutation of a second list<a class="headerlink" href="#proving-that-a-list-is-a-permutation-of-a-second-list" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Example: Proving that a list is a permutation of a second list</p>
<p>Let's first define the permutation predicate:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-keyword">Sort</span><span>.</span><span>
</span></dt><dt><span></span><span>
  </span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
</span></dd>
<dt><span></span><span>
  </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">perm</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
  | </span><span class="coqdoc-var">perm_refl</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">l</span><span>
  | </span><span class="coqdoc-var">perm_cons</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l0</span><span> </span><span class="coqdoc-var">l1</span><span>, </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">l0</span><span> </span><span class="coqdoc-var">l1</span><span> -&gt; </span><span class="coqdoc-var">perm</span><span> (</span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">l0</span><span>) (</span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">l1</span><span>)</span><span>
  | </span><span class="coqdoc-var">perm_append</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">perm</span><span> (</span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">l</span><span>) (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">nil</span><span>)</span><span>
  | </span><span class="coqdoc-var">perm_trans</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l0</span><span> </span><span class="coqdoc-var">l1</span><span> </span><span class="coqdoc-var">l2</span><span>, </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">l0</span><span> </span><span class="coqdoc-var">l1</span><span> -&gt; </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">l1</span><span> </span><span class="coqdoc-var">l2</span><span> -&gt; </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">l0</span><span> </span><span class="coqdoc-var">l2</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>perm is defined
perm_ind is defined
perm_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-keyword">Sort</span><span>.</span><span>
</span></dt></dl>
<span></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span><span>
</span></dt></dl>
</div>
<p>Next we define an auxiliary tactic <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">perm_aux</span></span></code> which takes an
argument used to control the recursion depth. This tactic works as
follows: If the lists are identical (i.e. convertible), it
completes the proof. Otherwise, if the lists have identical heads,
it looks at their tails.  Finally, if the lists have different
heads, it rotates the first list by putting its head at the end.</p>
<p>Every time we perform a rotation, we decrement <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>. When <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>
drops down to <code class="code Coq docutils literal notranslate"><span class="literal number integer"><span class="pre">1</span></span></code>, we stop performing rotations and we fail.
The idea is to give the length of the list as the initial value of
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>. This way of counting the number of rotations will avoid
going back to a head that had been considered before.</p>
<p>From Section <a class="reference internal" href="#ltac-syntax"><span class="std std-ref">Syntax</span></a> we know that Ltac has a primitive
notion of integers, but they are only used as arguments for
primitive tactics and we cannot make computations with them. Thus,
instead, we use Coq's natural number type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">perm_aux</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
  | |- (</span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">_</span><span> ?</span><span class="coqdoc-var">l</span><span> ?</span><span class="coqdoc-var">l</span><span>) =&gt; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">perm_refl</span><span>
  | |- (</span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">_</span><span> (?</span><span class="coqdoc-var">a</span><span> :: ?</span><span class="coqdoc-var">l1</span><span>) (?</span><span class="coqdoc-var">a</span><span> :: ?</span><span class="coqdoc-var">l2</span><span>)) =&gt;</span><span>
     </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">newn</span><span> := </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l1</span><span>) </span><span class="coqdoc-tactic">in</span><span>
         (</span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">perm_cons</span><span>; </span><span class="coqdoc-var">perm_aux</span><span> </span><span class="coqdoc-var">newn</span><span>)</span><span>
  | |- (</span><span class="coqdoc-var">perm</span><span> ?</span><span class="coqdoc-var">A</span><span> (?</span><span class="coqdoc-var">a</span><span> :: ?</span><span class="coqdoc-var">l1</span><span>) ?</span><span class="coqdoc-var">l2</span><span>) =&gt;</span><span>
     </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
     | 1 =&gt; </span><span class="coqdoc-tactic">fail</span><span>
     | </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
         </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">l1'</span><span> := </span><span class="coqdoc-keyword">constr</span><span>:(</span><span class="coqdoc-var">l1</span><span> ++ </span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">nil</span><span>) </span><span class="coqdoc-tactic">in</span><span>
         (</span><span class="coqdoc-tactic">apply</span><span> (</span><span class="coqdoc-var">perm_trans</span><span> </span><span class="coqdoc-var">A</span><span> (</span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">l1</span><span>) </span><span class="coqdoc-var">l1'</span><span> </span><span class="coqdoc-var">l2</span><span>);</span><span>
         [ </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">perm_append</span><span> | </span><span class="coqdoc-tactic">compute</span><span>; </span><span class="coqdoc-var">perm_aux</span><span> (</span><span class="coqdoc-var">pred</span><span> </span><span class="coqdoc-var">n</span><span>) ])</span><span>
     </span><span class="coqdoc-keyword">end</span><span>
  </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>perm_aux is defined
</span></dd>
</dl>
</div>
<p>The main tactic is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">solve_perm</span></span></code>. It computes the lengths of the
two lists and uses them as arguments to call <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">perm_aux</span></span></code> if the
lengths are equal. (If they aren't, the lists cannot be
permutations of each other.)</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">solve_perm</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
  | |- (</span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">_</span><span> ?</span><span class="coqdoc-var">l1</span><span> ?</span><span class="coqdoc-var">l2</span><span>) =&gt;</span><span>
     </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l1</span><span> = </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l2</span><span>) </span><span class="coqdoc-keyword">with</span><span>
     | (?</span><span class="coqdoc-var">n</span><span> = ?</span><span class="coqdoc-var">n</span><span>) =&gt; </span><span class="coqdoc-var">perm_aux</span><span> </span><span class="coqdoc-var">n</span><span>
     </span><span class="coqdoc-keyword">end</span><span>
  </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>solve_perm is defined
</span></dd>
</dl>
</div>
<p>And now, here is how we can use the tactic <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">solve_perm</span></span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">nat</span><span> (1 :: 2 :: 3 :: </span><span class="coqdoc-var">nil</span><span>) (3 :: 2 :: 1 :: </span><span class="coqdoc-var">nil</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  perm nat (1 </span><span>:: </span><span>2 </span><span>:: </span><span>3 </span><span>:: </span><span>nil) (3 </span><span>:: </span><span>2 </span><span>:: </span><span>1 </span><span>:: </span><span>nil)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">solve_perm</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">perm</span><span> </span><span class="coqdoc-var">nat</span><span>
       (0 :: 1 :: 2 :: 3 :: 4 :: 5 :: 6 :: 7 :: 8 :: 9 :: </span><span class="coqdoc-var">nil</span><span>)</span><span>
       (0 :: 2 :: 4 :: 6 :: 8 :: 9 :: 7 :: 5 :: 3 :: 1 :: </span><span class="coqdoc-var">nil</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  perm nat (0 </span><span>:: </span><span>1 </span><span>:: </span><span>2 </span><span>:: </span><span>3 </span><span>:: </span><span>4 </span><span>:: </span><span>5 </span><span>:: </span><span>6 </span><span>:: </span><span>7 </span><span>:: </span><span>8 </span><span>:: </span><span>9 </span><span>:: </span><span>nil)
    (0 </span><span>:: </span><span>2 </span><span>:: </span><span>4 </span><span>:: </span><span>6 </span><span>:: </span><span>8 </span><span>:: </span><span>9 </span><span>:: </span><span>7 </span><span>:: </span><span>5 </span><span>:: </span><span>3 </span><span>:: </span><span>1 </span><span>:: </span><span>nil)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">solve_perm</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="deciding-intuitionistic-propositional-logic">
<h3>Deciding intuitionistic propositional logic<a class="headerlink" href="#deciding-intuitionistic-propositional-logic" title="Permalink to this headline">¶</a></h3>
<p>Pattern matching on goals allows powerful backtracking when returning tactic
values. An interesting application is the problem of deciding intuitionistic
propositional logic. Considering the contraction-free sequent calculi LJT* of
Roy Dyckhoff <a class="reference internal" href="../zebibliography.html#dyc92" id="id8">[Dyc92]</a>, it is quite natural to code such a tactic using the
tactic language as shown below.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">basic</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | |- </span><span class="coqdoc-var">True</span><span> =&gt; </span><span class="coqdoc-tactic">trivial</span><span>
    | </span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">False</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">contradiction</span><span>
    | </span><span class="coqdoc-var">_</span><span> : ?</span><span class="coqdoc-var">A</span><span> |- ?</span><span class="coqdoc-var">A</span><span> =&gt; </span><span class="coqdoc-tactic">assumption</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>basic is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">simplify</span><span> :=</span><span>
</span><span class="coqdoc-tactic">repeat</span><span> (</span><span class="coqdoc-tactic">intros</span><span>;</span><span>
    </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
        | </span><span class="coqdoc-var">H</span><span> : ~ </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">red</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H</span><span>
        | </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">_</span><span> /\ </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
            </span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">do</span><span> 2 </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span>
        | </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">_</span><span> \/ </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
            </span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span>
        | </span><span class="coqdoc-var">H</span><span> : ?</span><span class="coqdoc-var">A</span><span> /\ ?</span><span class="coqdoc-var">B</span><span> -&gt; ?</span><span class="coqdoc-var">C</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
            </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>);</span><span>
                [ </span><span class="coqdoc-tactic">intro</span><span> | </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">split</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
        | </span><span class="coqdoc-var">H</span><span>: ?</span><span class="coqdoc-var">A</span><span> \/ ?</span><span class="coqdoc-var">B</span><span> -&gt; ?</span><span class="coqdoc-var">C</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
            </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>);</span><span>
                [ </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>);</span><span>
                    [ </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span>
                    | </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">left</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
                | </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">right</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
        | </span><span class="coqdoc-var">H0</span><span> : ?</span><span class="coqdoc-var">A</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span>, </span><span class="coqdoc-var">H1</span><span> : ?</span><span class="coqdoc-var">A</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
            </span><span class="coqdoc-tactic">cut</span><span> </span><span class="coqdoc-var">B</span><span>; [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H0</span><span> | </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H0</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
        | |- </span><span class="coqdoc-var">_</span><span> /\ </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">split</span><span>
        | |- ~ </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">red</span><span>
    </span><span class="coqdoc-keyword">end</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>simplify is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">my_tauto</span><span> :=</span><span>
  </span><span class="coqdoc-var">simplify</span><span>; </span><span class="coqdoc-var">basic</span><span> ||</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
      | </span><span class="coqdoc-var">H</span><span> : (?</span><span class="coqdoc-var">A</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span>) -&gt; ?</span><span class="coqdoc-var">C</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
          </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>);</span><span>
              [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>);</span><span>
                  [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">cut</span><span> </span><span class="coqdoc-var">C</span><span>;</span><span>
                      [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span> | </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
                  | </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span> ]</span><span>
              | </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]; </span><span class="coqdoc-var">my_tauto</span><span>
      | </span><span class="coqdoc-var">H</span><span> : ~ ?</span><span class="coqdoc-var">A</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
          </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">False</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>);</span><span>
              [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">cut</span><span> (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>);</span><span>
                  [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">cut</span><span> </span><span class="coqdoc-var">B</span><span>;</span><span>
                      [ </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span> | </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]</span><span>
                  | </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span> ]</span><span>
              | </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">red</span><span>; </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">assumption</span><span> ]; </span><span class="coqdoc-var">my_tauto</span><span>
      | |- </span><span class="coqdoc-var">_</span><span> \/ </span><span class="coqdoc-var">_</span><span> =&gt; (</span><span class="coqdoc-tactic">left</span><span>; </span><span class="coqdoc-var">my_tauto</span><span>) || (</span><span class="coqdoc-tactic">right</span><span>; </span><span class="coqdoc-var">my_tauto</span><span>)</span><span>
  </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>my_tauto is defined
</span></dd>
</dl>
</div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">basic</span></code> tries to reason using simple rules involving truth, falsity
and available assumptions. The tactic <code class="docutils literal notranslate"><span class="pre">simplify</span></code> applies all the reversible
rules of Dyckhoff’s system. Finally, the tactic <code class="docutils literal notranslate"><span class="pre">my_tauto</span></code> (the main
tactic to be called) simplifies with <code class="docutils literal notranslate"><span class="pre">simplify</span></code>, tries to conclude with
<code class="docutils literal notranslate"><span class="pre">basic</span></code> and tries several paths using the backtracking rules (one of the
four Dyckhoff’s rules for the left implication to get rid of the contraction
and the right <code class="docutils literal notranslate"><span class="pre">or</span></code>).</p>
<p>Having defined <code class="docutils literal notranslate"><span class="pre">my_tauto</span></code>, we can prove tautologies like these:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">my_tauto_ex1</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> /\</span><span> B</span><span> -&gt;</span><span> A</span><span> \/</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-var">my_tauto</span><span>. </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>
No more goals.

</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">my_tauto_ex2</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, (~ ~ </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) -&gt; (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) -&gt; ~ ~ </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, (</span><span>~</span><span> </span><span>~</span><span> B</span><span> -&gt;</span><span> B)</span><span> -&gt;</span><span> (A</span><span> -&gt;</span><span> B)</span><span> -&gt;</span><span> </span><span>~</span><span> </span><span>~</span><span> A</span><span> -&gt;</span><span> B
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-var">my_tauto</span><span>. </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>
No more goals.

</span></dd>
</dl>
</div>
</div>
<div class="section" id="deciding-type-isomorphisms">
<h3>Deciding type isomorphisms<a class="headerlink" href="#deciding-type-isomorphisms" title="Permalink to this headline">¶</a></h3>
<p>A trickier problem is to decide equalities between types modulo
isomorphisms. Here, we choose to use the isomorphisms of the simply
typed λ-calculus with Cartesian product and unit type (see, for
example, <a class="reference internal" href="../zebibliography.html#rc95" id="id9">[dC95]</a>). The axioms of this λ-calculus are given below.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">type_scope</span><span>.</span><span>
</span></dt></dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Iso_axioms</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
B is declared
C is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Com</span><span> : </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span> = </span><span class="coqdoc-var">B</span><span> * </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Com is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Ass</span><span> : </span><span class="coqdoc-var">A</span><span> * (</span><span class="coqdoc-var">B</span><span> * </span><span class="coqdoc-var">C</span><span>) = </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span> * </span><span class="coqdoc-var">C</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Ass is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Cur</span><span> : (</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) = (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>Cur is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Dis</span><span> : (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> * </span><span class="coqdoc-var">C</span><span>) = (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) * (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>Dis is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">P_unit</span><span> : </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">unit</span><span> = </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P_unit is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">AR_unit</span><span> : (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">unit</span><span>) = </span><span class="coqdoc-var">unit</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>AR_unit is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">AL_unit</span><span> : (</span><span class="coqdoc-var">unit</span><span> -&gt; </span><span class="coqdoc-var">A</span><span>) = </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>AL_unit is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">Cons</span><span> : </span><span class="coqdoc-var">B</span><span> = </span><span class="coqdoc-var">C</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span> = </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">C</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
  ============================
  B</span><span> =</span><span> C</span><span> -&gt;</span><span> A</span><span> *</span><span> B</span><span> =</span><span> A</span><span> *</span><span> C
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">Heq</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">Heq</span><span>; </span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">Iso_axioms</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">ty</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">ty</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">B</span><span> * ?</span><span class="coqdoc-var">C</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> &lt;- (</span><span class="coqdoc-var">Ass</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">B</span><span> -&gt; ?</span><span class="coqdoc-var">C</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">Cur</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span> * ?</span><span class="coqdoc-var">C</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">Dis</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">unit</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">P_unit</span><span> </span><span class="coqdoc-var">A</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | </span><span class="coqdoc-var">unit</span><span> * ?</span><span class="coqdoc-var">B</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">Com</span><span> </span><span class="coqdoc-var">unit</span><span> </span><span class="coqdoc-var">B</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">unit</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">AR_unit</span><span> </span><span class="coqdoc-var">A</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | </span><span class="coqdoc-var">unit</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">AL_unit</span><span> </span><span class="coqdoc-var">B</span><span>); </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">B</span><span> =&gt;</span><span>
        (</span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">A</span><span>; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>) ||</span><span>
        (</span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">B</span><span>; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>)</span><span>
    | ?</span><span class="coqdoc-var">A</span><span> -&gt; ?</span><span class="coqdoc-var">B</span><span> =&gt;</span><span>
        (</span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">A</span><span>; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>) ||</span><span>
        (</span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">B</span><span>; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">simplify_type_eq</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | |- ?</span><span class="coqdoc-var">A</span><span> = ?</span><span class="coqdoc-var">B</span><span> =&gt; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">A</span><span>; </span><span class="coqdoc-tactic">try</span><span> </span><span class="coqdoc-var">simplify_type</span><span> </span><span class="coqdoc-var">B</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>simplify_type is defined
simplify_type_eq is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">len</span><span> </span><span class="coqdoc-var">trm</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">trm</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | </span><span class="coqdoc-var">_</span><span> * ?</span><span class="coqdoc-var">B</span><span> =&gt; </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">succ</span><span> := </span><span class="coqdoc-var">len</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-keyword">constr</span><span>:(</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">succ</span><span>)</span><span>
    | </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-keyword">constr</span><span>:(1)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>len is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">assoc</span><span> := </span><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> &lt;- </span><span class="coqdoc-var">Ass</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>assoc is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">solve_type_eq</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | |- ?</span><span class="coqdoc-var">A</span><span> = ?</span><span class="coqdoc-var">A</span><span> =&gt; </span><span class="coqdoc-tactic">reflexivity</span><span>
    | |- ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">B</span><span> = ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">C</span><span> =&gt;</span><span>
        </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Cons</span><span>; </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">newn</span><span> := </span><span class="coqdoc-var">len</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">solve_type_eq</span><span> </span><span class="coqdoc-var">newn</span><span>
    | |- ?</span><span class="coqdoc-var">A</span><span> * ?</span><span class="coqdoc-var">B</span><span> = ?</span><span class="coqdoc-var">C</span><span> =&gt;</span><span>
        </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
            | 1 =&gt; </span><span class="coqdoc-tactic">fail</span><span>
            | </span><span class="coqdoc-var">_</span><span> =&gt;</span><span>
                </span><span class="coqdoc-tactic">pattern</span><span> (</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span>) </span><span class="coqdoc-tactic">at</span><span> 1; </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">Com</span><span>; </span><span class="coqdoc-var">assoc</span><span>; </span><span class="coqdoc-var">solve_type_eq</span><span> (</span><span class="coqdoc-var">pred</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
        </span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>solve_type_eq is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">compare_structure</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span>
    | |- ?</span><span class="coqdoc-var">A</span><span> = ?</span><span class="coqdoc-var">B</span><span> =&gt;</span><span>
        </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">l1</span><span> := </span><span class="coqdoc-var">len</span><span> </span><span class="coqdoc-var">A</span><span>
        </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">l2</span><span> := </span><span class="coqdoc-var">len</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-tactic">in</span><span>
            </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-tactic">eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">l1</span><span> = </span><span class="coqdoc-var">l2</span><span>) </span><span class="coqdoc-keyword">with</span><span>
                | ?</span><span class="coqdoc-var">n</span><span> = ?</span><span class="coqdoc-var">n</span><span> =&gt; </span><span class="coqdoc-var">solve_type_eq</span><span> </span><span class="coqdoc-var">n</span><span>
            </span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>compare_structure is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">solve_iso</span><span> := </span><span class="coqdoc-var">simplify_type_eq</span><span>; </span><span class="coqdoc-var">compare_structure</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>solve_iso is defined
</span></dd>
</dl>
</div>
<p>The tactic to judge equalities modulo this axiomatization is shown above.
The algorithm is quite simple. First types are simplified using axioms that
can be oriented (this is done by <code class="docutils literal notranslate"><span class="pre">simplify_type</span></code> and <code class="docutils literal notranslate"><span class="pre">simplify_type_eq</span></code>).
The normal forms are sequences of Cartesian products without a Cartesian product
in the left component. These normal forms are then compared modulo permutation
of the components by the tactic <code class="docutils literal notranslate"><span class="pre">compare_structure</span></code>. If they have the same
length, the tactic <code class="docutils literal notranslate"><span class="pre">solve_type_eq</span></code> attempts to prove that the types are equal.
The main tactic that puts all these components together is <code class="docutils literal notranslate"><span class="pre">solve_iso</span></code>.</p>
<p>Here are examples of what can be solved by <code class="docutils literal notranslate"><span class="pre">solve_iso</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">solve_iso_ex1</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>, </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">unit</span><span> * </span><span class="coqdoc-var">B</span><span> = </span><span class="coqdoc-var">B</span><span> * (</span><span class="coqdoc-var">unit</span><span> * </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, A</span><span> *</span><span> unit</span><span> *</span><span> B</span><span> =</span><span> B</span><span> *</span><span> (unit</span><span> *</span><span> A)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-var">solve_iso</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">solve_iso_ex2</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> : </span><span class="coqdoc-keyword">Set</span><span>,</span><span>
    (</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">unit</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> * (</span><span class="coqdoc-var">C</span><span> * </span><span class="coqdoc-var">unit</span><span>)) =</span><span>
    (</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">unit</span><span> -&gt; (</span><span class="coqdoc-var">C</span><span> -&gt; </span><span class="coqdoc-var">unit</span><span>) * </span><span class="coqdoc-var">C</span><span>) * (</span><span class="coqdoc-var">unit</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
  (A</span><span> *</span><span> unit</span><span> -&gt;</span><span> B</span><span> *</span><span> (C</span><span> *</span><span> unit))</span><span> =</span><span>
  (A</span><span> *</span><span> unit</span><span> -&gt;</span><span> (C</span><span> -&gt;</span><span> unit)</span><span> *</span><span> C)</span><span> *</span><span> (unit</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> B)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-var">solve_iso</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
</div>
<div class="section" id="debugging-ltac-tactics">
<h2>Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#debugging-ltac-tactics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="backtraces">
<h3>Backtraces<a class="headerlink" href="#backtraces" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.Ltac-Backtrace">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <span><span>Backtrace</span></span></span></code><a class="headerlink" href="#coq:flag.Ltac-Backtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting this <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> displays a backtrace on Ltac failures that can be useful
to find out what went wrong. It is disabled by default for performance
reasons.</p>
</dd></dl>

</div>
<div class="section" id="tracing-execution">
<h3>Tracing execution<a class="headerlink" href="#tracing-execution" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.Info">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Info</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:cmd.Info" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies <a class="reference internal" href="#grammar-token-ltac_expr"><code class="xref std std-token docutils literal notranslate"><span class="pre">ltac_expr</span></code></a> and prints a trace of the tactics that were successfully
applied, discarding branches that failed.
<a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> tactics appear in the trace as comments containing the output.</p>
<p>This command is valid only in proof mode.  It accepts <a class="reference internal" href="#goal-selectors"><span class="std std-ref">Goal selectors</span></a>.</p>
<p>The number <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> is the unfolding level of tactics in the trace. At level
0, the trace contains a sequence of tactics in the actual script, at level 1,
the trace will be the concatenation of the traces of these tactics, etc…</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span>; </span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>t is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span>=0.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span>exists</span><span> n : nat</span><span>,</span><span> n</span><span> =</span><span> 0
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Info</span><span> 0 </span><span class="coqdoc-var">t</span><span> 1||</span><span class="coqdoc-var">t</span><span> 0.</span><span>
</span></dt><dd><span class="ansi-fg-light-green">exists</span><span>  with 0;&lt;coq-core.plugins.ltac::reflexivity&#64;0&gt;
No more goals.
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span>exists</span><span> n : nat</span><span>,</span><span> n</span><span> =</span><span> 0
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Info</span><span> 1 </span><span class="coqdoc-var">t</span><span> 1||</span><span class="coqdoc-var">t</span><span> 0.</span><span>
</span></dt><dd><span>&lt;coq-core.plugins.ltac::exists&#64;1&gt;  with 0;simple refine </span><span class="ansi-fg-light-blue">?Goal</span><span>
No more goals.
</span></dd>
</dl>
</div>
</div>
<p>The trace produced by <a class="reference internal" href="#coq:cmd.Info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> tries its best to be a reparsable
<code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> script, but this goal is not achievable in all generality.
So some of the output traces will contain oddities.</p>
<p>As an additional help for debugging, the trace produced by <a class="reference internal" href="#coq:cmd.Info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> contains
(in comments) the messages produced by the <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> tactical at the right
position in the script. In particular, the calls to idtac in branches which failed are
not printed.</p>
<dl class="coq opt">
<dt id="coq:opt.Info-Level">
<em class="property"><span class="sigannot">Option</span></em> <code class="sig-name descname"><span class="notation"><span><span>Info</span></span> <span><span>Level</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></code><a class="headerlink" href="#coq:opt.Info-Level" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../language/core/basic.html#term-option"><span class="xref std std-term">option</span></a> is an alternative to the <a class="reference internal" href="#coq:cmd.Info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> command.</p>
<p>This will automatically print the same trace as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Info</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> at each
tactic call. The unfolding level can be overridden by a call to the
<a class="reference internal" href="#coq:cmd.Info" title="Info"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Info</span></code></a> command.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interactive-debugger">
<span id="id10"></span><h3>Interactive debugger<a class="headerlink" href="#interactive-debugger" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.Ltac-Debug">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <span><span>Debug</span></span></span></code><a class="headerlink" href="#coq:flag.Ltac-Debug" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag, when set, enables the step-by-step debugger in the <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> interpreter.
The debugger is supported in <code class="docutils literal notranslate"><span class="pre">coqtop</span></code> and Proof General by printing information
on the console and accepting typed commands.  In addition, CoqIDE now supports a
<a class="reference internal" href="../practical-tools/coqide.html#coqide-debugger"><span class="std std-ref">visual debugger</span></a> with additional capabilities.</p>
</dd></dl>

<p>When the debugger is activated in <code class="docutils literal notranslate"><span class="pre">coqtop</span></code>, it stops at every step of the evaluation of
the current <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> expression and prints information on what it is doing.
The debugger stops, prompting for a command which can be one of the
following:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>newline</p></td>
<td><p>go to the next step</p></td>
</tr>
<tr class="row-even"><td><p>h</p></td>
<td><p>get help</p></td>
</tr>
<tr class="row-odd"><td><p>r n</p></td>
<td><p>advance n steps further</p></td>
</tr>
<tr class="row-even"><td><p>r string</p></td>
<td><p>advance up to the next call to “idtac string”</p></td>
</tr>
<tr class="row-odd"><td><p>s</p></td>
<td><p>continue current evaluation without stopping</p></td>
</tr>
<tr class="row-even"><td><p>x</p></td>
<td><p>exit current evaluation</p></td>
</tr>
</tbody>
</table>
<dl class="coq exn">
<dt id="coq:exn.Debug-mode-not-available-in-the-IDE">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Debug</span></span> <span><span>mode</span></span> <span><span>not</span></span> <span><span>available</span></span> <span><span>in</span></span> <span><span>the</span></span> <span><span>IDE</span></span></span></code><a class="headerlink" href="#coq:exn.Debug-mode-not-available-in-the-IDE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A non-interactive mode for the debugger is available via the flag:</p>
<dl class="coq flag">
<dt id="coq:flag.Ltac-Batch-Debug">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <span><span>Batch</span></span> <span><span>Debug</span></span></span></code><a class="headerlink" href="#coq:flag.Ltac-Batch-Debug" title="Permalink to this definition">¶</a></dt>
<dd><p>This flag has the effect of presenting a newline at every prompt, when
the debugger is on in <code class="docutils literal notranslate"><span class="pre">coqtop</span></code>.  (It has no effect when running the
CoqIDE debugger.)  The debug log thus created, which does not require
user input to generate when this flag is set, can then be run through
external tools such as diff.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.Debug">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Debug</span></span> <span class="alternative"><span class="alternative-block"><span><span>On</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>Off</span></span></span></span></span></code><a class="headerlink" href="#coq:cmd.Debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Set</span></span></span> <span><span><span class="pre">Ltac</span></span></span> <span><span><span class="pre">Debug</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Unset</span></span></span> <span><span><span class="pre">Ltac</span></span></span> <span><span><span class="pre">Debug</span></span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="profiling-ltac-tactics">
<h3>Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics<a class="headerlink" href="#profiling-ltac-tactics" title="Permalink to this headline">¶</a></h3>
<p>It is possible to measure the time spent in invocations of primitive
tactics as well as tactics defined in <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> and their inner
invocations. The primary use is the development of complex tactics,
which can sometimes be so slow as to impede interactive usage. The
reasons for the performance degradation can be intricate, like a slowly
performing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> match or a sub-tactic whose performance only
degrades in certain situations. The profiler generates a call tree and
indicates the time spent in a tactic depending on its calling context. Thus
it allows to locate the part of a tactic definition that contains the
performance issue.</p>
<dl class="coq flag">
<dt id="coq:flag.Ltac-Profiling">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <span><span>Profiling</span></span></span></code><a class="headerlink" href="#coq:flag.Ltac-Profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> enables and disables the profiler.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.Show-Ltac-Profile">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Show</span></span> <span><span>Ltac</span></span> <span><span>Profile</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>CutOff</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><span class="hole">integer</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.Show-Ltac-Profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the profile.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">CutOff</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><span class="hole"><span class="pre">integer</span></span></a></span></code></dt><dd><p>By default, tactics that account for less than 2% of the total time are not displayed.
<code class="docutils literal notranslate"><span class="pre">CutOff</span></code> lets you specify a different percentage.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code></p>
<blockquote>
<div><p>Limits the profile to all tactics that start with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>. Append a period
(.) to the string if you only want exactly that name.</p>
</div></blockquote>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.Reset-Ltac-Profile">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Reset</span></span> <span><span>Ltac</span></span> <span><span>Profile</span></span></span></code><a class="headerlink" href="#coq:cmd.Reset-Ltac-Profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the profile, that is, deletes all accumulated information.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Backtracking across a <a class="reference internal" href="#coq:cmd.Reset-Ltac-Profile" title="Reset Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> will not restore the information.</p>
</div>
</dd></dl>

<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Lia</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>[Loading ML file ring_plugin.cmxs (using legacy method) ... done]
[Loading ML file zify_plugin.cmxs (using legacy method) ... done]
[Loading ML file micromega_plugin.cmxs (using legacy method) ... done]
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">mytauto</span><span> := </span><span class="coqdoc-tactic">tauto</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>mytauto is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">tac</span><span> := </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">split</span><span>; </span><span class="coqdoc-var">lia</span><span> || </span><span class="coqdoc-var">mytauto</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>tac is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> := (</span><span class="coqdoc-var">x</span><span> + (</span><span class="coqdoc-var">y</span><span> - </span><span class="coqdoc-var">x</span><span>)) (</span><span class="coqdoc-var">only</span><span> </span><span class="coqdoc-var">parsing</span><span>).</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">D</span><span> </span><span class="coqdoc-var">E</span><span> </span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">I</span><span> </span><span class="coqdoc-var">J</span><span> </span><span class="coqdoc-var">K</span><span> </span><span class="coqdoc-var">L</span><span> </span><span class="coqdoc-var">M</span><span> </span><span class="coqdoc-var">N</span><span> </span><span class="coqdoc-var">O</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">T</span><span> </span><span class="coqdoc-var">U</span><span> </span><span class="coqdoc-var">V</span><span> </span><span class="coqdoc-var">W</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-var">Y</span><span> </span><span class="coqdoc-var">Z</span><span>,</span><span>
    </span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>) = </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> /\ </span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>) = </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span>
    /\</span><span>
    (</span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> /\ </span><span class="coqdoc-var">D</span><span> /\ </span><span class="coqdoc-var">E</span><span> /\ </span><span class="coqdoc-var">F</span><span> /\ </span><span class="coqdoc-var">G</span><span> /\ </span><span class="coqdoc-var">H</span><span> /\ </span><span class="coqdoc-var">I</span><span> /\ </span><span class="coqdoc-var">J</span><span> /\ </span><span class="coqdoc-var">K</span><span> /\ </span><span class="coqdoc-var">L</span><span> /\ </span><span class="coqdoc-var">M</span><span> /\</span><span>
     </span><span class="coqdoc-var">N</span><span> /\ </span><span class="coqdoc-var">O</span><span> /\ </span><span class="coqdoc-var">P</span><span> /\ </span><span class="coqdoc-var">Q</span><span> /\ </span><span class="coqdoc-var">R</span><span> /\ </span><span class="coqdoc-var">S</span><span> /\ </span><span class="coqdoc-var">T</span><span> /\ </span><span class="coqdoc-var">U</span><span> /\ </span><span class="coqdoc-var">V</span><span> /\ </span><span class="coqdoc-var">W</span><span> /\ </span><span class="coqdoc-var">X</span><span> /\ </span><span class="coqdoc-var">Y</span><span> /\ </span><span class="coqdoc-var">Z</span><span>
     -&gt;</span><span>
     </span><span class="coqdoc-var">Z</span><span> /\ </span><span class="coqdoc-var">Y</span><span> /\ </span><span class="coqdoc-var">X</span><span> /\ </span><span class="coqdoc-var">W</span><span> /\ </span><span class="coqdoc-var">V</span><span> /\ </span><span class="coqdoc-var">U</span><span> /\ </span><span class="coqdoc-var">T</span><span> /\ </span><span class="coqdoc-var">S</span><span> /\ </span><span class="coqdoc-var">R</span><span> /\ </span><span class="coqdoc-var">Q</span><span> /\ </span><span class="coqdoc-var">P</span><span> /\ </span><span class="coqdoc-var">O</span><span> /\ </span><span class="coqdoc-var">N</span><span> /\</span><span>
     </span><span class="coqdoc-var">M</span><span> /\ </span><span class="coqdoc-var">L</span><span> /\ </span><span class="coqdoc-var">K</span><span> /\ </span><span class="coqdoc-var">J</span><span> /\ </span><span class="coqdoc-var">I</span><span> /\ </span><span class="coqdoc-var">H</span><span> /\ </span><span class="coqdoc-var">G</span><span> /\ </span><span class="coqdoc-var">F</span><span> /\ </span><span class="coqdoc-var">E</span><span> /\ </span><span class="coqdoc-var">D</span><span> /\ </span><span class="coqdoc-var">C</span><span> /\ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (x y z : nat)
    (A B C D E F G H I J K L M N O P Q R S T U V W X Y Z : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>),
  x</span><span> +</span><span> (y</span><span> +</span><span> (z</span><span> -</span><span> y)</span><span> -</span><span> x)</span><span> =</span><span> x</span><span> +</span><span> (y</span><span> -</span><span> x)</span><span> +</span><span> (z</span><span> -</span><span> (x</span><span> +</span><span> (y</span><span> -</span><span> x)))</span><span> /\</span><span>
  x</span><span> +</span><span> (y</span><span> +</span><span> (z</span><span> -</span><span> y)</span><span> -</span><span> x)</span><span> =</span><span> x</span><span> +</span><span> (y</span><span> -</span><span> x)</span><span> +</span><span> (z</span><span> -</span><span> (x</span><span> +</span><span> (y</span><span> -</span><span> x)))</span><span> /\</span><span>
  (A</span><span> /\</span><span>
   B</span><span> /\</span><span>
   C</span><span> /\</span><span>
   D</span><span> /\</span><span>
   E</span><span> /\</span><span>
   F</span><span> /\</span><span>
   G</span><span> /\</span><span>
   H</span><span> /\</span><span>
   I</span><span> /\</span><span>
   J</span><span> /\</span><span>
   K</span><span> /\</span><span>
   L</span><span> /\</span><span> M</span><span> /\</span><span> N</span><span> /\</span><span> O</span><span> /\</span><span> P</span><span> /\</span><span> Q</span><span> /\</span><span> R</span><span> /\</span><span> S</span><span> /\</span><span> T</span><span> /\</span><span> U</span><span> /\</span><span> V</span><span> /\</span><span> W</span><span> /\</span><span> X</span><span> /\</span><span> Y</span><span> /\</span><span> Z</span><span> -&gt;</span><span>
   Z</span><span> /\</span><span>
   Y</span><span> /\</span><span>
   X</span><span> /\</span><span>
   W</span><span> /\</span><span>
   V</span><span> /\</span><span>
   U</span><span> /\</span><span>
   T</span><span> /\</span><span>
   S</span><span> /\</span><span>
   R</span><span> /\</span><span>
   Q</span><span> /\</span><span>
   P</span><span> /\</span><span>
   O</span><span> /\</span><span> N</span><span> /\</span><span> M</span><span> /\</span><span> L</span><span> /\</span><span> K</span><span> /\</span><span> J</span><span> /\</span><span> I</span><span> /\</span><span> H</span><span> /\</span><span> G</span><span> /\</span><span> F</span><span> /\</span><span> E</span><span> /\</span><span> D</span><span> /\</span><span> C</span><span> /\</span><span> B</span><span> /\</span><span> A)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">Profiling</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-var">tac</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> </span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">Profile</span><span>.</span><span>
</span></dt><dd><span>total time:      2.200s

 tactic                                   local  total   calls       max 
────────────────────────────────────────┴──────┴──────┴───────┴─────────┘
─tac -----------------------------------   0.2% 100.0%       1    2.200s
─&lt;Coq.Init.Tauto.with_uniform_flags&gt; ---   0.0%  94.8%      26    0.157s
─&lt;Coq.Init.Tauto.tauto_gen&gt; ------------   0.0%  94.8%      26    0.157s
─&lt;Coq.Init.Tauto.tauto_intuitionistic&gt; -   0.0%  94.7%      26    0.157s
─t_tauto_intuit ------------------------   0.1%  94.6%      26    0.157s
─&lt;Coq.Init.Tauto.simplif&gt; --------------  68.4%  91.2%      26    0.154s
─&lt;Coq.Init.Tauto.is_conj&gt; --------------  14.4%  14.4%   28756    0.017s
─elim id -------------------------------   5.5%   5.5%     650    0.011s
─lia -----------------------------------   0.1%   4.7%      28    0.084s
─xlia (tactic) -------------------------   3.5%   3.9%      28    0.080s
─&lt;Coq.Init.Tauto.axioms&gt; ---------------   3.3%   3.4%    1430    0.005s

 tactic                                   local  total   calls       max 
────────────────────────────────────────┴──────┴──────┴───────┴─────────┘
─tac -----------------------------------   0.2% 100.0%       1    2.200s
 ├─&lt;Coq.Init.Tauto.with_uniform_flags&gt; -   0.0%  94.8%      26    0.157s
 │└&lt;Coq.Init.Tauto.tauto_gen&gt; ----------   0.0%  94.8%      26    0.157s
 │└&lt;Coq.Init.Tauto.tauto_intuitionistic&gt;   0.0%  94.7%      26    0.157s
 │└t_tauto_intuit ----------------------   0.1%  94.6%      26    0.157s
 │ ├─&lt;Coq.Init.Tauto.simplif&gt; ----------  68.4%  91.2%      26    0.154s
 │ │ ├─&lt;Coq.Init.Tauto.is_conj&gt; --------  14.4%  14.4%   28756    0.017s
 │ │ └─elim id -------------------------   5.5%   5.5%     650    0.011s
 │ └─&lt;Coq.Init.Tauto.axioms&gt; -----------   3.3%   3.4%    1430    0.005s
 └─lia ---------------------------------   0.1%   4.7%      28    0.084s
  └xlia (tactic) -----------------------   3.5%   3.9%      28    0.080s

</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> </span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">Profile</span><span> &quot;lia&quot;.</span><span>
</span></dt><dd><span>total time:      2.200s

 tactic                                   local  total   calls       max 
────────────────────────────────────────┴──────┴──────┴───────┴─────────┘
─lia -----------------------------------   0.1%   4.7%      28    0.084s

 tactic                                   local  total   calls       max 
────────────────────────────────────────┴──────┴──────┴───────┴─────────┘

</span></dd>
</dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">Profiling</span><span>.</span><span>
</span></dt></dl>
</div>
<dl class="coq tacn">
<dt id="coq:tacn.start-ltac-profiling">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>start</span></span> <span><span>ltac</span></span> <span><span>profiling</span></span></span></code><a class="headerlink" href="#coq:tacn.start-ltac-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> but enables the profiler.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.stop-ltac-profiling">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>stop</span></span> <span><span>ltac</span></span> <span><span>profiling</span></span></span></code><a class="headerlink" href="#coq:tacn.stop-ltac-profiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarly to <a class="reference internal" href="#coq:tacn.start-ltac-profiling" title="start ltac profiling"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">start</span> <span class="pre">ltac</span> <span class="pre">profiling</span></code></a>, this tactic behaves like
<a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>. Together, they allow you to exclude parts of a proof script
from profiling.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.reset-ltac-profile">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>reset</span></span> <span><span>ltac</span></span> <span><span>profile</span></span></span></code><a class="headerlink" href="#coq:tacn.reset-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to the <a class="reference internal" href="#coq:cmd.Reset-Ltac-Profile" title="Reset Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> command, which allows
resetting the profile from tactic scripts for benchmarking purposes.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.show-ltac-profile">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>show</span></span> <span><span>ltac</span></span> <span><span>profile</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>cutoff</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-integer"><span class="hole">integer</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-string"><span class="hole">string</span></a></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.show-ltac-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to the <a class="reference internal" href="#coq:cmd.Show-Ltac-Profile" title="Show Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> command,
which allows displaying the profile from tactic scripts for
benchmarking purposes.</p>
</dd></dl>

<dl class="coq warn">
<dt id="coq:warn.Ltac-Profiler-encountered-an-invalid-stack-(no-self-node).-This-can-happen-if-you-reset-the-profile-during-tactic-execution">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span><span>Ltac</span></span> <span><span>Profiler</span></span> <span><span>encountered</span></span> <span><span>an</span></span> <span><span>invalid</span></span> <span><span>stack</span></span> <span><span>(no</span></span> <span><span>self</span></span> <span><span>node).</span></span> <span><span>This</span></span> <span><span>can</span></span> <span><span>happen</span></span> <span><span>if</span></span> <span><span>you</span></span> <span><span>reset</span></span> <span><span>the</span></span> <span><span>profile</span></span> <span><span>during</span></span> <span><span>tactic</span></span> <span><span>execution</span></span></span></code><a class="headerlink" href="#coq:warn.Ltac-Profiler-encountered-an-invalid-stack-(no-self-node).-This-can-happen-if-you-reset-the-profile-during-tactic-execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently, <a class="reference internal" href="#coq:tacn.reset-ltac-profile" title="reset ltac profile"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reset</span> <span class="pre">ltac</span> <span class="pre">profile</span></code></a> is not very well-supported,
as it clears all profiling information about all tactics, including
ones above the current tactic.  As a result, the profiler has
trouble understanding where it is in tactic execution.  This mixes
especially poorly with backtracking into multi-success tactics.  In
general, non-top-level calls to <a class="reference internal" href="#coq:tacn.reset-ltac-profile" title="reset ltac profile"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reset</span> <span class="pre">ltac</span> <span class="pre">profile</span></code></a> should
be avoided.</p>
</dd></dl>

<p>You can also pass the <code class="docutils literal notranslate"><span class="pre">-profile-ltac</span></code> command line option to <code class="docutils literal notranslate"><span class="pre">coqc</span></code>, which
turns the <a class="reference internal" href="#coq:flag.Ltac-Profiling" title="Ltac Profiling"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Ltac</span> <span class="pre">Profiling</span></code></a> flag on at the beginning of each document,
and performs a <a class="reference internal" href="#coq:cmd.Show-Ltac-Profile" title="Show Ltac Profile"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Ltac</span> <span class="pre">Profile</span></code></a> at the end.</p>
</div>
<div class="section" id="run-time-optimization-tactic">
<h3>Run-time optimization tactic<a class="headerlink" href="#run-time-optimization-tactic" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.optimize_heap">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>optimize</span></span><span><span>_</span></span><span><span>heap</span></span></span></code><a class="headerlink" href="#coq:tacn.optimize_heap" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>, except that running it compacts the
heap in the OCaml run-time system. It is analogous to the
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#coq:cmd.Optimize-Heap" title="Optimize Heap"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Optimize</span> <span class="pre">Heap</span></code></a> command.</p>
</dd></dl>

<dl class="coq cmd">
<dt id="coq:cmd.infoH">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>infoH</span></span> <a class="reference internal" href="#grammar-token-ltac_expr"><span class="hole">ltac_expr</span></a></span></code><a class="headerlink" href="#coq:cmd.infoH" title="Permalink to this definition">¶</a></dt>
<dd><p>Used internally by Proof General.  See <a class="reference external" href="https://github.com/coq/coq/issues/12423">#12423</a> for
some background.</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ltac2.html" class="btn btn-neutral float-right" title="Ltac2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../proofs/creating-tactics/index.html" class="btn btn-neutral float-left" title="Creating new tactics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2021, Inria, CNRS and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  




  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Other versions</span>
      v: 8.17.1
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://coq.github.io/doc/master/refman/">dev</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/current/refman/">stable</a></dd>
        
          <dd><a href="https://coq.github.io/doc/v8.17/refman/">8.17</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.16.1/refman/">8.16</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.15.2/refman/">8.15</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.14.1/refman/">8.14</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.13.2/refman/">8.13</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.12.2/refman/">8.12</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.11.2/refman/">8.11</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.10.2/refman/">8.10</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.9.1/refman/">8.9</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.8.2/refman/">8.8</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.7.2/refman/">8.7</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.6.1/refman/">8.6</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.5pl3/refman/">8.5</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.4pl6/refman/">8.4</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.3pl5/refman/">8.3</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.2pl3/refman/">8.2</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.1pl6/refman/">8.1</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.0/doc/">8.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://github.com/coq/coq/releases/download/V8.17.1/coq-8.17.1-reference-manual.pdf">PDF</a></dd>
        
      </dl>
    </div>
  </div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>