<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tactics &mdash; Coq 8.18.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
      <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
      <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
      <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/notations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reasoning with equalities" href="../proofs/writing-proofs/equality.html" />
    <link rel="prev" title="Proof mode" href="../proofs/writing-proofs/proof-mode.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Coq
          </a>
              <div class="version">
                8.18.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Specification language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/core/index.html">Core language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/core/basic.html">Basic notions and conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#syntax-and-lexical-conventions">Syntax and lexical conventions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#syntax-conventions">Syntax conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#lexical-conventions">Lexical conventions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#essential-vocabulary">Essential vocabulary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#settings">Settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#flags-options-and-tables">Flags, Options and Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sorts.html">Sorts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/assumptions.html">Functions and assumptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#functions-fun-and-function-types-forall">Functions (fun) and function types (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#function-application">Function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#assumptions">Assumptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/definitions.html">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#top-level-definitions">Top-level definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/conversion.html">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#conversion">α-conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#delta-reduction-sect">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id4">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id7">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html">Typing rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#id6">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/variants.html">Variants and the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#id1">Variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/variants.html#private-matching-inductive-types">Private (matching) inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#definition-by-cases-match">Definition by cases: match</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#defining-record-types">Defining record types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#constructing-records">Constructing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#accessing-fields-projections">Accessing fields (projections)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#settings-for-printing-records">Settings for printing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#compatibility-constants-for-projections">Compatibility Constants for Projections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/inductive.html">Inductive types and recursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#inductive-types">Inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-indexed-inductive-types">Simple indexed inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#recursive-functions-fix">Recursive functions: fix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#top-level-recursive-functions">Top-level recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#theory-of-inductive-definitions">Theory of inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/coinductive.html">Coinductive types and corecursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#coinductive-types">Coinductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/coinductive.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#co-recursive-functions-cofix">Co-recursive functions: cofix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#top-level-definitions-of-corecursive-functions">Top-level definitions of corecursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sections.html">Sections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/sections.html#typing-rules-used-at-the-end-of-a-section">Typing rules used at the end of a section</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/modules.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#using-modules">Using modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/modules.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#typing-modules">Typing Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#controlling-the-scope-of-commands-with-locality-attributes">Controlling the scope of commands with locality attributes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/primitive.html">Primitive objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-arrays">Primitive Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#specifying-cumulativity">Specifying cumulativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#printing-universes">Printing universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#definitional-uip">Definitional UIP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/sprop.html#non-termination-with-uip">Non Termination with UIP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#lack-of-tactic-support">Lack of tactic support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/evars.html">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#e-tactics-that-can-create-existential-variables">e* tactics that can create existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#automatic-resolution-of-existential-variables">Automatic resolution of existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#explicit-display-of-existential-instances-for-pretty-printing">Explicit display of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments">Maximal and non-maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/match.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#conventions-about-unused-pattern-matching-variables">Conventions about unused pattern-matching variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and notation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#use-of-notations-for-printing">Use of notations for printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#enabling-and-disabling-notations">Enabling and disabling notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax">Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes">Notation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes-used-in-the-standard-library-of-coq">Notation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numbers-and-strings">Numbers and strings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#number-notations">Number notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/arguments-command.html">Setting properties of a function's arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#manual-declaration-of-implicit-arguments">Manual declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#binding-arguments-to-scopes">Binding arguments to scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#effects-of-arguments-on-unfolding">Effects of <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code> on unfolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercion-classes">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#id1">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#reversible-coercions">Reversible Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#id2">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#typeclass-and-instance-declarations">Typeclass and instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#binding-typeclasses">Binding typeclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#command-summary">Command summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/canonical.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#declaration-of-canonical-structures">Declaration of canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#load-paths">Load paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#extra-dependencies">Extra Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Proofs</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../proofs/writing-proofs/index.html">Basic proof writing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html">Proof mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-state">Proof State</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#entering-and-exiting-proof-mode">Entering and exiting proof mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-modes">Proof modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#managing-goals">Managing goals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#focusing-goals">Focusing goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#shelving-goals">Shelving goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#reordering-goals">Reordering goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proving-a-subgoal-as-a-separate-lemma-abstract">Proving a subgoal as a separate lemma: abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-diffs-are-calculated">How diffs are calculated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#show-proof-differences">&quot;Show Proof&quot; differences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-proof-mode">Controlling proof mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reserved-keywords">Reserved keywords</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-clauses">Occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/equality.html">Reasoning with equalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#tactics-for-simple-equalities">Tactics for simple equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-leibniz-and-setoid-equality">Rewriting with Leibniz and setoid equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-definitional-equality">Rewriting with definitional equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#applying-conversion-rules">Applying conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#fast-reduction-tactics-vm-compute-and-native-compute">Fast reduction tactics: vm_compute and native_compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#computing-in-a-term-eval-and-eval">Computing in a term: eval and Eval</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#controlling-reduction-strategies-and-the-conversion-algorithm">Controlling reduction strategies and the conversion algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html">Reasoning with inductive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#applying-constructors">Applying constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#case-analysis">Case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#induction">Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#equality-of-inductive-types">Equality of inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#helper-tactics">Helper tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#examples-of-dependent-destruction-dependent-induction">Examples of <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> / <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#a-larger-example">A larger example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#gallina-extensions">Gallina extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/automatic-tactics/index.html">Automatic solvers and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/logic.html">Solvers for logic and equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html">Micromega: solvers for arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html">ring and field: solvers for polynomial and rational equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: a solver for equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/auto.html">Programmable proof search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases">Hint databases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hint-databases">Creating hint databases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hints">Creating Hints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-locality">Hint locality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations">Rewriting and nonreflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonsymmetric-relations">Rewriting and nonsymmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-with-type-valued-relations">Rewriting with <code class="docutils literal notranslate"><span class="pre">Type</span></code> valued relations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#declaring-rewrite-relations">Declaring rewrite relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/creating-tactics/index.html">Creating new tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ltac.html">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#values">Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#syntactic-values">Syntactic values</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#substitution">Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#local-definitions-let">Local definitions: let</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#function-construction-and-application">Function construction and application</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#tactics-in-terms">Tactics in terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#processing-multiple-goals">Processing multiple goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#branching-and-backtracking">Branching and backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#sequence">Sequence: ;</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#do-loop">Do loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#catching-errors-try">Catching errors: try</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#conditional-branching-tryif">Conditional branching: tryif</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#branching-with-backtracking">Branching with backtracking: +</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#local-application-of-tactics">Local application of tactics: [&gt; ... ]</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#first-tactic-to-succeed">First tactic to succeed</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#first-tactic-to-make-progress">First tactic to make progress: ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#detecting-progress">Detecting progress</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#success-and-failure">Success and failure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-success-assert-succeeds">Checking for success: assert_succeeds</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-failure-assert-fails">Checking for failure: assert_fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#soft-cut-once">Soft cut: once</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-a-single-success-exactly-once">Checking for a single success: exactly_once</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#manipulating-values">Manipulating values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#pattern-matching-on-terms-match">Pattern matching on terms: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#pattern-matching-on-goals-and-hypotheses-match-goal">Pattern matching on goals and hypotheses: match goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#computing-in-a-term-eval">Computing in a term: eval</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#getting-the-type-of-a-term">Getting the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#manipulating-untyped-terms-type-term">Manipulating untyped terms: type_term</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#counting-goals-numgoals">Counting goals: numgoals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#testing-boolean-expressions-guard">Testing boolean expressions: guard</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-properties-of-terms">Checking properties of terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing">Timing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timing-a-tactic-that-evaluates-to-a-term-time-constr">Timing a tactic that evaluates to a term: time_constr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#print-identity-tactic-idtac">Print/identity tactic: idtac</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#defining-ltac-symbols">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#tracing-execution">Tracing execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-definitions">Ltac2 Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#printing-ltac2-tactics">Printing Ltac2 tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#quotations">Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-goals">Match over goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-on-values">Match on values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#defining-tactics">Defining tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntactic-classes">Syntactic classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html">The Coq library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-prelude">The prelude</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between Coq and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/writing.html">Writing Coq libraries and plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/writing.html#deprecating-library-objects-or-tactics">Deprecating library objects or tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html">Building Coq Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coq-configuration-basics">Coq configuration basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installing-coq-and-coq-packages-with-opam">Installing Coq and Coq packages with opam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#setup-for-working-on-your-own-projects">Setup for working on your own projects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-project-with-coqproject-overview">Building a project with _CoqProject (overview)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#logical-paths-and-the-load-path">Logical paths and the load path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#modifying-multiple-interdependent-projects-at-the-same-time">Modifying multiple interdependent projects at the same time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installed-and-uninstalled-packages">Installed and uninstalled packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#upgrading-to-a-new-version-of-coq">Upgrading to a new version of Coq</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile-details">Building a Coq project with coq_makefile (details)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a Coq project with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coqdep-computing-module-dependencies">coqdep: Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#split-compilation-of-native-computation-files">Split compilation of native computation files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html">Coq commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#command-parameters">Command parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#coqrc-start-up-script"><code class="docutils literal notranslate"><span class="pre">coqrc</span></code> start up script</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#environment-variables">Environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/tools/coqdoc.html">Documenting Coq files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#coq-material-inside-documentation">Coq material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html">CoqIDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#running-coq-scripts">Running Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#asynchronous-mode">Asynchronous mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#commands-and-templates">Commands and templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#preferences">Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#key-bindings">Key bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#debugger">Debugger</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#breakpoints">Breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#call-stack-and-variables">Call Stack and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#supported-use-cases">Supported use cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id3">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-18">Version 8.18</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-18-0">Changes in 8.18.0</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-17">Version 8.17</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id141">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-0">Changes in 8.17.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-1">Changes in 8.17.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-16">Version 8.16</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id295">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-0">Changes in 8.16.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-1">Changes in 8.16.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-15">Version 8.15</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id458">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-0">Changes in 8.15.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-1">Changes in 8.15.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-2">Changes in 8.15.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-14">Version 8.14</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id686">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-0">Changes in 8.14.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-1">Changes in 8.14.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-13">Version 8.13</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id882">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-beta1">Changes in 8.13+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-0">Changes in 8.13.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-1">Changes in 8.13.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-2">Changes in 8.13.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-12">Version 8.12</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1046">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-beta1">Changes in 8.12+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-0">Changes in 8.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-1">Changes in 8.12.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-2">Changes in 8.12.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1352">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-2">Changes in 8.11.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1490">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1637">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1639">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1640">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1641">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1642">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1643">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1644">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1646">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1647">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1648">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1649">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1650">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1651">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-attrindex.html">Attribute index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../genindex.html">General index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../proofs/writing-proofs/index.html">Basic proof writing</a> &raquo;</li>
      <li>Tactics</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/tactics.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<section id="tactics">
<span id="id1"></span><h1>Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h1>
<p>Tactics specify how to transform the <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-proof-state"><span class="xref std std-term">proof state</span></a> of an
incomplete proof to eventually generate a complete proof.</p>
<p>Proofs can be developed in two basic ways: In <span class="term-defn"><span class="target" id="term-forward-reasoning"></span>forward reasoning</span>,
the proof begins by proving simple statements that are then combined to prove the
theorem statement as the last step of the proof. With forward reasoning,
for example,
the proof of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code> would begin with proofs of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, which are
then used to prove <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code>.  Forward reasoning is probably the most common
approach in human-generated proofs.</p>
<p>In <span class="term-defn"><span class="target" id="term-backward-reasoning"></span>backward reasoning</span>, the proof begins with the theorem statement
as the goal, which is then gradually transformed until every subgoal generated
along the way has been proven.  In this case, the proof of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code> begins
with that formula as the goal.  This can be transformed into two subgoals,
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, followed by the proofs of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>.  Coq and its tactics
primarily use backward reasoning.</p>
<p>A tactic may fully prove a goal, in which case the goal is removed
from the proof state.
More commonly, a tactic replaces a goal with one or more <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-subgoal"><span class="xref std std-term">subgoals</span></a>.
(We say that a tactic reduces a goal to its subgoals.)</p>
<p>Most tactics require specific elements or preconditions to reduce a goal;
they display error messages if they can't be applied to the goal.
A few tactics, such as <a class="reference internal" href="../proofs/automatic-tactics/auto.html#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>, don't fail even if the proof state
is unchanged.</p>
<p>Goals are identified by number. The current goal is number
1. Tactics are applied to the current goal by default.  (The
default can be changed with the <a class="reference internal" href="#coq:opt.Default-Goal-Selector" title="Default Goal Selector"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Default</span> <span class="pre">Goal</span> <span class="pre">Selector</span></code></a>
option.)  They can
be applied to another goal or to multiple goals with a
<a class="reference internal" href="ltac.html#goal-selectors"><span class="std std-ref">goal selector</span></a> such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">2:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code>.</p>
<p>This chapter describes many of the most common built-in tactics.
Built-in tactics can be combined to form tactic expressions, which are
described in the <a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">Ltac</span></a> chapter.  Since tactic expressions can
be used anywhere that a built-in tactic can be used, &quot;tactic&quot; may
refer to both built-in tactics and tactic expressions.</p>
<section id="common-elements-of-tactics">
<h2>Common elements of tactics<a class="headerlink" href="#common-elements-of-tactics" title="Permalink to this headline">¶</a></h2>
<section id="reserved-keywords">
<h3>Reserved keywords<a class="headerlink" href="#reserved-keywords" title="Permalink to this headline">¶</a></h3>
<p>The tactics described in this chapter reserve the following keywords:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>by using
</pre></div>
</div>
<p>Thus, these keywords cannot be used as identifiers. It also declares
the following character sequences as tokens:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>** [= |-
</pre></div>
</div>
</section>
<section id="invocation-of-tactics">
<span id="id2"></span><h3>Invocation of tactics<a class="headerlink" href="#invocation-of-tactics" title="Permalink to this headline">¶</a></h3>
<p>Tactics may be preceded by a
goal selector (see Section <a class="reference internal" href="ltac.html#goal-selectors"><span class="std std-ref">Goal selectors</span></a>). If no selector is
specified, the default selector is used.</p>
<blockquote id="tactic-invocation-grammar">
<div><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic_invocation"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tactic_invocation"><span class="hole">tactic_invocation</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="ltac.html#grammar-token-toplevel_selector"><span class="hole">toplevel_selector</span></a> <span><span>:</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a><span><span>.</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span></div></blockquote>
<dl class="coq opt">
<dt class="sig sig-object coq" id="coq:opt.Default-Goal-Selector">
<em class="property"><span class="sigannot"><span class="pre">Option</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Default</span></span></span> <span><span><span class="pre">Goal</span></span></span> <span><span><span class="pre">Selector</span></span></span> <span><span><span class="pre">&quot;</span></span></span><a class="reference internal" href="ltac.html#grammar-token-toplevel_selector"><span class="hole"><span class="pre">toplevel_selector</span></span></a><span><span><span class="pre">&quot;</span></span></span></span></span><a class="headerlink" href="#coq:opt.Default-Goal-Selector" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../language/core/basic.html#term-option"><span class="xref std std-term">option</span></a> controls the default selector, used when no selector is
specified when applying a tactic. The initial value is 1, hence the
tactics are, by default, applied to the first goal.</p>
<p>Using value <code class="docutils literal notranslate"><span class="pre">all</span></code> will make it so that tactics are, by default,
applied to every goal simultaneously. Then, to apply a tactic tac
to the first goal only, you can write <code class="docutils literal notranslate"><span class="pre">1:tac</span></code>.</p>
<p>Using value <code class="docutils literal notranslate"><span class="pre">!</span></code> enforces that all tactics are used either on a
single focused goal or with a local selector (’’strict focusing
mode’’).</p>
<p>Although other selectors are available, only <code class="docutils literal notranslate"><span class="pre">all</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code> or a
single natural number are valid default goal selectors.</p>
</dd></dl>

</section>
<section id="bindings">
<span id="id3"></span><h3>Bindings<a class="headerlink" href="#bindings" title="Permalink to this headline">¶</a></h3>
<p>Tactics that take a term as an argument may also accept <a class="reference internal" href="#grammar-token-bindings"><code class="xref std std-token docutils literal notranslate"><span class="pre">bindings</span></code></a> to
specify the values to assign unbound variables in a term.
Bindings can be given by position or name.  Generally these appear in the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>, depending on the tactic.</p>
<blockquote>
<div><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-one_term_with_bindings"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole">one_term_with_bindings</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-bindings"><span class="hole">bindings</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-bindings"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-bindings"><span class="hole">bindings</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>(</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span></div></blockquote>
<ul>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> — bindings for variables in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
are typically determined by unifying <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> with a tactic-dependent part
of the context, with any remaining unbound variables provided by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> — binds free variables in the left-to-right order of their first
appearance in the relevant term.</p>
<p>For some tactics, bindings for all free variables
must be provided, such as for <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>
and <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>.  Other tactics automatically generate some or all
of the bindings from the conclusion or a hypothesis, such as <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a> and its variants.  In this case, only instances
for the <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a> that are not bound in
the conclusion of the relevant term are required (and permitted).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> —  binds variables by name (if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is given), or
by unifying with the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th <a class="reference internal" href="../language/core/assumptions.html#term-premise"><span class="xref std std-term">premise</span></a> of the relevant term
(if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> is given).</p></li>
</ul>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-such-binder">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">such</span></span></span> <span><span><span class="pre">binder.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-such-binder" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> is 0 or more than the number of unbound variables.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-such-bound-variable-‘ident’-(no-bound-variables-at-all-in-the-expression)">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">such</span></span></span> <span><span><span class="pre">bound</span></span></span> <span><span><span class="pre">variable</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">(no</span></span></span> <span><span><span class="pre">bound</span></span></span> <span><span><span class="pre">variables</span></span></span> <span><span><span class="pre">at</span></span></span> <span><span><span class="pre">all</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">expression).</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-such-bound-variable-‘ident’-(no-bound-variables-at-all-in-the-expression)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-such-bound-variable-‘ident’-(possible-names-are:-‘ident’-...)">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">such</span></span></span> <span><span><span class="pre">bound</span></span></span> <span><span><span class="pre">variable</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">(possible</span></span></span> <span><span><span class="pre">names</span></span></span> <span><span><span class="pre">are:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a> <span><span><span class="pre">...).</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-such-bound-variable-‘ident’-(possible-names-are:-‘ident’-...)" title="Permalink to this definition">¶</a></dt>
<dd><p>The specified binder name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> is not used in the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a> <span><span><span class="pre">...</span></span></span></span></code> lists all the valid binder names.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-the-right-number-of-missing-arguments-(expected-‘natural’)">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">right</span></span></span> <span><span><span class="pre">number</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">missing</span></span></span> <span><span><span class="pre">arguments</span></span></span> <span><span><span class="pre">(expected</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a><span><span><span class="pre">).</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-the-right-number-of-missing-arguments-(expected-‘natural’)" title="Permalink to this definition">¶</a></dt>
<dd><p>Generated when the first form of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> doesn't have the
expected number of arguments.</p>
</dd></dl>

</section>
<section id="intro-patterns">
<span id="intropatterns"></span><h3>Intro patterns<a class="headerlink" href="#intro-patterns" title="Permalink to this headline">¶</a></h3>
<p>Intro patterns let you specify the name to assign to variables and hypotheses
introduced by tactics.  They also let you split an introduced hypothesis into
multiple hypotheses or subgoals.  Common tactics that accept intro patterns
include <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a>, <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-intropattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole">intropattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>**</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole">simple_intropattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simple_intropattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole">simple_intropattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern_closed"><span class="hole">simple_intropattern_closed</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>%</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term0"><span class="hole">term0</span></a></span><span class="notation-sup">*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simple_intropattern_closed"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern_closed"><span class="hole">simple_intropattern_closed</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole">naming_intropattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-or_and_intropattern"><span class="hole">or_and_intropattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-equality_intropattern"><span class="hole">equality_intropattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-naming_intropattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole">naming_intropattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>?</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-or_and_intropattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-or_and_intropattern"><span class="hole">or_and_intropattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole">intropattern</span></a></span><span class="notation-sup">*</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole">simple_intropattern</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole">simple_intropattern</span></a></span><span class="notation-sup">*</span><span class="notation-sub">&amp;</span></span> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-equality_intropattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-equality_intropattern"><span class="hole">equality_intropattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>-&gt;</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&lt;-</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>[=</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole">intropattern</span></a></span><span class="notation-sup">*</span></span> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Note that the intro pattern syntax varies between tactics.
Most tactics use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span></code> in the grammar.
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.edestruct" title="edestruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">edestruct</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>,
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.einduction" title="einduction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einduction</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.ecase" title="ecase"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ecase</span></code></a> and the various
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span></code>, while
<a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and <a class="reference internal" href="#coq:tacn.eintros" title="eintros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eintros</span></code></a> use <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.
The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">eqn:</span></span></span></span></code> construct in various tactics uses <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span></code>.</p>
<p><strong>Naming patterns</strong></p>
<p>Use these elementary patterns to specify a name:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> — use the specified name</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span></span></code> — let Coq generate a fresh name</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> — generate a name that begins with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code> — discard the matched part (unless it is required for another
hypothesis)</p></li>
<li><p>if a disjunction pattern omits a name, such as <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">[|</span></span><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>, Coq will choose a name</p></li>
</ul>
<p><strong>Splitting patterns</strong></p>
<p>The most common splitting patterns are:</p>
<ul class="simple">
<li><p>split a hypothesis in the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> into two
hypotheses <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">B</span></span></code> using the pattern <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">)</span></span></code> or
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">)</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">H1</span></span> <span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>.
<a class="reference internal" href="#intropattern-conj-ex"><span class="std std-ref">Example</span></a>.  This also works on <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">&lt;-&gt;</span></span></span> <span><span><span class="pre">B</span></span></span></span></code>, which
is just a notation representing <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(A</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">B)</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">(B</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">A)</span></span></span></span></code>.</p></li>
<li><p>split a hypothesis in the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code> into two
subgoals using the pattern <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">[</span></span><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">|</span></span><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">]</span></span></code>.  The first subgoal will have the hypothesis
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span></code> and the second subgoal will have the hypothesis <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">B</span></span></code>.
<a class="reference internal" href="#intropattern-disj-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p>split a hypothesis in either of the forms <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code> using the pattern <code class="code Coq docutils literal notranslate"><span class="name builtin pseudo"><span class="pre">[]</span></span></code>.</p></li>
</ul>
<p>Patterns can be nested: <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[[Ha</span></span></span><span class="pre">|</span><span><span><span class="pre">Hb]</span></span></span> <span><span><span class="pre">H]</span></span></span></span></code> can be used to split <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(A</span></span></span> <span><span><span class="pre">\/</span></span></span> <span><span><span class="pre">B)</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">C</span></span></span></span></code>.</p>
<p>Note that there is no equivalent to intro patterns for goals.  For a goal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span></code>,
use the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a> tactic to replace the current goal with subgoals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>.
For a goal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">B</span></span></code>, use <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> to replace the current goal with <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>, or
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a> to replace the current goal with <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> ) — matches
a product over an inductive type with a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor</span></a>.
If the number of patterns
equals the number of constructor arguments, then it applies the patterns only to
the arguments, and
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span><span><span class="pre">)</span></span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span><span class="pre">]</span></span></span></span></code>.
If the number of patterns equals the number of constructor arguments plus the number
of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let-ins</span></span></span></span></code>, the patterns are applied to the arguments and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let-in</span></span></span></span></code> variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">&amp;</span></span></span> <span><span><span class="pre">)</span></span></span></span></code> — matches a right-hand nested term that consists
of one or more nested binary inductive types such as <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a1</span></span> <span class="name"><span class="pre">OP1</span></span> <span class="name"><span class="pre">a2</span></span> <span class="name"><span class="pre">OP2</span></span> <span class="name builtin pseudo"><span class="pre">…</span></span></code>
(where the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">OPn</span></span></code> are right-associative).
(If the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">OPn</span></span></code> are left-associative, additional parentheses will be needed to make the
term right-hand nested, such as <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a1</span></span> <span class="name"><span class="pre">OP1</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">a2</span></span> <span class="name"><span class="pre">OP2</span></span> <span class="name builtin pseudo"><span class="pre">…</span></span><span class="operator"><span class="pre">)</span></span></code>.)
The splitting pattern can have more than 2 names, for example <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">H1</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H2</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">H3</span></span><span class="operator"><span class="pre">)</span></span></code>
matches <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">C</span></span></code>.
The inductive types must have a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor with two parameters</span></a>.
<a class="reference internal" href="#intropattern-ampersand-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> — splits an inductive type that has
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">multiple constructors</span></a>
such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">\/</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> into multiple subgoals.  The number of <a class="reference internal" href="#grammar-token-intropattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">intropattern</span></code></a>s
must be the same as the number of constructors for the matched part.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> — splits an inductive type that has a
<a class="reference internal" href="#intropattern-cons-note"><span class="std std-ref">single constructor with multiple parameters</span></a>
such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> into multiple hypotheses.  Use <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[H1</span></span></span> <span><span><span class="pre">[H2</span></span></span> <span><span><span class="pre">H3]]</span></span></span></span></code> to match <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">B</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">C</span></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[]</span></span></span></span></code> — splits an inductive type:  If the inductive
type has multiple constructors, such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">\/</span></span></span> <span><span><span class="pre">B</span></span></span></span></code>,
create one subgoal for each constructor.  If the inductive type has a single constructor with
multiple parameters, such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">B</span></span></span></span></code>, split it into multiple hypotheses.</p></li>
</ul>
<p><strong>Equality patterns</strong></p>
<p>These patterns can be used when the hypothesis is an equality:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">-&gt;</span></span></span></span></code> — replaces the right-hand side of the hypothesis with the left-hand
side of the hypothesis in the conclusion of the goal; the hypothesis is
cleared; if the left-hand side of the hypothesis is a variable, it is
substituted everywhere in the context and the variable is removed.
<a class="reference internal" href="#intropattern-rarrow-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&lt;-</span></span></span></span></code> — similar to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">-&gt;</span></span></span></span></code>, but replaces the left-hand side of the hypothesis
with the right-hand side of the hypothesis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[=</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> — If the product is over an equality type,
applies either <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> or <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>.
If <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> is applicable, the intropattern
is used on the hypotheses generated by <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a>.  If the
number of patterns is smaller than the number of hypotheses generated, the
pattern <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span></span></code> is used to complete the list.
<a class="reference internal" href="#intropattern-inj-discr-ex"><span class="std std-ref">Example</span></a></p></li>
</ul>
<p><strong>Other patterns</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">*</span></span></span></span></code> — introduces one or more <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a>
from the result until there are no more.
<a class="reference internal" href="#intropattern-star-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">**</span></span></span></span></code> — introduces one or more <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent</span></a>
or <a class="reference internal" href="../language/core/assumptions.html#term-non-dependent-premise"><span class="xref std std-term">non-dependent premises</span></a> from the result
until there are no more premises.  <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">intros</span></span> <span class="operator"><span class="pre">**</span></span></code> is equivalent to <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">intros</span></span></code>.
<a class="reference internal" href="#intropattern-2stars-ex"><span class="std std-ref">Example</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern_closed"><span class="hole"><span class="pre">simple_intropattern_closed</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">%</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> — first applies each of the terms
with the <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic on the hypothesis to be introduced, then it uses
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern_closed"><span class="hole"><span class="pre">simple_intropattern_closed</span></span></a></span></code>.
<a class="reference internal" href="#intropattern-injection-ex"><span class="std std-ref">Example</span></a></p></li>
</ul>
<div class="admonition note" id="intropattern-cons-note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">\/</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> use infix notation to refer to the inductive
types <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">or</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">and</span></span></span></span></code>.
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">or</span></span></span></span></code> has multiple constructors (<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">or</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">introl</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">or</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">intror</span></span></span></span></code>),
while <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">and</span></span></span></span></code> has a single constructor (<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">conj</span></span></span></span></code>) with multiple parameters
(<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">B</span></span></span></span></code>).
These are defined in <code class="docutils literal notranslate"><span class="pre">theories/Init/Logic.v</span></code>.  The &quot;where&quot; clauses define the
infix notation for &quot;or&quot; and &quot;and&quot;.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
  | </span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span>
  | </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span>
</span><span class="coqdoc-keyword">where</span><span> &quot;A \/ B&quot; := (</span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>) : </span><span class="coqdoc-var">type_scope</span><span>.</span><span>
</span><span>
</span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">and</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
  </span><span class="coqdoc-var">conj</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span>
</span><span class="coqdoc-keyword">where</span><span> &quot;A /\ B&quot; := (</span><span class="coqdoc-var">and</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>) : </span><span class="coqdoc-var">type_scope</span><span>.</span><span>
</span></span></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">p</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> is not always equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">p;</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">p</span></span></span></span></code>
if some of the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">p</span></span></span></span></code> are <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code>.  In the first form, all erasures are done
at once, while they're done sequentially for each tactic in the second form.
If the second matched term depends on the first matched term and the pattern
for both is <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code> (i.e., both will be erased), the first <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span></span></code> in the second
form will fail because the second matched term still has the dependency on the first.</p>
</div>
<p>Examples:</p>
<blockquote id="intropattern-conj-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: intro pattern for /\</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>), (</span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> /\</span><span> B</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> /\</span><span> B
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">as</span><span> (</span><span class="coqdoc-var">HA</span><span> &amp; </span><span class="coqdoc-var">HB</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HA : A
  HB : B
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-disj-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: intro pattern for \/</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>), (</span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> \/</span><span> B</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> \/</span><span> B
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">as</span><span> [</span><span class="coqdoc-var">HA</span><span>|</span><span class="coqdoc-var">HB</span><span>]. </span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">swap</span><span> 1 2.</span><span>
</span></dt><dd><span>2 goals
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HA : A
  ============================
  True

goal 2 is:
 True

2 goals
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HB : B
  ============================
  True

goal 2 is:
 True
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-rarrow-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: -&gt; intro pattern</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>), (</span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>) -&gt; (</span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>) -&gt; (</span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y z : nat, x</span><span> =</span><span> y</span><span> -&gt;</span><span> y</span><span> =</span><span> z</span><span> -&gt;</span><span> x</span><span> =</span><span> z
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> * </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  H : x</span><span> =</span><span> y
  ============================
  y</span><span> =</span><span> z</span><span> -&gt;</span><span> x</span><span> =</span><span> z
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> -&gt;.</span><span>
</span></dt><dd><span>1 goal
  
  x, z : nat
  H : x</span><span> =</span><span> z
  ============================
  x</span><span> =</span><span> z
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-inj-discr-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: [=] intro pattern</p>
<p>The first <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[=]</span></span></span></span></code> uses <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> to strip <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(S</span></span></span> <span><span><span class="pre">…)</span></span></span></span></code> from
both sides of the matched equality.  The second uses <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> on
the contradiction <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">1</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">2</span></span></span></span></code> (internally represented as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(S</span></span></span> <span><span><span class="pre">O)</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">(S</span></span></span> <span><span><span class="pre">(S</span></span></span> <span><span><span class="pre">O))</span></span></span></span></code>)
to complete the goal.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>),  (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) = (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>) -&gt; (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>)=(</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>)) -&gt; </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n m : nat, S n</span><span> =</span><span> S m</span><span> -&gt;</span><span> 1</span><span> =</span><span> 2</span><span> -&gt;</span><span> False
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> *.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  ============================
  S n</span><span> =</span><span> S m</span><span> -&gt;</span><span> 1</span><span> =</span><span> 2</span><span> -&gt;</span><span> False
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> [= </span><span class="coqdoc-var">H</span><span>].</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : n</span><span> =</span><span> m
  ============================
  1</span><span> =</span><span> 2</span><span> -&gt;</span><span> False
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> [=].</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-ampersand-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: (A &amp; B &amp; …) intro pattern</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Parameters</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">C</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
B is declared
C is declared
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">A</span><span> /\ (</span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">x</span><span> /\ </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  A</span><span> /\</span><span> (</span><span>exists</span><span> x : nat</span><span>,</span><span> B x</span><span> /\</span><span> C)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> (</span><span class="coqdoc-var">a</span><span> &amp; </span><span class="coqdoc-var">x</span><span> &amp; </span><span class="coqdoc-var">b</span><span> &amp; </span><span class="coqdoc-var">c</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  a : A
  x : nat
  b : B x
  c : C
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-star-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: * intro pattern</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>), </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> B
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> *.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  ============================
  A</span><span> -&gt;</span><span> B
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-2stars-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: ** pattern (&quot;intros **&quot; is equivalent to &quot;intros&quot;)</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>), </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> B
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> **.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A
  ============================
  B
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: compound intro pattern</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">C</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> \/</span><span> B</span><span> /\</span><span> C</span><span> -&gt;</span><span> (A</span><span> -&gt;</span><span> C)</span><span> -&gt;</span><span> C
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> * [</span><span class="coqdoc-var">a</span><span> | (</span><span class="coqdoc-var">_</span><span>,</span><span class="coqdoc-var">c</span><span>)] </span><span class="coqdoc-var">f</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  a : A
  f : A</span><span> -&gt;</span><span> C
  ============================
  C

goal 2 is:
 C
</span></dd>
<dt><span></span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">swap</span><span> 1 2.</span><span>
</span></dt><dd><span>2 goals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  c : C
  f : A</span><span> -&gt;</span><span> C
  ============================
  C

goal 2 is:
 C
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<blockquote id="intropattern-injection-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: combined intro pattern using [=] -&gt; and %</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Lists.List</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">IntroPatterns</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variables</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">xs</span><span> </span><span class="coqdoc-var">ys</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
xs is declared
ys is declared
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Example</span><span> </span><span class="coqdoc-var">ThreeIntroPatternsCombined</span><span> :</span><span>
</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">ys</span><span>) = 1 -&gt; </span><span class="coqdoc-var">xs</span><span> ++ </span><span class="coqdoc-var">ys</span><span> = </span><span class="coqdoc-var">xs</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  xs, ys : list A
  ============================
  S (length ys)</span><span> =</span><span> 1</span><span> -&gt;</span><span> xs</span><span> ++</span><span> ys</span><span> =</span><span> xs
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> [=-&gt;%</span><span class="coqdoc-var">length_zero_iff_nil</span><span>].</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  xs : list A
  ============================
  xs</span><span> ++</span><span> nil</span><span> =</span><span> xs
</span></dd>
</dl>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span></code> would add <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">ys</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">1</span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span> <span class="pre">[=]</span></code> would additionally apply <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> to yield <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H0</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">ys</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">0</span></span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intros</span> <span class="pre">[=-&gt;%length_zero_iff_nil]</span></code> applies the theorem, making H the equality <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">nil</span></span></code>,
which is then applied as for <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code>.</p></li>
</ul>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">length_zero_iff_nil</span><span> (</span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>):</span><span>
   </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span> = 0 &lt;-&gt; </span><span class="coqdoc-var">l</span><span>=</span><span class="coqdoc-var">nil</span><span>.</span><span>
</span></span></div>
<p>The example is based on <a class="reference external" href="https://github.com/tchajed/coq-tricks/blob/8e6efe4971ed828ac8bdb5512c1f615d7d62691e/src/IntroPatterns.v">Tej Chajed's coq-tricks</a></p>
</div>
</div></blockquote>
</section>
<section id="occurrence-clauses">
<span id="occurrenceclauses"></span><h3>Occurrence clauses<a class="headerlink" href="#occurrence-clauses" title="Permalink to this headline">¶</a></h3>
<p>An <span class="term-defn"><span class="target" id="term-occurrence"></span>occurrence</span> is a subterm of a goal or hypothesis that
matches a pattern provided by a tactic.  Occurrence clauses
select a subset of the ocurrences in a goal and/or in
one or more of its hypotheses.</p>
<blockquote>
<div><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-occurrences"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole">occurrences</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>at</span></span> <a class="reference internal" href="#grammar-token-occs_nums"><span class="hole">occs_nums</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simple_occurrences"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simple_occurrences"><span class="hole">simple_occurrences</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole">occurrences</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-occs_nums"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-occs_nums"><span class="hole">occs_nums</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>-</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-nat_or_var"><span class="hole">nat_or_var</span></a></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-nat_or_var"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-nat_or_var"><span class="hole">nat_or_var</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-goal_occurrences"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-hyp_occs"><span class="hole">hyp_occs</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|-</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole">concl_occs</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>*</span></span> <span><span>|-</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole">concl_occs</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>|-</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole">concl_occs</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole">concl_occs</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-hyp_occs"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-hyp_occs"><span class="hole">hyp_occs</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-hypident"><span class="hole">hypident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>at</span></span> <a class="reference internal" href="#grammar-token-occs_nums"><span class="hole">occs_nums</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-hypident"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-hypident"><span class="hole">hypident</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span><span>type</span></span> <span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span><span>value</span></span> <span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-concl_occs"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole">concl_occs</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>*</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>at</span></span> <a class="reference internal" href="#grammar-token-occs_nums"><span class="hole">occs_nums</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code></dt><dd><p>The first form of <a class="reference internal" href="#grammar-token-occurrences"><code class="xref std std-token docutils literal notranslate"><span class="pre">occurrences</span></code></a> selects occurrences in
the conclusion of the goal.  The second form can select occurrences
in the goal conclusion and in one or more hypotheses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_occurrences"><span class="hole"><span class="pre">simple_occurrences</span></span></a></span></code></dt><dd><p>A semantically restricted form of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code> that doesn't allow the
<code class="docutils literal notranslate"><span class="pre">at</span></code> clause anywhere within it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">-</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>Selects the specified occurrences within a single goal or hypothesis.
Occurrences are numbered starting with 1 following a depth-first traversal
of the term's expression, including occurrences in
<a class="reference internal" href="../language/extensions/implicit-arguments.html#implicitarguments"><span class="std std-ref">implicit arguments</span></a>
and <a class="reference internal" href="../addendum/implicit-coercions.html#coercions"><span class="std std-ref">coercions</span></a> that are not displayed by default.
(Set the <a class="reference internal" href="vernacular-commands.html#coq:flag.Printing-All" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag to show those in the printed term.)</p>
<p>For example, when matching the pattern <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">+</span> <span class="pre">_</span></code> in the term <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c</span></code>,
occurrence 1 is <code class="docutils literal notranslate"><span class="pre">(…)</span> <span class="pre">+</span> <span class="pre">c</span></code> and
occurrence 2 is <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code>.  When matching that pattern with term <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code>,
occurrence 1 is <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(…)</span></code> and occurrence 2 is <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></code>.</p>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">-</span></code> includes all occurrences <em>except</em> the ones listed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-hyp_occs"><span class="hole"><span class="pre">hyp_occs</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">|-</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole"><span class="pre">concl_occs</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Selects occurrences in the specified hypotheses and the
specified occurrences in the conclusion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">*</span></span></span> <span><span><span class="pre">|-</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole"><span class="pre">concl_occs</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Selects all occurrences in all hypotheses and the
specified occurrences in the conclusion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">|-</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole"><span class="pre">concl_occs</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Selects the specified occurrences in the conclusion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a> <span><span><span class="pre">::=</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole"><span class="pre">concl_occs</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Selects all occurrences in all hypotheses and in the specified occurrences
in the conclusion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypident"><span class="hole"><span class="pre">hypident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">at</span></span></span> <a class="reference internal" href="#grammar-token-occs_nums"><span class="hole"><span class="pre">occs_nums</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Omiting <a class="reference internal" href="#grammar-token-occs_nums"><code class="xref std std-token docutils literal notranslate"><span class="pre">occs_nums</span></code></a> selects all occurrences within the hypothesis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypident"><span class="hole"><span class="pre">hypident</span></span></a> <span><span><span class="pre">::=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></dt><dd><p>Selects the hypothesis named <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">)</span></span></span></span></code></dt><dd><p>Selects the type part of the named hypothesis (e.g. <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">nat</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span> <span><span><span class="pre">value</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">)</span></span></span></span></code></dt><dd><p>Selects the value part of the named hypothesis (e.g. <code class="docutils literal notranslate"><span class="pre">:=</span> <span class="pre">1</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-concl_occs"><span class="hole"><span class="pre">concl_occs</span></span></a> <span><span><span class="pre">::=</span></span></span> <span><span><span class="pre">*</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">at</span></span></span> <a class="reference internal" href="#grammar-token-occs_nums"><span class="hole"><span class="pre">occs_nums</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Selects occurrences in the conclusion.  '*' by itself selects all occurrences.
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-occs_nums"><span class="hole"><span class="pre">occs_nums</span></span></a></span></code> selects the specified occurrences.</p>
</dd>
</dl>
<p>Use <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">*</span></code> to select all occurrences in all hypotheses and the conclusion,
which is equivalent to <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">*</span> <span class="pre">|-</span> <span class="pre">*</span></code>.  Use <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">|-</span></code> to select all occurrences
in all hypotheses.</p>
<p>When rewriting in multiple hypotheses, they must not appear in the
term to rewrite. For instance <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">H</span> <span class="pre">in</span> <span class="pre">H,H'</span></code> is an error. If
an hypothesis appears only through a hole, it will be removed from
that hole's context.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">term</span> <span class="pre">in</span> <span class="pre">*</span></code>, hypotheses on which the dependency cannot
be avoided are skipped, for instance <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">H</span> <span class="pre">in</span> <span class="pre">*</span></code> skips
rewriting in <code class="docutils literal notranslate"><span class="pre">H</span></code>. This is the case even if only one hypothesis ends
up rewritten.</p>
<p>If multiple
occurrences are given, such as in <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">at</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span></code>, the tactic
must match at least one occurrence in order to succeed.  The tactic will fail
if no occurrences match.  Occurrence numbers that are out of range (e.g.
<code class="docutils literal notranslate"><span class="pre">at</span> <span class="pre">1</span> <span class="pre">3</span></code> when there are only 2 occurrences in the hypothesis or conclusion)
are ignored.</p>
<p>Tactics that use occurrence clauses include <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>,
<a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-such-hypothesis:-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">such</span></span></span> <span><span><span class="pre">hypothesis:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-such-hypothesis:-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#managingthelocalcontext"><span class="std std-ref">Managing the local context</span></a>, <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#caseanalysisandinduction"><span class="std std-ref">Case analysis</span></a>,
<a class="reference internal" href="vernacular-commands.html#printing-constructions-full"><span class="std std-ref">Printing constructions in full</span></a>.</p>
</div>
</section>
</section>
<section id="applying-theorems">
<span id="applyingtheorems"></span><h2>Applying theorems<a class="headerlink" href="#applying-theorems" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.exact">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">exact</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Directly gives the exact proof term for the goal.
<code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">p</span></code> succeeds if and only if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> and the type of <code class="docutils literal notranslate"><span class="pre">p</span></code> are
unifiable (see <a class="reference internal" href="../language/core/conversion.html#conversion-rules"><span class="std std-ref">Conversion rules</span></a>).</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-an-exact-proof">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">exact</span></span></span> <span><span><span class="pre">proof.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-an-exact-proof" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eexact">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eexact</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.eexact" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> but can handle terms and
goals with existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.assumption">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assumption</span></span></span></span></span><a class="headerlink" href="#coq:tacn.assumption" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic looks in the local context for a hypothesis whose type is
convertible to the goal. If it is the case, the subgoal is proved.
Otherwise, it fails.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-such-assumption">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">such</span></span></span> <span><span><span class="pre">assumption.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-such-assumption" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eassumption">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eassumption</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eassumption" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a> but is able to process
goals and hypotheses with existential variables.  It can also
resolve existential variables, which <a class="reference internal" href="#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a> will not.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.refine">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">simple</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">notypeclasses</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">refine</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> but allows holes (denoted by <code class="docutils literal notranslate"><span class="pre">_</span></code>
or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><span><span><span class="pre">_</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">)</span></span></span></span></code>) in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>. <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> generates as many
subgoals as there are remaining holes in the elaborated term. Any subgoal
that occurs in other subgoals is automatically shelved, as if calling
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#coq:tacn.shelve_unifiable" title="shelve_unifiable"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">shelve_unifiable</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">simple</span></code></dt><dd><p>If specified, don't shelve any subgoals or perform beta reduction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notypeclasses</span></code></dt><dd><p>If specified, do checking without resolving typeclasses.  The generated
subgoals (shelved or not) are <em>not</em> candidates for typeclass resolution,
even if they have a typeclass type as their conclusion.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Option</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">Fail</span><span> : </span><span class="coqdoc-var">Option</span><span>
| </span><span class="coqdoc-var">Ok</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-var">Option</span><span>.</span><span>
</span></dt><dd><span>Option is defined
Option_rect is defined
Option_ind is defined
Option_rec is defined
Option_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">get</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Option</span><span>, </span><span class="coqdoc-var">x</span><span> &lt;&gt; </span><span class="coqdoc-var">Fail</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x : Option, x</span><span> &lt;&gt;</span><span> Fail</span><span> -&gt;</span><span> bool
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">refine</span><span>
    (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Option</span><span> =&gt;</span><span>
      </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">x</span><span> &lt;&gt; </span><span class="coqdoc-var">Fail</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-keyword">with</span><span>
      | </span><span class="coqdoc-var">Fail</span><span> =&gt; </span><span class="coqdoc-var">_</span><span>
      | </span><span class="coqdoc-var">Ok</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">b</span><span>
      </span><span class="coqdoc-keyword">end</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x : Option
  ============================
  Fail</span><span> &lt;&gt;</span><span> Fail</span><span> -&gt;</span><span> bool
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-var">absurd</span><span> (</span><span class="coqdoc-var">Fail</span><span> = </span><span class="coqdoc-var">Fail</span><span>); </span><span class="coqdoc-tactic">trivial</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Defined</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-infer-a-term-for-this-placeholder.-(refine)">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">infer</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">term</span></span></span> <span><span><span class="pre">for</span></span></span> <span><span><span class="pre">this</span></span></span> <span><span><span class="pre">placeholder.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-infer-a-term-for-this-placeholder.-(refine)" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a hole in the term you gave whose type cannot be inferred. Put a
cast around it.</p>
</dd></dl>

<p>Setting <a class="reference internal" href="vernacular-commands.html#coq:opt.Debug" title="Debug"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Debug</span></code></a> <code class="docutils literal notranslate"><span class="pre">&quot;unification&quot;</span></code> enables printing traces of
unification steps used during elaboration/typechecking and the
<a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic. <code class="docutils literal notranslate"><span class="pre">&quot;ho-unification&quot;</span></code> prints information
about higher order heuristics.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.apply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">apply</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.apply" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-in_hyp_as"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole">in_hyp_as</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole">as_ipat</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-as_ipat"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole">as_ipat</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>as</span></span> <a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole">simple_intropattern</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Uses unification to match the type of each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
(in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>) with the goal
(to do <a class="reference internal" href="#term-backward-reasoning"><span class="xref std std-term">backward reasoning</span></a>) or with a hypothesis (to do <a class="reference internal" href="#term-forward-reasoning"><span class="xref std std-term">forward reasoning</span></a>).
Specifying multiple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code> is equivalent to
giving each one serially, left to right, as separate <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactics.</p>
<p>The type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> contains zero or more <a class="reference internal" href="../language/core/assumptions.html#term-premise"><span class="xref std std-term">premises</span></a>
followed by a <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#conclusion-meaning-2"><span class="std std-ref">conclusion</span></a>,
i.e. it typically has the form <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="../language/core/assumptions.html#grammar-token-open_binders"><span class="hole"><span class="pre">open_binders</span></span></a> <span><span><span class="pre">,</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">premise</span></sub></span></a> <span><span><span class="pre">-&gt;</span></span></span></span><span class="notation-sup"><span class="pre">*</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">conclusion</span></sub></span></a></span></code>.
(The <code class="docutils literal notranslate"><span class="pre">forall</span></code>s may also be interleaved with the premises, but common usage is
to equivalently gather them at the beginning of the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.)
Backward reasoning with a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> whose type is, for example, <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>
replaces an as-yet unproven goal <code class="docutils literal notranslate"><span class="pre">B</span></code> with <code class="docutils literal notranslate"><span class="pre">A</span></code>.  Forward reasoning with the same
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> changes a hypothesis with type <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code>.  (Hypotheses are
considered proven propositions within the context that contains them.)</p>
<p>Unification creates a map from the variables in the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
to matching subterms of the goal or hypothesis.
The matching subterms are then substituted into the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
when generating the updated goal or hypothesis.  Unmatched premises become
new subgoals with similar substitutions.  If no match is found, the
tactic fails.</p>
<p>Setting <a class="reference internal" href="vernacular-commands.html#coq:opt.Debug" title="Debug"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Debug</span></code></a> <code class="docutils literal notranslate"><span class="pre">&quot;tactic-unification&quot;</span></code> enables printing traces of
unification steps in tactic unification. Tactic unification is used in
tactics such as <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>.</p>
<p>The goal and hypothesis cases are described separately for clarity.</p>
</dd></dl>

<blockquote id="unused1">
<div><dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (inside <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)</dt><dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is an <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, it is the name of
a theorem, lemma or hypothesis whose type is given in the
theorem statement or shown in the context.  Otherwise it is a proof term whose
type can be displayed with <a class="reference internal" href="vernacular-commands.html#coq:cmd.Check" title="Check"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Check</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.</p>
</dd>
<dt>Without <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span></code> (the goal case)</dt><dd><p>If the goal matches all of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (both premises and
the conclusion), the tactic proves the goal.
Otherwise, the tactic matches the goal against the conclusion of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
and, if possible, one or more premises (from right to left).
If the match succeeds, the tactic replaces the current goal with a subgoal for
each unmatched premise of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.  This
<a class="reference internal" href="#apply-backward"><span class="std std-ref">example</span></a> matches only the conclusion, while
this <a class="reference internal" href="#apply-backward-w-premises"><span class="std std-ref">one</span></a> also matches a premise.</p>
<p>If the conclusion of the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a> does not match the goal
<em>and</em> the conclusion is an inductive type with a single constructor,
then each premise in the constructor is recursively matched to the goal in
right-to-left order and the first match is used.  In this case, the tactic
will not match premises that would result in applying a lemma of the form
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">A,</span> <span class="pre">…</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code>.  See example <a class="reference internal" href="#apply-with-iff"><span class="std std-ref">here</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<blockquote id="apply-with-second-order-unification">
<div><blockquote>
<div><p>The goal case uses first-order unification with dependent types unless the
conclusion of the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">n</span></sub></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> to be instantiated. In the latter case,
the behavior depends on the form of the target. If the target is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Q</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">n</span></sub></span></span></code> and the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">t</span></span><sub><span class="pre">i</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">u</span></span><sub><span class="pre">i</span></sub></span></span></code> unify,
then <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> is instantiated into <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Q</span></span></span></span></code>. Otherwise, <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
tries to define <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> by abstracting over <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">n</span></sub></span></span></code> in the target.
You can use <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> to transform the target so that it
gets the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(fun</span></span></span> <span><span><span class="pre">x</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">x</span></span><sub><span class="pre">n</span></sub></span> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">Q)</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">n</span></sub></span></span></code>.  See the example
<a class="reference internal" href="#example-apply-pattern"><span class="std std-ref">here</span></a>.</p>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span></code> (the hypothesis case)</dt><dd><p>Proceeding from <em>right to left</em>, find the first premise of the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> that matches the specified hypothesis.  If a match
is found, the hypothesis is replaced with the conclusion of the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (substituting for the unified variables)
and the tactic creates a new subgoal for each unmatched premise.
See the example <a class="reference internal" href="#apply-forward"><span class="std std-ref">here</span></a>.</p>
<p>If specified, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span></code> is applied to the conclusion
of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>. In this case, the selected hypothesis
is left unchanged if its name is not reused.</p>
<p>If the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is an inductive type with a single constructor,
then each premise in the constructor is recursively matched to the conclusion
of the hypothesis in right-to-left order and the first match is used.
See example <a class="reference internal" href="#apply-with-iff"><span class="std std-ref">here</span></a>.</p>
<p>For the hypothesis case, matching is done only with first-order unification.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)</dt><dd><p>Gives explicit instantiations for variables used in the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.
There are 3 cases:</p>
<ul class="simple">
<li><p>Bindings for variables can be provided in a list of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>s
in the left-to-right order of their first appearance in the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.  For the goal case (<a class="reference internal" href="#apply-with-binding-goal"><span class="std std-ref">example</span></a>),
the list should give bindings only for variables that aren't bound by
unification.  However, in the hypothesis case
(<a class="reference internal" href="#apply-with-binding-hyp"><span class="std std-ref">example</span></a>),
the list must include bindings for <em>all</em> variables.</p></li>
<li><p>Bindings for unbound variables can be given by name with the
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> form.</p></li>
<li><p>The form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> binds additional variables by
unifying the Nth premise of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.
(Use <code class="docutils literal notranslate"><span class="pre">1</span></code> for the first premise.)</p></li>
</ul>
</dd>
</dl>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Unable-to-unify-‘one_term’-with-‘one_term’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Unable</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">unify</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Unable-to-unify-‘one_term’-with-‘one_term’" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic failed to match the conclusion of <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a>.
You can help <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> by
transforming your goal with the <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> or <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>
tactics.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Unable-to-apply-lemma-of-type-&quot;...&quot;-on-hypothesis-of-type-&quot;...&quot;">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Unable</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">apply</span></span></span> <span><span><span class="pre">lemma</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">&quot;...&quot;</span></span></span> <span><span><span class="pre">on</span></span></span> <span><span><span class="pre">hypothesis</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">&quot;...&quot;.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Unable-to-apply-lemma-of-type-"..."-on-hypothesis-of-type-"..."" title="Permalink to this definition">¶</a></dt>
<dd><p>This happens if the conclusion of <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> does not match any of
the premises of the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a>.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Unable-to-find-an-instance-for-the-variables-‘ident’…‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Unable</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">find</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">instance</span></span></span> <span><span><span class="pre">for</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">variables</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Unable-to-find-an-instance-for-the-variables-‘ident’…‘ident’" title="Permalink to this definition">¶</a></dt>
<dd><p>This occurs when some instantiations of the premises of <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a> are not deducible
from the unification. This is the case, for instance, when you want to apply a
transitivity property.  To fix this, add bindings for the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s using
to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> or use <a class="reference internal" href="#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a>.</p>
</dd></dl>

<div class="admonition note" id="apply-backward">
<p class="admonition-title">Example: Backward reasoning in the goal with <code class="docutils literal notranslate"><span class="pre">apply</span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>, (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">C</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, (A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C)</span><span> -&gt;</span><span> C
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  C
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>. </span><span class="coqdoc-comment">(* replace goal with new goals for unmatched premises of H *)</span></dt><dd><span>2 goals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  A

goal 2 is:
 B
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="apply-backward-w-premises">
<p class="admonition-title">Example: Backward reasoning in the goal with <code class="docutils literal notranslate"><span class="pre">apply</span></code> including a premise</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>, (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; (</span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, (A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C)</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  B</span><span> -&gt;</span><span> C
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>. </span><span class="coqdoc-comment">(* match on &quot;B -&gt; C&quot;, replace goal with &quot;A&quot; *)</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  A
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="apply-forward">
<p class="admonition-title">Example: Forward reasoning in hypotheses with <code class="docutils literal notranslate"><span class="pre">apply</span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">B</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, B</span><span> -&gt;</span><span> (A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H0</span><span> </span><span class="coqdoc-var">H1</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H0 : B
  H1 : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H0</span><span>. </span><span class="coqdoc-comment">(* change H0, create new goals for unmatched premises of H1 *)</span></dt><dd><span>2 goals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H0 : C
  H1 : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  True

goal 2 is:
 A
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="apply-with-binding-goal">
<p class="admonition-title">Example: Apply a theorem with a binding in a goal</p>
<p><a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> unifies the conclusion <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code> of the theorem
<code class="docutils literal notranslate"><span class="pre">le_trans</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">p,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code>
with the goal, assigning <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">*</span> <span class="pre">y</span></code> in the goal
to, repectively, <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> in theorem (backward reasoning).
The <code class="docutils literal notranslate"><span class="pre">with</span></code> clause provides the binding for <code class="docutils literal notranslate"><span class="pre">m</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">PeanoNat</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>), </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> &lt;=</span><span> y</span><span> -&gt;</span><span> x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">H0</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  H0 : x</span><span> &lt;=</span><span> y
  ============================
  x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Nat.le_trans</span><span> </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  x, y : nat
  H0 : x</span><span> &lt;=</span><span> y
  ============================
  x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> x

goal 2 is:
 y</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> y
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="apply-with-binding-hyp">
<p class="admonition-title">Example: Apply a theorem with a binding in a hypothesis</p>
<p>When applying a theorem in a hypothesis,
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> unifies the hypothesis with one of the premises
of the theorem <code class="docutils literal notranslate"><span class="pre">le_trans</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">p,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code>.
In this case, it unifies with the first premise
(<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code>) and assigns <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">*</span> <span class="pre">y</span></code> to,
respectively, <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span></code> in the theorem (forward reasoning).
The  <code class="docutils literal notranslate"><span class="pre">with</span></code> clause provides the binding for <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>In addition, <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> in a hypothesis isn't as flexible as
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> in the goal: for hypotheses, the unbound variable can be bound
by name (as shown) or values for all the variables can be given
positionally, i.e. <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">Nat.le_trans</span> <span class="pre">with</span> <span class="pre">(x</span> <span class="pre">*</span> <span class="pre">x)</span> <span class="pre">(y</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">(y</span> <span class="pre">*</span> <span class="pre">x)</span> <span class="pre">in</span> <span class="pre">H.</span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">PeanoNat</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>), </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> y</span><span> -&gt;</span><span> x</span><span> &lt;=</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  H : x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> y
  ============================
  x</span><span> &lt;=</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Nat.le_trans</span><span> </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-var">p</span><span> := </span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">x</span><span>) </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x, y : nat
  H : x</span><span> *</span><span> x</span><span> &lt;=</span><span> y</span><span> *</span><span> x
  ============================
  x</span><span> &lt;=</span><span> y

goal 2 is:
 y</span><span> *</span><span> y</span><span> &lt;=</span><span> y</span><span> *</span><span> x
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="apply-with-iff">
<p class="admonition-title">Example: Applying theorems with <code class="docutils literal notranslate"><span class="pre">&lt;-&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">&lt;-&gt;</span></span></span> <span><span><span class="pre">B</span></span></span></span></code> is defined as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(A</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">B)</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">(B</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">A)</span></span></span></span></code>.
<code class="docutils literal notranslate"><span class="pre">/\</span></code> represents an inductive type with a single constructor:
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Inductive</span></span></span> <span><span><span class="pre">and</span></span></span> <span><span><span class="pre">(C</span></span></span> <span><span><span class="pre">D:Prop)</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">Prop</span></span></span> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">conj</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">C</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">D</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">D</span></span></span> <span><span><span class="pre">/\</span></span></span> <span><span><span class="pre">C</span></span></span></span></code>.  The premises
of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">conj</span></span></span></span></code> are <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">C</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">D</span></span></span></span></code>.  The tactic uses the first matching
constructor premise in right-to-left order.</p>
<p>Theorems that use <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&lt;-&gt;</span></span></span></span></code> to state a logical equivalence behave consistently
when applied to goals and hypotheses.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">H1</span><span>: </span><span class="coqdoc-var">A</span><span> &lt;-&gt; </span><span class="coqdoc-var">B</span><span>) (</span><span class="coqdoc-var">H</span><span>: </span><span class="coqdoc-var">A</span><span>), </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> &lt;-&gt;</span><span> B</span><span> -&gt;</span><span> A</span><span> -&gt;</span><span> A
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : A</span><span> &lt;-&gt;</span><span> B
  H : A
  ============================
  A
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H1</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : A</span><span> &lt;-&gt;</span><span> B
  H : A
  ============================
  B
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : A</span><span> &lt;-&gt;</span><span> B
  H : B
  ============================
  B
</span></dd>
</dl>
</div>
</div>
<div class="admonition note" id="example-apply-pattern">
<p class="admonition-title">Example: Special case of second-order unification in apply</p>
<p>Shows the use of the special case second-order unification described
<a class="reference internal" href="#apply-with-second-order-unification"><span class="std std-ref">here</span></a> (after &quot;unless&quot;).</p>
<p>Note that we usually use <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> rather than applying <code class="docutils literal notranslate"><span class="pre">nat_ind</span></code> directly.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span><span>
</span></dt><dd><span>nat_ind
     : </span><span class="ansi-bold">forall</span><span> P : nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       P 0</span><span> -&gt;</span><span> (</span><span class="ansi-bold">forall</span><span> n : nat, P n</span><span> -&gt;</span><span> P (S n))</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : nat, P n
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">nat_ind</span><span>. </span><span class="coqdoc-comment">(* Notice the goals are unprovable. *)</span></dt><dd><span>2 goals
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> 0

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> n : nat, x</span><span> +</span><span> y</span><span> =</span><span> n</span><span> -&gt;</span><span> x</span><span> +</span><span> y</span><span> =</span><span> S n
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> </span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-comment">(* apply has instantiated P with (eq (x + y))</span><span class="coqdoc-comment">
               because the goal was (eq (x + y) (y + x))</span><span class="coqdoc-comment">
               and n could be unified with (y + x) *)</span></dt><dd><span>(</span><span class="ansi-bold">fun</span><span> x y : nat =&gt; nat_ind (eq (x</span><span> +</span><span> y)) </span><span class="ansi-fg-light-blue">?Goal</span><span> </span><span class="ansi-fg-light-blue">?Goal0</span><span> (y</span><span> +</span><span> x))
</span></dd>
<dt><span></span><span class="coqdoc-comment">(* However, we can use the pattern tactic to get the instantiation we want: *)</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">pattern</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; n</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> n) x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x, y : nat
  ============================
  0</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> 0

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> n</span><span> -&gt;</span><span> S n</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> S n
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> </span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-comment">(* apply has instantiated P with (fun n : nat =&gt; n + y = y + n)</span><span class="coqdoc-comment">
               and the goal can be proven *)</span></dt><dd><span>(</span><span class="ansi-bold">fun</span><span> x y : nat =&gt;
 nat_ind (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; n</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> n) </span><span class="ansi-fg-light-blue">?Goal</span><span> </span><span class="ansi-fg-light-blue">?Goal0</span><span> x : x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x)
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eapply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eapply</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>, but creates
<a class="reference internal" href="../language/extensions/evars.html#existential-variables"><span class="std std-ref">existential variables</span></a>
when Coq is unable to deduce instantiations for variables, rather than failing.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.rapply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">rapply</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.rapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> but
uses the proof engine of <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> to handle
existential variables, holes and conversion problems.  This may
result in slightly different behavior regarding which conversion
problems are solvable.  However, <a class="reference internal" href="#coq:tacn.rapply" title="rapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rapply</span></code></a> fails if any holes remain
in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> itself after typechecking and
typeclass resolution but before unification with the goal. Note
that <a class="reference internal" href="#coq:tacn.rapply" title="rapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rapply</span></code></a> tries to instantiate as many hypotheses of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> as possible.  As a result, if it is possible to apply
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> to arbitrarily many arguments without getting a type
error, <a class="reference internal" href="#coq:tacn.rapply" title="rapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rapply</span></code></a> will loop.</p>
<p>Note that you must <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Require</span></span></span> <span><span><span class="pre">Import</span></span></span> <span><span><span class="pre">Coq.Program.Tactics</span></span></span></span></code> to
use <a class="reference internal" href="#coq:tacn.rapply" title="rapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rapply</span></code></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-apply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">apply</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> but it reasons modulo conversion only on subterms
that contain no variables to instantiate and does not traverse tuples.
For instance, the following example fails because it would require converting
<code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">?foo</span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>.</p>
<div class="admonition note" id="simple-apply-ex">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>) := </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>id is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">id</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>H is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">O</span><span> = </span><span class="coqdoc-var">O</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  0</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">simple</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Unable to unify &quot;id </span><span class="ansi-fg-light-blue">?M150</span><span> =</span><span> </span><span class="ansi-fg-light-blue">?M151</span><span>&quot; with &quot;0</span><span> =</span><span> 0&quot;.
</span></dd>
</dl>
</div>
</div>
<p>Because it reasons modulo a limited amount of conversion, <a class="reference internal" href="#coq:tacn.simple-apply" title="simple apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">apply</span></code></a> fails
faster than <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and it is thus well-suited for use in user-defined
tactics that backtrack often.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-eapply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">eapply</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-in_hyp_as"><span class="hole"><span class="pre">in_hyp_as</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-eapply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.lapply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">lapply</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.lapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> in the goal reducible to the form <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>, replacing it
with two new subgoals <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>.
<code class="docutils literal notranslate"><span class="pre">lapply</span> <span class="pre">H</span></code> (where <code class="docutils literal notranslate"><span class="pre">H</span></code> is <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> does not start with a product)
is equivalent to <a class="reference internal" href="#coq:tacn.cut" title="cut"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cut</span></code></a> <code class="docutils literal notranslate"><span class="pre">B.</span> <span class="pre">2:apply</span> <span class="pre">H.</span></code>.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.lapply-needs-a-non-dependent-product">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">lapply</span></span></span> <span><span><span class="pre">needs</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">non-dependent</span></span></span> <span><span><span class="pre">product.</span></span></span></span></span><a class="headerlink" href="#coq:exn.lapply-needs-a-non-dependent-product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Assume we have a transitive relation <code class="docutils literal notranslate"><span class="pre">R</span></code> on <code class="docutils literal notranslate"><span class="pre">nat</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>R is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Rtrans</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Rtrans is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameters</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>n is declared
m is declared
p is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Rnm</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Rnm is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Rmp</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Rmp is declared
</span></dd>
</dl>
</div>
<p>Consider the goal <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">n</span> <span class="pre">p)</span></code> provable using the transitivity of <code class="docutils literal notranslate"><span class="pre">R</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  R n p
</span></dd>
</dl>
</div>
<p>The direct application of <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> with <code class="docutils literal notranslate"><span class="pre">apply</span></code> fails because no value
for <code class="docutils literal notranslate"><span class="pre">y</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> is found by <code class="docutils literal notranslate"><span class="pre">apply</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span>.</span><span>
</span></dt><dd><span>Toplevel input, characters 6-12:
&gt; apply Rtrans.
&gt;       ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Unable to find an instance for the variable y.
</span></dd>
</dl>
</div>
<p>A solution is to <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">p)</span></code> or <code class="docutils literal notranslate"><span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m)</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> (</span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  R n m

goal 2 is:
 R m p
</span></dd>
</dl>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">n</span></code> can be inferred from the goal, so the following would work
too.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> (</span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">m</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  ============================
  R n m

goal 2 is:
 R m p
</span></dd>
</dl>
</div>
<p>More elegantly, <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">Rtrans</span> <span class="pre">with</span> <span class="pre">(y:=m)</span></code> allows only mentioning the
unknown m:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">m</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  ============================
  R n m

goal 2 is:
 R m p
</span></dd>
</dl>
</div>
<p>Another solution is to mention the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">x</span> <span class="pre">y)</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code></p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (1 := </span><span class="coqdoc-var">Rnm</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  R m p
</span></dd>
</dl>
</div>
<p>… or the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">y</span> <span class="pre">z)</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (2 := </span><span class="coqdoc-var">Rmp</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  R n m
</span></dd>
</dl>
</div>
<p>On the opposite, one can use <code class="docutils literal notranslate"><span class="pre">eapply</span></code> which postpones the problem of
finding <code class="docutils literal notranslate"><span class="pre">m</span></code>. Then one can apply the hypotheses <code class="docutils literal notranslate"><span class="pre">Rnm</span></code> and <code class="docutils literal notranslate"><span class="pre">Rmp</span></code>. This
instantiates the existential variable and completes the proof.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">eapply</span><span> </span><span class="coqdoc-var">Rtrans</span><span>.</span><span>
</span></dt><dd><span>2 focused goals (shelved: 1)
  
  ============================
  R n </span><span class="ansi-fg-light-blue">?y</span><span>

goal 2 is:
 R </span><span class="ansi-fg-light-blue">?y</span><span> p
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rnm</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  R m p
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rmp</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
</div>
</section>
<section id="managing-the-local-context">
<span id="managingthelocalcontext"></span><h2>Managing the local context<a class="headerlink" href="#managing-the-local-context" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.intro">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">intro</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-where"><span class="hole"><span class="pre">where</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.intro" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> tactic until it finds an item that can be
introduced in the context by removing certain constructs in the goal.
If no item is found, the tactic fails.  The name used is
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (if specified) or from the construct, except that if the name from the
construct already exists in the <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-local-context"><span class="xref std std-term">local context</span></a>, Coq uses a fresh name
instead.  The constructs have these forms:
(See examples <a class="reference internal" href="#intro-examples"><span class="std std-ref">here</span></a>.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">T,</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">T</span></code> is a <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premise</span></a>.  Removes <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T,</span></code>
from the goal and adds <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">T</span></code> to the context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">A</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">…</span></span></span></span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a <a class="reference internal" href="../language/core/assumptions.html#term-non-dependent-premise"><span class="xref std std-term">non-dependent premise</span></a>.  Removes <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span></code> from
the goal and adds <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">A</span></code> to the context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">c,</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt><dd><p>Removes <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">c,</span></code> from the goal and adds <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">c</span> <span class="pre">:</span> <span class="pre">T</span></code> to the context.</p>
</dd>
</dl>
</dd></dl>

<blockquote id="warn-should-give-name-in-intro">
<div><p>We recommend always specifying <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> so that the names of hypotheses don't
change as the proof is updated, making your proof easier to maintain.  For example,
if H exists in the context, Coq will consider using <code class="docutils literal notranslate"><span class="pre">H0</span></code>, <code class="docutils literal notranslate"><span class="pre">H1</span></code>, ... until it finds an
unused name.  Modifications to a proof can change automatically assigned names
that subsequent tactics likely refer to, making the proofs harder to maintain.  The
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#coq:flag.Mangle-Names" title="Mangle Names"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Mangle</span> <span class="pre">Names</span></code></a> flag gives some control over how fresh names are generated (see
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-maintenance"><span class="std std-ref">Proof maintenance</span></a>).</p>
<p>Note that <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> lets you introduce multiple items into
the context with a single tactic.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></dt><dd><p>The name to give to the introduced item.  If not given, Coq uses the
variable name from the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="pre">H</span></code> for premises.
If a name such as <code class="docutils literal notranslate"><span class="pre">H</span></code> is already in use, Coq will consider using <code class="docutils literal notranslate"><span class="pre">H0</span></code>,
<code class="docutils literal notranslate"><span class="pre">H1</span></code>, ... until it finds a fresh name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a hypothesis name hides the base name of a global constant then
the latter can still be referred to by a qualified name
(see <a class="reference internal" href="../language/core/modules.html#qualified-names"><span class="std std-ref">Qualified names</span></a>).</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-where"><span class="hole"><span class="pre">where</span></span></a></span></code></dt><dd><p>Indicates where to place the introduced hypothesis: at the top or bottom
of the context or before or after another specified hypothesis.  The default
is <code class="docutils literal notranslate"><span class="pre">at</span> <span class="pre">bottom</span></code>.</p>
</dd>
</dl>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.‘ident’-is-already-used">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">already</span></span></span> <span><span><span class="pre">used.</span></span></span></span></span><a class="headerlink" href="#coq:exn.‘ident’-is-already-used" title="Permalink to this definition">¶</a></dt>
<dd><p>The provided <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is already used in the <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-local-context"><span class="xref std std-term">local context</span></a>.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-product-even-after-head-reduction">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">product</span></span></span> <span><span><span class="pre">even</span></span></span> <span><span><span class="pre">after</span></span></span> <span><span><span class="pre">head-reduction.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-product-even-after-head-reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>There is nothing to introduce even after <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> has been completely applied.</p>
</dd></dl>

<div class="admonition note" id="intro-examples">
<p class="admonition-title">Example: <code class="docutils literal notranslate"><span class="pre">intro</span></code> and <code class="docutils literal notranslate"><span class="pre">intros</span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> &lt; </span><span class="coqdoc-var">n</span><span> -&gt; (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">x</span><span> := 0 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">True</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> m n : nat, m</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> </span><span class="ansi-bold">let</span><span> x := 0 </span><span class="ansi-bold">in</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, m</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> </span><span class="ansi-bold">let</span><span> x := 0 </span><span class="ansi-bold">in</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  ============================
  m</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> </span><span class="ansi-bold">let</span><span> x := 0 </span><span class="ansi-bold">in</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  H : m</span><span> &lt;</span><span> n
  ============================
  </span><span class="ansi-bold">let</span><span> x := 0 </span><span class="ansi-bold">in</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  H : m</span><span> &lt;</span><span> n
  x := 0 : nat
  ============================
  True
</span></dd>
</dl>
</div>
<p>This single <code class="docutils literal notranslate"><span class="pre">intros</span></code> tactic is equivalent to the 4 preceding <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactics:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> &lt; </span><span class="coqdoc-var">n</span><span> -&gt; (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">x</span><span> := 0 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">True</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> m n : nat, m</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> </span><span class="ansi-bold">let</span><span> x := 0 </span><span class="ansi-bold">in</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  H : m</span><span> &lt;</span><span> n
  x := 0 : nat
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.intros">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#coq:tacn.intros" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.intros-until">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span></span></span><a class="headerlink" href="#coq:tacn.intros-until" title="Permalink to this definition">¶</a></dt>
<dd><p>The first form introduces zero or more items into the context from the
constructs listed in <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>.  If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span></code> is not specified,
the tactic introduces items until it reaches the <a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a>;
it never fails and may leave the context unchanged.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span></code> is specified, the <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> tactic is applied until
it finds an item that can be introduced into the context.
The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span></code> is
often just a list of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s, but other forms can also be specified
in order to, for example, introduce all <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a> (<code class="docutils literal notranslate"><span class="pre">*</span></code>);
introduce all dependent and <a class="reference internal" href="../language/core/assumptions.html#term-non-dependent-premise"><span class="xref std std-term">non-dependent premises</span></a> (<code class="docutils literal notranslate"><span class="pre">**</span></code>);
split terms such as <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code> (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) and pick a fresh name with a given prefix (<code class="docutils literal notranslate"><span class="pre">?X</span></code>).
See <a class="reference internal" href="#intropatterns"><span class="std std-ref">Intro patterns</span></a>.</p>
<p>The second form repeats <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intro</span></span></span></span></code> until it has introduced a <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premise</span></a>
with the name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> or has introduced
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> <a class="reference internal" href="../language/core/assumptions.html#term-premise"><span class="xref std std-term">premises</span></a> (like <code class="docutils literal notranslate"><span class="pre">A</span></code> in <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>).</p>
<p>We recommend explicitly naming items with <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> instead of using
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code>.  See the explanation <a class="reference internal" href="#warn-should-give-name-in-intro"><span class="std std-ref">here</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Example: intros until</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> =</span><span> y</span><span> -&gt;</span><span> y</span><span> =</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-tactic">until</span><span> </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> =</span><span> y</span><span> -&gt;</span><span> y</span><span> =</span><span> x
</span></dd>
</dl>
</div>
<p>Or:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> =</span><span> y</span><span> -&gt;</span><span> y</span><span> =</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-tactic">until</span><span> 1.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  H : x</span><span> =</span><span> y
  ============================
  y</span><span> =</span><span> x
</span></dd>
</dl>
</div>
</div>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-quantified-hypothesis-named-‘ident’-in-current-goal-even-after-head-reduction">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">quantified</span></span></span> <span><span><span class="pre">hypothesis</span></span></span> <span><span><span class="pre">named</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">current</span></span></span> <span><span><span class="pre">goal</span></span></span> <span><span><span class="pre">even</span></span></span> <span><span><span class="pre">after</span></span></span> <span><span><span class="pre">head-reduction.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-quantified-hypothesis-named-‘ident’-in-current-goal-even-after-head-reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the <code class="docutils literal notranslate"><span class="pre">until</span></code> clause doesn't appear as a <a class="reference internal" href="../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premise</span></a>.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-‘natural’-th-non-dependent-hypothesis-in-current-goal-even-after-head-reduction">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a><span><span><span class="pre">-th</span></span></span> <span><span><span class="pre">non</span></span></span> <span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">hypothesis</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">current</span></span></span> <span><span><span class="pre">goal</span></span></span> <span><span><span class="pre">even</span></span></span> <span><span><span class="pre">after</span></span></span> <span><span><span class="pre">head-reduction.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-‘natural’-th-non-dependent-hypothesis-in-current-goal-even-after-head-reduction" title="Permalink to this definition">¶</a></dt>
<dd><p>There are fewer than <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> premises in the goal.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eintros">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eintros</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eintros" title="Permalink to this definition">¶</a></dt>
<dd><p>Works just like <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> except that it creates existential variables
for any unresolved variables rather than failing.  Typically this happens when
using a <code class="docutils literal notranslate"><span class="pre">%</span></code> intropattern (see <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span></code>).</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.clear">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">clear</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">-</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Erases <em>unneeded</em> hypotheses from the context of the current goal.  &quot;Unneeded&quot;
means that the unselected hypotheses and the goal don't depend directly or
indirectly on the erased hypotheses.  That means the hypotheses will no longer
appear in the context and therefore can't be used in subsequent proof steps.
Note that erasing an uneeded hypothesis may turn a goal that was provable
into an unprovable goal.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">clear</span></span></span></span></code></dt><dd><p>All unneeded hypotheses are erased.  This may leave the context unchanged; this form
never fails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">clear</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>Erases the named hypotheses if they are unneeded and fails otherwise.</p>
<blockquote>
<div><dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.‘ident’-is-used-in-the-conclusion">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">used</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">conclusion.</span></span></span></span></span><a class="headerlink" href="#coq:exn.‘ident’-is-used-in-the-conclusion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.‘ident’-is-used-in-the-hypothesis-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">used</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">hypothesis</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.‘ident’-is-used-in-the-hypothesis-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">clear</span></span></span> <span><span><span class="pre">-</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>Selects all hypotheses that are not named by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s, then
erases those that are unneeded.
This may leave the context unchanged; this form never fails as long as the
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s name hypotheses in the context.</p>
</dd>
</dl>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.clearbody">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">clearbody</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></span><a class="headerlink" href="#coq:tacn.clearbody" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic expects <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to be <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definitions</span></a>
and clears their respective bodies.
In other words, it turns the given definitions into assumptions.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.‘ident’-is-not-a-local-definition">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">local</span></span></span> <span><span><span class="pre">definition.</span></span></span></span></span><a class="headerlink" href="#coq:exn.‘ident’-is-not-a-local-definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.clear-dependent">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">clear</span></span></span> <span><span><span class="pre">dependent</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.clear-dependent" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the hypothesis <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and all the hypotheses that depend on it.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.revert">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">revert</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></span><a class="headerlink" href="#coq:tacn.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the specified hypotheses and <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definitions</span></a>
to the goal, if this respects dependencies. This is
the inverse of <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.revert-dependent">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">revert</span></span></span> <span><span><span class="pre">dependent</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.revert-dependent" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.18.</span></p>
</div>
<p>An alias for <a class="reference internal" href="#coq:tacn.generalize-dependent" title="generalize dependent"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span> <span class="pre">dependent</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.move">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">move</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a> <a class="reference internal" href="#grammar-token-where"><span class="hole"><span class="pre">where</span></span></a></span></span><a class="headerlink" href="#coq:tacn.move" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-where"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-where"><span class="hole">where</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>at</span></span> <span><span>top</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>at</span></span> <span><span>bottom</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>before</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>after</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Moves a hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code> and hypotheses that directly or indirectly
refer to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code> that appear between <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.
<code class="docutils literal notranslate"><span class="pre">at</span> <span class="pre">top</span></code> and <code class="docutils literal notranslate"><span class="pre">at</span> <span class="pre">bottom</span></code> are
equivalent to giving the name of the first or last hypotheses in the context.  The
dependent hypotheses will appear after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code>, appearing in dependency order.
This lets users show and group hypotheses in the order they prefer.  It doesn't
change the goal or the proof term.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Perhaps confusingly, &quot;before&quot; and &quot;after&quot; are interpeted with respect to the direction
in which the hypotheses are moved rather than in the order of the resulting
list of hypotheses.  If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code> is before <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the context, these
notions are the
same: for hypotheses <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">A</span> <span class="pre">after</span> <span class="pre">B</span></code> gives <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">A</span> <span class="pre">C</span></code>, whereas if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a></span></code>
is after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the context, they are the opposite: <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">C</span> <span class="pre">after</span> <span class="pre">A</span></code> gives
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">A</span> <span class="pre">B</span></code> because the direction of movement is reversed.</p>
</div>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-move-‘ident’-after-‘ident’:-it-occurs-in-the-type-of-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">move</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a> <span><span><span class="pre">after</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">:</span></span></span> <span><span><span class="pre">it</span></span></span> <span><span><span class="pre">occurs</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-move-‘ident’-after-‘ident’:-it-occurs-in-the-type-of-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-move-‘ident’-after-‘ident’:-it-depends-on-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">move</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">from</span></sub></span></a> <span><span><span class="pre">after</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">:</span></span></span> <span><span><span class="pre">it</span></span></span> <span><span><span class="pre">depends</span></span></span> <span><span><span class="pre">on</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-move-‘ident’-after-‘ident’:-it-depends-on-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: move</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> :</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = 0 -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">y</span><span>=</span><span class="coqdoc-var">y</span><span>-&gt; 0=</span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> =</span><span> 0</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> y : nat, nat</span><span> -&gt;</span><span> y</span><span> =</span><span> y</span><span> -&gt;</span><span> 0</span><span> =</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Hx</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">Hy</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-comment">(*                    x Hx y z Hy *)</span></dt><dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">z</span><span>. </span><span class="coqdoc-comment">(*    x Hx z y Hy   (z was left of y, intuitive case) *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  z, y : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">y</span><span>. </span><span class="coqdoc-comment">(*    x Hx z y Hy   (z was right of y, see Note above) *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  z, y : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">Hy</span><span>. </span><span class="coqdoc-comment">(*   y z Hy x Hx   (Hx depends on x, so moved) *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  y, z : nat
  Hy : y</span><span> =</span><span> y
  x : nat
  Hx : x</span><span> =</span><span> 0
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">before</span><span> </span><span class="coqdoc-var">Hy</span><span>. </span><span class="coqdoc-comment">(*  y z x Hx Hy *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  y, z, x : nat
  Hx : x</span><span> =</span><span> 0
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">Hy</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">Hx</span><span>. </span><span class="coqdoc-comment">(*  x y Hy Hx z *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : nat
  Hy : y</span><span> =</span><span> y
  Hx : x</span><span> =</span><span> 0
  z : nat
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Undo</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y, z : nat
  Hy : y</span><span> =</span><span> y
  ============================
  0</span><span> =</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">Hy</span><span> </span><span class="coqdoc-keyword">before</span><span> </span><span class="coqdoc-var">Hx</span><span>. </span><span class="coqdoc-comment">(* x Hx y Hy z *)</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  Hx : x</span><span> =</span><span> 0
  y : nat
  Hy : y</span><span> =</span><span> y
  z : nat
  ============================
  0</span><span> =</span><span> x
</span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.rename">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">rename</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">into</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#coq:tacn.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Renames hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> for each pair of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s.
Renaming is done simultaneously, which permits swapping the names of 2 hypotheses.
(Note that the renaming is applied in the context and the existential
variables, but the proof term doesn't change.)</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.set">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">set</span></span></span> <a class="reference internal" href="#grammar-token-alias_definition"><span class="hole"><span class="pre">alias_definition</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.set" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id4">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">set</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-alias_definition"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-alias_definition"><span class="hole">alias_definition</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_binder"><span class="hole">simple_binder</span></a></span><span class="notation-sup">*</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simple_binder"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simple_binder"><span class="hole">simple_binder</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-as_name"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-as_name"><span class="hole">as_name</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>as</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>The first form adds a new local definition <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">…</span></span></span></span></code>.  If
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span></code> is not specified, the definition body is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and
otherwise <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.  Then the tactic replaces
the body expression with the new variable <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the goal or as
specified by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code>.  The tactic may succeed and add the local
definition even if no replacements are made.</p>
<p>The second form is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">set</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a><span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>
using <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, if present, or an auto-generated name if not provided.</p>
<p>If <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> or <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a> has holes (i.e. subexpressions with the
form “<code class="docutils literal notranslate"><span class="pre">_</span></code>”), the tactic first checks that all subterms matching the pattern
are compatible before doing the replacement using the leftmost subterm
matching the pattern.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.The-variable-‘ident’-is-already-declared">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">The</span></span></span> <span><span><span class="pre">variable</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">already</span></span></span> <span><span><span class="pre">declared.</span></span></span></span></span><a class="headerlink" href="#coq:exn.The-variable-‘ident’-is-already-declared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: set with a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span></code></p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">set</span></span></span></span></code> does a simple syntactic replacement in the goal:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span> = 0.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> =</span><span> 0
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  ============================
  n</span><span> =</span><span> 0
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">pattern</span><span> </span><span class="coqdoc-var">n</span><span>. </span><span class="coqdoc-comment">(* without this, &quot;set&quot; won't replace anything in the goal *)</span></dt><dd><span>1 goal
  
  n : nat
  ============================
  (</span><span class="ansi-bold">fun</span><span> n0 : nat =&gt; n0</span><span> =</span><span> 0) n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> = 0).</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  f := </span><span class="ansi-bold">fun</span><span> x : nat =&gt; x</span><span> =</span><span> 0 : nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  ============================
  f n
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eset">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eset</span></span></span> <a class="reference internal" href="#grammar-token-alias_definition"><span class="hole"><span class="pre">alias_definition</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eset" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id5">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eset</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>, but instead of failing because of uninstantiated
variables, generates existential variables for them.
In practice, this is relevant only when <a class="reference internal" href="#coq:tacn.eset" title="eset"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eset</span></code></a> is
used as a synonym of <a class="reference internal" href="#coq:tacn.epose" title="epose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span></code></a>, i.e. when the <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> does
not occur in the goal.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.remember">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">remember</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">eqn</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.remember" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">set</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a><span><span><span class="pre">)</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">*</span></span></span></span></code> but creates a hypothesis using
<a class="reference internal" href="../proofs/writing-proofs/equality.html#term-Leibniz-equality"><span class="xref std std-term">Leibniz equality</span></a> to remember the relation between the introduced
variable and the term rather than creating a
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definition</span></a>.  If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span></code> is not
specified a fresh name is used.
Use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span></code> to name the new equation.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eremember">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eremember</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">eqn</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eremember" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a>, but instead of failing because of uninstantiated
variables, generates existential variables for them.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.pose">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">pose</span></span></span> <a class="reference internal" href="#grammar-token-alias_definition"><span class="hole"><span class="pre">alias_definition</span></span></a></span></span><a class="headerlink" href="#coq:tacn.pose" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id6">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">pose</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>.  Adds a <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definition</span></a>
to the context but without doing any replacement.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.epose">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">epose</span></span></span> <a class="reference internal" href="#grammar-token-alias_definition"><span class="hole"><span class="pre">alias_definition</span></span></a></span></span><a class="headerlink" href="#coq:tacn.epose" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id7">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">epose</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#coq:tacn.pose" title="pose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a>, but instead of failing because of uninstantiated
variables, generates existential variables for them.</p>
</dd></dl>

</dd></dl>

</section>
<section id="controlling-the-proof-flow">
<span id="controllingtheproofflow"></span><h2>Controlling the proof flow<a class="headerlink" href="#controlling-the-proof-flow" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.assert">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assert</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.assert" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id8">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assert</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#id8" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assert</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span></dt>
<dd><p>Adds a new hypothesis to the current subgoal and a new subgoal before
it to prove the hypothesis.  Then, if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code>
is specified, it applies that tactic to fully prove the new subgoal (and
otherwise fails).</p>
<p>The first form adds a new hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> of type <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.
(This corresponds to the cut rule of sequent calculus.)</p>
<p>The second form is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">assert</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">)</span></span></span> <span><span><span class="pre">by</span></span></span> <span><span><span class="pre">exact</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> where
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> is the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.  It is also equivalent to using
<a class="reference internal" href="#coq:tacn.pose-proof" title="pose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">proof</span></code></a>. If the head of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, the tactic
is equivalent to <a class="reference internal" href="#coq:tacn.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a>.</p>
<p>In the third form, if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> isn't specified, the tactic adds the
hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> with a fresh name.  Otherwise, it transforms the
hypothesis as specified by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> and adds the resulting new hypotheses
and goals.  See <a class="reference internal" href="#intropatterns"><span class="std std-ref">Intro patterns</span></a>.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.The-term-&quot;‘type’&quot;-has-type-&quot;‘type’&quot;-which-should-be-Set,-Prop-or-Type">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">The</span></span></span> <span><span><span class="pre">term</span></span></span> <span><span><span class="pre">&quot;</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">&quot;</span></span></span> <span><span><span class="pre">has</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">&quot;</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span><sub><span class="pre">1</span></sub></span></a><span><span><span class="pre">&quot;</span></span></span> <span><span><span class="pre">which</span></span></span> <span><span><span class="pre">should</span></span></span> <span><span><span class="pre">be</span></span></span> <span><span><span class="pre">Set,</span></span></span> <span><span><span class="pre">Prop</span></span></span> <span><span><span class="pre">or</span></span></span> <span><span><span class="pre">Type.</span></span></span></span></span><a class="headerlink" href="#coq:exn.The-term-"‘type’"-has-type-"‘type’"-which-should-be-Set,-Prop-or-Type" title="Permalink to this definition">¶</a></dt>
<dd><p>Occurs when the argument <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> (in the first form) or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code>
(in the third form) is not of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> nor <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Proof-is-not-complete.-(assert)">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Proof</span></span></span> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">complete.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Proof-is-not-complete.-(assert)" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> was not able to prove the new hypothesis.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eassert">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eassert</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eassert" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id9">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eassert</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#id9" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eassert</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span></dt>
<dd><p>Unlike <a class="reference internal" href="#coq:tacn.assert" title="assert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assert</span></code></a>, the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> in
<a class="reference internal" href="#coq:tacn.eassert" title="eassert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eassert</span></code></a> may contain <span class="term-defn"><span class="target" id="term-hole"></span>holes</span>, denoted by <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code>,
for which the tactic will create existential variables.  This lets you
avoid specifying the asserted statement completely before starting to
prove it.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.enough">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">enough</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.enough" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id10">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">enough</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id10" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new hypothesis to the current subgoal and a new subgoal after it
to prove the hypothesis.</p>
<p>The first form adds a new hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>
and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> as the new subgoal.  Then, if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> is
specified, it applies that tactic to prove the current subgoal
with the added hypothesis (and otherwise fails).</p>
<p>In the second form, if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> isn't specified, the tactic adds a new
hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> with a name chosen by Coq.  Otherwise, it transforms
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> as specified by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> and adds the resulting new hypotheses.
The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> may also expand the current subgoal into multiple subgoals.
Then, if <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span></code> is specified, it is applied to and must succeed on all
of them.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eenough">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eenough</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eenough" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id11">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eenough</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="ltac.html#grammar-token-ltac_expr3"><span class="hole"><span class="pre">ltac_expr3</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id11" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlike <a class="reference internal" href="#coq:tacn.enough" title="enough"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">enough</span></code></a>, the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> in
<a class="reference internal" href="#coq:tacn.eenough" title="eenough"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eenough</span></code></a> may contain <a class="reference internal" href="#term-hole"><span class="xref std std-term">holes</span></a>, denoted by <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code>,
for which the tactic will create existential variables.  This lets you
avoid specifying the asserted statement completely until you start to use
the hypothesis or later start to prove the statement.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.cut">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cut</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></span><a class="headerlink" href="#coq:tacn.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the non-dependent case of the <a class="reference internal" href="../language/cic.html#app-rule"><span class="std std-ref">App</span></a> typing rule,
the Modus Ponens inference rule.  It is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">enough</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a><span><span><span class="pre">).</span></span></span> <span><span><span class="pre">revert</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></code>
This tactic is generally considered obsolete but it is still widely
used in old scripts.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.pose-proof">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">pose</span></span></span> <span><span><span class="pre">proof</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.pose-proof" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id12">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">pose</span></span></span> <span><span><span class="pre">proof</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#id12" title="Permalink to this definition">¶</a></dt>
<dd><p>The first form behaves like <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">assert</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">by</span></span></span> <span><span><span class="pre">exact</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
where <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_type</span></code></a> is the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>The second form is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">assert</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code>.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.epose-proof">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">epose</span></span></span> <span><span><span class="pre">proof</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.epose-proof" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id13">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">epose</span></span></span> <span><span><span class="pre">proof</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#id13" title="Permalink to this definition">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacn.pose-proof" title="pose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">proof</span></code></a> expects that no existential variables are generated by
the tactic, <a class="reference internal" href="#coq:tacn.epose-proof" title="epose proof"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span> <span class="pre">proof</span></code></a> removes this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.specialize">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">specialize</span></span></span> <a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.specialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Specializes a term (typically a hypothesis or a lemma) by applying arguments to it.</p>
<p><em>First</em>, the tactic generates a modified term:
If the <a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a> of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)
has the type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">...</span></code>, the tactic replaces one or more of the
quantified variables in the type with arguments provided by
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>, either in the form of a
<a class="reference internal" href="../language/core/assumptions.html#function-application"><span class="std std-ref">function application</span></a> (which may be partial),
such as <code class="docutils literal notranslate"><span class="pre">(H</span> <span class="pre">1)</span></code>, or with named or numbered binders, such as <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">with</span> <span class="pre">(n:=1)</span></code>.</p>
<p>If the <a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a> has a <a class="reference internal" href="../language/core/assumptions.html#term-non-dependent-product"><span class="xref std std-term">non-dependent product</span></a> type such as
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code>, the tactic eliminates one or more of the premises
(doing <a class="reference internal" href="#term-forward-reasoning"><span class="xref std std-term">forward reasoning</span></a>).</p>
<p>Uninstantiated arguments are inferred by unification, if possible, or otherwise
left quantified in the resulting term.</p>
<p><em>Then</em>, If the <a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a> is a hypothesis <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H</span></span></span></span></code>, the resulting
term replaces that hypothesis.  Specifying <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> will leave the original
hypothesis unchanged and will introduce new hypotheses as specified by the
<a class="reference internal" href="#grammar-token-simple_intropattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">simple_intropattern</span></code></a>.  If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H</span></span></span></span></code> appears in the conclusion or another
hypothesis, you must use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> to give a fresh hypothesis name.</p>
<p>If the head constant is a lemma or theorem, the resulting term
is added as a new premise of the goal so that the behavior is similar
to that of <a class="reference internal" href="#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>.  In this case, you can use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_ipat"><span class="hole"><span class="pre">as_ipat</span></span></a></span></code> to
immediately introduce the modified term as one or more hypotheses.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-change-‘ident’,-it-is-used-in-hypothesis-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">change</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">,</span></span></span> <span><span><span class="pre">it</span></span></span> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">used</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">hypothesis</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-change-‘ident’,-it-is-used-in-hypothesis-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-change-‘ident’,-it-is-used-in-conclusion">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">change</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">,</span></span></span> <span><span><span class="pre">it</span></span></span> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">used</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">conclusion.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-change-‘ident’,-it-is-used-in-conclusion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: partial application in <a class="reference internal" href="#coq:tacn.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>: </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span> = </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  (</span><span class="ansi-bold">forall</span><span> n m : nat, n</span><span> +</span><span> m</span><span> =</span><span> m</span><span> +</span><span> n)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> n m : nat, n</span><span> +</span><span> m</span><span> =</span><span> m</span><span> +</span><span> n
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">specialize</span><span> (</span><span class="coqdoc-var">H</span><span> 1). </span><span class="coqdoc-comment">(* equivalent to: specialize H with (n := 1) *)</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> m : nat, 1</span><span> +</span><span> m</span><span> =</span><span> m</span><span> +</span><span> 1
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: <a class="reference internal" href="#coq:tacn.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a> with a non-dependent product</p>
<p>Compare this to a similar <a class="reference internal" href="#apply-forward"><span class="std std-ref">example</span></a> that uses
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>.  <a class="reference internal" href="#coq:tacn.specialize" title="specialize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">specialize</span></code></a> won't introduce new goals as
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> can.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">B</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, B</span><span> -&gt;</span><span> (A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C)</span><span> -&gt;</span><span> True
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H0</span><span> </span><span class="coqdoc-var">H1</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H0 : B
  H1 : A</span><span> -&gt;</span><span> B</span><span> -&gt;</span><span> C
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">specialize</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-keyword">with</span><span> (2:=</span><span class="coqdoc-var">H0</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H0 : B
  H1 : A</span><span> -&gt;</span><span> C
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.specialize_eqs">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">specialize</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eqs</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.specialize_eqs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.generalize">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></span><a class="headerlink" href="#coq:tacn.generalize" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id14">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../proofs/writing-proofs/equality.html#grammar-token-pattern_occs"><span class="hole"><span class="pre">pattern_occs</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#id14" title="Permalink to this definition">¶</a></dt>
<dd><p>For each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (which may be in the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../proofs/writing-proofs/equality.html#grammar-token-pattern_occs"><span class="hole"><span class="pre">pattern_occs</span></span></a></span></code>), replaces the
goal <code class="docutils literal notranslate"><span class="pre">G</span></code> with <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x:T),</span> <span class="pre">G'</span></code>,
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> is a subterm of <code class="docutils literal notranslate"><span class="pre">G</span></code> of type <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">G'</span></code> is obtained
by replacing all occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code> within <code class="docutils literal notranslate"><span class="pre">G</span></code>.  <code class="docutils literal notranslate"><span class="pre">x</span></code> is
a fresh variable chosen based on <code class="docutils literal notranslate"><span class="pre">T</span></code>.  Specifying multiple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>s is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">n</span></sub></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">generalize</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a></span></code>.
(Note they are processed <em>right to left</em>.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-as_name"><span class="hole"><span class="pre">as_name</span></span></a></span></code></dt><dd><p>The name to use for <code class="docutils literal notranslate"><span class="pre">x</span></code> instead of a fresh name.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">nat</span><span>, 0 &lt;= </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : nat, 0</span><span> &lt;=</span><span> x</span><span> +</span><span> y</span><span> +</span><span> y
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">intros</span><span> *.</span><span>
</span></dt><dd class="coqtop-hidden"><span>
1 goal
  
  x, y : nat
  ============================
  0</span><span> &lt;=</span><span> x</span><span> +</span><span> y</span><span> +</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Show</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  0</span><span> &lt;=</span><span> x</span><span> +</span><span> y</span><span> +</span><span> y
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">generalize</span><span> (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span>). </span><span class="coqdoc-comment">(* get a simpler goal that can be proven by induction *)</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, 0</span><span> &lt;=</span><span> n
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.generalize-dependent">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span><span><span class="pre">dependent</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.generalize-dependent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalizes <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> and all hypotheses that depend on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>. It
clears the generalized hypotheses.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-generalize_eqs">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">generalize</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eqs</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.dependent-generalize_eqs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-generalize_eqs_vars">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">generalize</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eqs</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">vars</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.dependent-generalize_eqs_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.generalize_eqs">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eqs</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.generalize_eqs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.generalize_eqs_vars">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eqs</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">vars</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.generalize_eqs_vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.evar">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">evar</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#coq:tacn.evar" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id15">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">evar</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></span><a class="headerlink" href="#id15" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">evar</span></span></span></span></code> tactic creates a new <a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definition</span></a>
named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> with type <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> in the context.
The body of this binding is a fresh existential variable.  If the second
form is used, Coq chooses the name.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.instantiate">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">instantiate</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#coq:tacn.instantiate" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id16">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">instantiate</span></span></span> <span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">)</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-hloc"><span class="hole"><span class="pre">hloc</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id16" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-hloc"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-hloc"><span class="hole">hloc</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <span><span>|-</span></span> <span><span>*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <span><span>(</span></span> <span><span>type</span></span> <span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>in</span></span> <span><span>(</span></span> <span><span>value</span></span> <span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>The first form refines (see <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>) an existential variable
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> with the term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. It is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">only</span></span></span> <span><span><span class="pre">[</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">]:</span></span></span> <span><span><span class="pre">refine</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To be able to refer to an existential variable by name, the user
must have given the name explicitly (see <a class="reference internal" href="../language/extensions/evars.html#existential-variables"><span class="std std-ref">Existential variables</span></a>).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When you are referring to hypotheses which you did not name
explicitly, be aware that Coq may make a different decision on how to
name the variable in the current goal and in the context of the
existential variable. This can lead to surprising behaviors.</p>
</div>
<p>The second form refines an existential variable selected by its position.  The
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> argument is the position of the existential variable
<em>from right to left</em> in the goal.  (Use the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hloc"><span class="hole"><span class="pre">hloc</span></span></a></span></code> clause
to select an existential variable in a
hypothesis.)  Counting starts at 1 and multiple occurrences of the
same existential variable are counted multiple times.  Using this form
is discouraged because slight changes to the goal may change the needed index,
causing a maintenance issue.</p>
<p>Advanced users may want to define and use an Ltac tactic to get more consistent
behavior, such as:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">instantiate_ltac_variable</span><span> </span><span class="coqdoc-var">ev</span><span> </span><span class="coqdoc-var">term</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-tactic">fresh</span><span> </span><span class="coqdoc-tactic">in</span><span>
  </span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">ev</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">H</span><span>;</span><span>
  </span><span class="coqdoc-tactic">instantiate</span><span> (1 := </span><span class="coqdoc-var">term</span><span>) </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">value</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">H</span><span>);</span><span>
  </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></span></div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></dt><dd><p>Selects the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">in</span></span></span> <span><span><span class="pre">|-</span></span></span> <span><span><span class="pre">*</span></span></span></span></code></dt><dd><p>Selects the goal.  This is the default behavior.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">in</span></span></span> <span><span><span class="pre">(</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">)</span></span></span></span></code></dt><dd><p>Selects existential variables in the type of the
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definition</span></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.
(The body is not included.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">in</span></span></span> <span><span><span class="pre">(</span></span></span> <span><span><span class="pre">value</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">)</span></span></span></span></code></dt><dd><p>Selects existential variables in the body of the
<a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#term-context-local-definition"><span class="xref std std-term">local definition</span></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.
(The type is not included.)</p>
</dd>
</dl>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.absurd">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">absurd</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></span><a class="headerlink" href="#coq:tacn.absurd" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></code> is any proposition
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This tactic applies False elimination, that is it
deduces the current goal from False, and generates as subgoals <code class="code Coq docutils literal notranslate"><span class="name builtin pseudo"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. It is very useful in proofs by cases, where some cases are
impossible. In most cases, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name builtin pseudo"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> is one of the hypotheses of the
local context.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.contradiction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">contradiction</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.contradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to prove the current goal by finding a contradiction.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code> is not provided (the most common use case),
the tactic first does an <a class="reference internal" href="#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>.  The tactic then proves the goal if</p>
<ul class="simple">
<li><p>the updated context has a pair of hypotheses where one is the negation of
the other (e.g. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> and not <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">~P</span></span></span></span></code>), or</p></li>
<li><p>there is a hypothesis with an empty inductive type (e.g. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">False</span></span></span></span></code>), or</p></li>
<li><p>there is a hypothesis <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">~P</span></span></span></span></code> where <code class="docutils literal notranslate"><span class="pre">P</span></code> is a singleton inductive type
(e.g. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">True</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x=x</span></span></span></span></code>) provable by <code class="docutils literal notranslate"><span class="pre">Goal</span> <span class="pre">P.</span> <span class="pre">constructor.</span></code></p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code> is provided, its type
must be a negation, such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">~P</span></span></span></span></code>,
or an empty inductive type, such as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">False</span></span></span></span></code>.
If the type is a negation and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> is a hypothesis in the context,
the goal is proven.  If the type is a negation and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code> is not in
the context, the goal is replaced with <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">P</span></span></span></span></code>.  If the type is <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">False</span></span></span></span></code>
or another empty inductive type, the goal is proven.
Otherwise the tactic fails.  (If there is a hypothesis
<code class="docutils literal notranslate"><span class="pre">P</span></code> and you want to replace the goal with <code class="docutils literal notranslate"><span class="pre">~P</span></code>, use the <a class="reference internal" href="#coq:tacn.contradict" title="contradict"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradict</span></code></a>
tactic.  If there are hypotheses <code class="docutils literal notranslate"><span class="pre">H1</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">H2</span> <span class="pre">:</span> <span class="pre">~P</span></code>, use <code class="docutils literal notranslate"><span class="pre">contradiction</span></code>
without arguments or <code class="docutils literal notranslate"><span class="pre">contradiction</span> <span class="pre">H2</span></code> since <code class="docutils literal notranslate"><span class="pre">contradiction</span> <span class="pre">H1</span></code> won't work.)</p>
<p>Use the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> tactic to prove the current goal when there
is a hypothesis with an impossible structural equality such as
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">0</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">1</span></span></span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: <a class="reference internal" href="#coq:tacn.contradiction" title="contradiction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradiction</span></code></a> tactic</p>
<p>Simple examples.  To see more detail, add <code class="docutils literal notranslate"><span class="pre">intros</span></code> after each <code class="docutils literal notranslate"><span class="pre">Goal</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">F</span><span> :=. </span><span class="coqdoc-comment">(* Another empty inductive type *)</span></dt><dd class="coqtop-hidden"><span>F is defined
F_rect is defined
F_ind is defined
F_rec is defined
F_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">F</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  F</span><span> -&gt;</span><span> False
</span></dd>
<dt><span></span><span class="coqdoc-var">contradiction</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>), </span><span class="coqdoc-var">A</span><span> -&gt; ~</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> -&gt;</span><span> </span><span>~</span><span> A</span><span> -&gt;</span><span> False
</span></dd>
<dt><span></span><span class="coqdoc-var">contradiction</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>), ~(</span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">x</span><span>) -&gt; </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : A), x</span><span> &lt;&gt;</span><span> x</span><span> -&gt;</span><span> False
</span></dd>
<dt><span></span><span class="coqdoc-var">contradiction</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
<p>Apply a fact from the standard library:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Arith</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>[Loading ML file ring_plugin.cmxs (using legacy method) ... done]
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>), 0 &lt; 0 -&gt; </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, 0</span><span> &lt;</span><span> 0</span><span> -&gt;</span><span> A
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : 0</span><span> &lt;</span><span> 0
  ============================
  A
</span></dd>
<dt><span></span><span class="coqdoc-var">contradiction</span><span> (</span><span class="coqdoc-var">Nat.lt_irrefl</span><span> 0).</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.contradict">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">contradict</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></span><a class="headerlink" href="#coq:tacn.contradict" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the specified hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> and the goal in order to
prove that the hypothesis is false. For <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">contradict</span></span></span> <span><span><span class="pre">H</span></span></span></span></code>, the
current goal and context are transformed as shown.  (For brevity,
<code class="docutils literal notranslate"><span class="pre">⊢</span></code> is used to separate hypotheses from the goal; it is equivalent to the
dividing line shown in a context.):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">~A</span> <span class="pre">⊢</span> <span class="pre">B</span></code> becomes <code class="docutils literal notranslate"><span class="pre">⊢</span> <span class="pre">A</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">~A</span> <span class="pre">⊢</span> <span class="pre">~B</span></code> becomes <code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">B</span> <span class="pre">⊢</span> <span class="pre">A</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">A</span> <span class="pre">⊢</span> <span class="pre">B</span></code> becomes <code class="docutils literal notranslate"><span class="pre">⊢</span> <span class="pre">~A</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">A</span> <span class="pre">⊢</span> <span class="pre">~B</span></code> becomes <code class="docutils literal notranslate"><span class="pre">H:</span> <span class="pre">B</span> <span class="pre">⊢</span> <span class="pre">~A</span></code></p></li>
</ul>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.exfalso">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">exfalso</span></span></span></span></span><a class="headerlink" href="#coq:tacn.exfalso" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the “ex falso quodlibet” logical principle: an
elimination of False is performed on the current goal, and the user is
then required to prove that False is indeed provable in the current
context.</p>
</dd></dl>

</section>
<section id="classical-tactics">
<h2>Classical tactics<a class="headerlink" href="#classical-tactics" title="Permalink to this headline">¶</a></h2>
<p>In order to ease the proving process, when the <code class="docutils literal notranslate"><span class="pre">Classical</span></code> module is
loaded, a few more tactics are available. Make sure to load the module
using the <a class="reference internal" href="vernacular-commands.html#coq:cmd.Require-Import" title="Require Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span></code></a> command.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.classical_left">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">classical</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">left</span></span></span></span></span><a class="headerlink" href="#coq:tacn.classical_left" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.classical_right">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">classical</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">right</span></span></span></span></span><a class="headerlink" href="#coq:tacn.classical_right" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics are the analog of <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a>
but using classical logic. They can only be used for
disjunctions. Use <a class="reference internal" href="#coq:tacn.classical_left" title="classical_left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">classical_left</span></code></a> to prove the left part of the
disjunction with the assumption that the negation of right part holds.
Use <a class="reference internal" href="#coq:tacn.classical_right" title="classical_right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">classical_right</span></code></a> to prove the right part of the disjunction with
the assumption that the negation of left part holds.</p>
</dd></dl>

</section>
<section id="performance-oriented-tactic-variants">
<h2>Performance-oriented tactic variants<a class="headerlink" href="#performance-oriented-tactic-variants" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.exact_no_check">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">exact</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">no</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">check</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.exact_no_check" title="Permalink to this definition">¶</a></dt>
<dd><p>For advanced usage. Similar to <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, but as an optimization,
it skips checking that <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has the goal's type, relying on the kernel
check instead. See <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.change_no_check" title="change_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change_no_check</span></code></a> for more explanation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  False
</span></dd>
<dt><span>  </span><span class="coqdoc-var">exact_no_check</span><span> </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
The term &quot;I&quot; has type &quot;True&quot; while it is expected to have type &quot;False&quot;.
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.vm_cast_no_check">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">vm</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">cast</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">no</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">check</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.vm_cast_no_check" title="Permalink to this definition">¶</a></dt>
<dd><p>For advanced usage. Similar to <a class="reference internal" href="#coq:tacn.exact_no_check" title="exact_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact_no_check</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, but additionally
instructs the kernel to use <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.vm_compute" title="vm_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">vm_compute</span></code></a> to compare the
goal's type with the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>'s type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  False
</span></dd>
<dt><span>  </span><span class="coqdoc-var">vm_cast_no_check</span><span> </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
The term &quot;I&quot; has type &quot;True&quot; while it is expected to have type &quot;False&quot;.
</span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.native_cast_no_check">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">native</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">cast</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">no</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">check</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.native_cast_no_check" title="Permalink to this definition">¶</a></dt>
<dd><p>for advanced usage. similar to <a class="reference internal" href="#coq:tacn.exact_no_check" title="exact_no_check"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact_no_check</span></code></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, but additionally
instructs the kernel to use <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.native_compute" title="native_compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">native_compute</span></code></a> to compare the goal's
type with the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>'s type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  False
</span></dd>
<dt><span>  </span><span class="coqdoc-var">native_cast_no_check</span><span> </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Native compiler is disabled, falling back to VM conversion test.
[native-compiler-disabled,native-compiler,default]
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../proofs/writing-proofs/proof-mode.html" class="btn btn-neutral float-left" title="Proof mode" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../proofs/writing-proofs/equality.html" class="btn btn-neutral float-right" title="Reasoning with equalities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2021, Inria, CNRS and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  




  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Other versions</span>
      v: 8.18.0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://coq.github.io/doc/master/refman/">dev</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/current/refman/">stable</a></dd>
        
          <dd><a href="https://coq.github.io/doc/v8.18/refman/">8.18</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.17.1/refman/">8.17</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.16.1/refman/">8.16</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.15.2/refman/">8.15</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.14.1/refman/">8.14</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.13.2/refman/">8.13</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.12.2/refman/">8.12</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.11.2/refman/">8.11</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.10.2/refman/">8.10</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.9.1/refman/">8.9</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.8.2/refman/">8.8</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.7.2/refman/">8.7</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.6.1/refman/">8.6</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.5pl3/refman/">8.5</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.4pl6/refman/">8.4</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.3pl5/refman/">8.3</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.2pl3/refman/">8.2</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.1pl6/refman/">8.1</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.0/doc/">8.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://github.com/coq/coq/releases/download/V8.18.0/coq-8.18.0-reference-manual.pdf">PDF</a></dd>
        
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>