

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The SSReflect proof language &mdash; Coq 8.17.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Automatic solvers and programmable tactics" href="../proofs/automatic-tactics/index.html" />
    <link rel="prev" title="Reasoning with inductive types" href="../proofs/writing-proofs/reasoning-inductives.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.17.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption"><span class="caption-text">Specification language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/core/index.html">Core language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/core/basic.html">Basic notions and conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#syntax-and-lexical-conventions">Syntax and lexical conventions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#syntax-conventions">Syntax conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#lexical-conventions">Lexical conventions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#essential-vocabulary">Essential vocabulary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/basic.html#settings">Settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/basic.html#flags-options-and-tables">Flags, Options and Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sorts.html">Sorts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/assumptions.html">Functions and assumptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#functions-fun-and-function-types-forall">Functions (fun) and function types (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#function-application">Function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/assumptions.html#assumptions">Assumptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/definitions.html">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#top-level-definitions">Top-level definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/definitions.html#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/conversion.html">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#conversion">α-conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#delta-reduction-sect">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id4">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#id7">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/conversion.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/cic.html">Typing rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-terms">The terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#id6">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/variants.html">Variants and the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#id1">Variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/variants.html#private-matching-inductive-types">Private (matching) inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/variants.html#definition-by-cases-match">Definition by cases: match</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#defining-record-types">Defining record types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#constructing-records">Constructing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#accessing-fields-projections">Accessing fields (projections)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#settings-for-printing-records">Settings for printing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/records.html#compatibility-projections-and-match">Compatibility Projections and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/inductive.html">Inductive types and recursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#inductive-types">Inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#recursive-functions-fix">Recursive functions: fix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#top-level-recursive-functions">Top-level recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/inductive.html#theory-of-inductive-definitions">Theory of inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/core/inductive.html#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/coinductive.html">Coinductive types and corecursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#coinductive-types">Coinductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/coinductive.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#co-recursive-functions-cofix">Co-recursive functions: cofix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/coinductive.html#top-level-definitions-of-corecursive-functions">Top-level definitions of corecursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/sections.html">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/modules.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#using-modules">Using modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/core/modules.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#typing-modules">Typing Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/modules.html#controlling-the-scope-of-commands-with-locality-attributes">Controlling the scope of commands with locality attributes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/core/primitive.html">Primitive objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/core/primitive.html#primitive-arrays">Primitive Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#specifying-cumulativity">Specifying cumulativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#printing-universes">Printing universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#definitional-uip">Definitional UIP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/sprop.html#non-termination-with-uip">Non Termination with UIP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/sprop.html#issues-with-non-cumulativity">Issues with non-cumulativity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/evars.html">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#e-tactics-that-can-create-existential-variables">e* tactics that can create existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#automatic-resolution-of-existential-variables">Automatic resolution of existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#explicit-display-of-existential-instances-for-pretty-printing">Explicit display of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/evars.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments">Maximal and non-maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/match.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#conventions-about-unused-pattern-matching-variables">Conventions about unused pattern-matching variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/match.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/match.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and notation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#use-of-notations-for-printing">Use of notations for printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#enabling-and-disabling-notations">Enabling and disabling notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#syntax">Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes">Notation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-type-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#the-function-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#notation-scopes-used-in-the-standard-library-of-coq">Notation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#numbers-and-strings">Numbers and strings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#number-notations">Number notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/arguments-command.html">Setting properties of a function's arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#manual-declaration-of-implicit-arguments">Manual declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#binding-arguments-to-scopes">Binding arguments to scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#effects-of-arguments-on-unfolding">Effects of <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code> on unfolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/arguments-command.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#id1">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#reversible-coercions">Reversible Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#declaring-coercions">Declaring Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/implicit-coercions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#class-and-instance-declarations">Class and Instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#binding-classes">Binding classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#parameterized-instances">Parameterized Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/type-classes.html#summary-of-the-commands">Summary of the commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/extensions/canonical.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#declaration-of-canonical-structures">Declaration of canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/extensions/canonical.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/extensions/canonical.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vernacular-commands.html">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#load-paths">Load paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#extra-dependencies">Extra Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Proofs</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../proofs/writing-proofs/index.html">Basic proof writing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html">Proof mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-state">Proof State</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#entering-and-exiting-proof-mode">Entering and exiting proof mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-modes">Proof modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#managing-goals">Managing goals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#focusing-goals">Focusing goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#shelving-goals">Shelving goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#reordering-goals">Reordering goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proving-a-subgoal-as-a-separate-lemma-abstract">Proving a subgoal as a separate lemma: abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#how-diffs-are-calculated">How diffs are calculated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#show-proof-differences">&quot;Show Proof&quot; differences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-proof-mode">Controlling proof mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/proof-mode.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tactics.html">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#reserved-keywords">Reserved keywords</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="tactics.html#occurrence-clauses">Occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/equality.html">Reasoning with equalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#tactics-for-simple-equalities">Tactics for simple equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-leibniz-and-setoid-equality">Rewriting with Leibniz and setoid equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#rewriting-with-definitional-equality">Rewriting with definitional equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#applying-conversion-rules">Applying conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#fast-reduction-tactics-vm-compute-and-native-compute">Fast reduction tactics: vm_compute and native_compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/equality.html#computing-in-a-term-eval-and-eval">Computing in a term: eval and Eval</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/equality.html#controlling-reduction-strategies-and-the-conversion-algorithm">Controlling reduction strategies and the conversion algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html">Reasoning with inductive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#applying-constructors">Applying constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#case-analysis">Case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#induction">Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#equality-of-inductive-types">Equality of inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#helper-tactics">Helper tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#examples-of-dependent-destruction-dependent-induction">Examples of <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> / <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#a-larger-example">A larger example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gallina-extensions">Gallina extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/automatic-tactics/index.html">Automatic solvers and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/logic.html">Solvers for logic and equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/micromega.html">Micromega: solvers for arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/ring.html">ring and field: solvers for polynomial and rational equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: a solver for equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../proofs/automatic-tactics/auto.html">Programmable proof search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases">Hint databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hint-databases">Creating Hint databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#creating-hints">Creating Hints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../proofs/automatic-tactics/auto.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations">Rewriting and nonreflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-and-nonsymmetric-relations">Rewriting and nonsymmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-with-type-valued-relations">Rewriting with <code class="docutils literal notranslate"><span class="pre">Type</span></code> valued relations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#declaring-rewrite-relations">Declaring rewrite relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#usage">Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proofs/creating-tactics/index.html">Creating new tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ltac.html">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#values">Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#syntactic-values">Syntactic values</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#substitution">Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#local-definitions-let">Local definitions: let</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#function-construction-and-application">Function construction and application</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#tactics-in-terms">Tactics in terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#processing-multiple-goals">Processing multiple goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#branching-and-backtracking">Branching and backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#sequence">Sequence: ;</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#do-loop">Do loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#catching-errors-try">Catching errors: try</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#conditional-branching-tryif">Conditional branching: tryif</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#branching-with-backtracking">Branching with backtracking: +</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#local-application-of-tactics">Local application of tactics: [&gt; ... ]</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#first-tactic-to-succeed">First tactic to succeed</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#first-tactic-to-make-progress">First tactic to make progress: ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#detecting-progress">Detecting progress</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#success-and-failure">Success and failure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-success-assert-succeeds">Checking for success: assert_succeeds</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-failure-assert-fails">Checking for failure: assert_fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#soft-cut-once">Soft cut: once</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-for-a-single-success-exactly-once">Checking for a single success: exactly_once</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#manipulating-values">Manipulating values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#pattern-matching-on-terms-match">Pattern matching on terms: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#pattern-matching-on-goals-and-hypotheses-match-goal">Pattern matching on goals and hypotheses: match goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#computing-in-a-term-eval">Computing in a term: eval</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#getting-the-type-of-a-term">Getting the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#manipulating-untyped-terms-type-term">Manipulating untyped terms: type_term</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#counting-goals-numgoals">Counting goals: numgoals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#testing-boolean-expressions-guard">Testing boolean expressions: guard</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#checking-properties-of-terms">Checking properties of terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#timing">Timing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#timing-a-tactic-that-evaluates-to-a-term-time-constr">Timing a tactic that evaluates to a term: time_constr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#print-identity-tactic-idtac">Print/identity tactic: idtac</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#defining-ltac-symbols">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#tracing-execution">Tracing execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-definitions">Ltac2 Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#printing-ltac2-tactics">Printing Ltac2 tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#quotations">Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-over-goals">Match over goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#match-on-values">Match on values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#defining-tactics">Defining tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntactic-classes">Syntactic classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/coq-library.html">The Coq library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-prelude">The prelude</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../language/coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between Coq and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/libraries/writing.html">Writing Coq libraries and plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/libraries/writing.html#deprecating-library-objects-or-tactics">Deprecating library objects or tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/utilities.html">Building Coq Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coq-configuration-basics">Coq configuration basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installing-coq-and-coq-packages-with-opam">Installing Coq and Coq packages with opam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#setup-for-working-on-your-own-projects">Setup for working on your own projects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#building-a-project-with-coqproject-overview">Building a project with _CoqProject (overview)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#logical-paths-and-the-load-path">Logical paths and the load path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#modifying-multiple-interdependent-projects-at-the-same-time">Modifying multiple interdependent projects at the same time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#installed-and-uninstalled-packages">Installed and uninstalled packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#upgrading-to-a-new-version-of-coq">Upgrading to a new version of Coq</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile-details">Building a Coq project with coq_makefile (details)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/utilities.html#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a Coq project with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#coqdep-computing-module-dependencies">coqdep: Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#split-compilation-of-native-computation-files">Split compilation of native computation files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coq-commands.html">Coq commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#command-parameters">Command parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#coqrc-start-up-script"><code class="docutils literal notranslate"><span class="pre">coqrc</span></code> start up script</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#environment-variables">Environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../using/tools/coqdoc.html">Documenting Coq files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#coq-material-inside-documentation">Coq material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../practical-tools/coqide.html">CoqIDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#running-coq-scripts">Running Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#asynchronous-mode">Asynchronous mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#commands-and-templates">Commands and templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#customizations">Customizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#preferences">Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#key-bindings">Key bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../practical-tools/coqide.html#debugger">Debugger</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#breakpoints">Breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#call-stack-and-variables">Call Stack and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../practical-tools/coqide.html#supported-use-cases">Supported use cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../addendum/parallel-proof-processing.html#id3">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-17">Version 8.17</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-0">Changes in 8.17.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-17-1">Changes in 8.17.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-16">Version 8.16</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id154">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-0">Changes in 8.16.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-16-1">Changes in 8.16.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-15">Version 8.15</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id316">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-0">Changes in 8.15.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-1">Changes in 8.15.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-15-2">Changes in 8.15.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-14">Version 8.14</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id544">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-0">Changes in 8.14.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-14-1">Changes in 8.14.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-13">Version 8.13</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id740">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-beta1">Changes in 8.13+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-0">Changes in 8.13.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-1">Changes in 8.13.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-13-2">Changes in 8.13.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-12">Version 8.12</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id904">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-beta1">Changes in 8.12+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-0">Changes in 8.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-1">Changes in 8.12.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-12-2">Changes in 8.12.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1210">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-11-2">Changes in 8.11.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1348">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1495">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1497">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1498">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1499">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1500">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1501">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1502">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1504">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1505">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1506">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1507">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1508">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#id1509">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-attrindex.html">Attribute index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../genindex.html">General index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../proofs/writing-proofs/index.html">Basic proof writing</a> &raquo;</li>
        
      <li>The <span class="smallcaps">SSReflect</span> proof language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/ssreflect-proof-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<div class="section" id="the-ssr-proof-language">
<span id="thessreflectprooflanguage"></span><h1>The <span class="smallcaps">SSReflect</span> proof language<a class="headerlink" href="#the-ssr-proof-language" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p>Georges Gonthier, Assia Mahboubi, Enrico Tassi</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes a set of tactics known as <span class="smallcaps">SSReflect</span> originally
designed to provide support for the so-called <em>small scale reflection</em>
proof methodology. Despite the original purpose, this set of tactics is
of general interest and is available in Coq starting from version 8.7.</p>
<p><span class="smallcaps">SSReflect</span> was developed independently of the tactics described in
Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Indeed the scope of the tactics part of <span class="smallcaps">SSReflect</span> largely
overlaps with the standard set of tactics. Eventually the overlap will
be reduced in future releases of Coq.</p>
<p>Proofs written in <span class="smallcaps">SSReflect</span> typically look quite different from the
ones written using only tactics as per Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. We try to
summarise here the most “visible” ones in order to help the reader
already accustomed to the tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> to read
this chapter.</p>
<p>The first difference between the tactics described in this chapter and the
tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> is the way hypotheses are managed
(we call this <em>bookkeeping</em>). In Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> the most common
approach is to avoid moving explicitly hypotheses back and forth between the
context and the conclusion of the goal. On the contrary, in <span class="smallcaps">SSReflect</span> all
bookkeeping is performed on the conclusion of the goal, using for that
purpose a couple of syntactic constructions behaving similar to tacticals
(and often named as such in this chapter). The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves hypotheses
from the context to the conclusion, while <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> moves hypotheses from the
conclusion to the context, and <code class="docutils literal notranslate"><span class="pre">in</span></code> moves back and forth a hypothesis from the
context to the conclusion for the time of applying an action to it.</p>
<p>While naming hypotheses is commonly done by means of an <code class="docutils literal notranslate"><span class="pre">as</span></code> clause in the
basic model of Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is here to <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> that this task is
devoted. Tactics frequently leave new assumptions in the conclusion, and are
often followed by <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> to explicitly name them. While generalizing the
goal is normally not explicitly needed in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is an
explicit operation performed by <code class="docutils literal notranslate"><span class="pre">:</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a></p>
</div>
<p>Besides the difference of bookkeeping model, this chapter includes
specific tactics that have no explicit counterpart in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>
such as tactics to mix forward steps and generalizations as
<a class="reference internal" href="#coq:tacn.generally-have" title="generally have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span></code></a> or <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>.</p>
<p><span class="smallcaps">SSReflect</span> adopts the point of view that rewriting, definition
expansion and partial evaluation participate all to a same concept of
rewriting a goal in a larger sense. As such, all these functionalities
are provided by the <a class="reference internal" href="#coq:tacn.rewrite-(ssreflect)" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic.</p>
<p><span class="smallcaps">SSReflect</span> includes a little language of patterns to select subterms in
tactics or tacticals where it matters. Its most notable application is
in the <a class="reference internal" href="#coq:tacn.rewrite-(ssreflect)" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic, where patterns are
used to specify where the rewriting step has to take place.</p>
<p>Finally, <span class="smallcaps">SSReflect</span> supports so-called reflection steps, typically
allowing to switch back and forth between the computational view and
logical view of a concept.</p>
<p>To conclude, it is worth mentioning that <span class="smallcaps">SSReflect</span> tactics can be mixed
with non-<span class="smallcaps">SSReflect</span> tactics in the same proof, or in the same Ltac
expression. The few exceptions to this statement are described in
section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>.</p>
<div class="section" id="acknowledgments">
<h3>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h3>
<p>The authors would like to thank Frédéric Blanqui, François Pottier and
Laurence Rideau for their comments and suggestions.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="getting-started">
<h3>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>To be available, the tactics presented in this manual need the
following minimal set of libraries to be loaded: <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>,
<code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>.
Moreover, these tactics come with a methodology
specific to the authors of <span class="smallcaps">SSReflect</span> and which requires a few options
to be set in a different way than in their default way. All in all,
this corresponds to working in the following context:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>[Loading ML file ssrmatching_plugin.cmxs (using legacy method) ... done]
[Loading ML file ssreflect_plugin.cmxs (using legacy method) ... done]
Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../language/extensions/implicit-arguments.html#coq:flag.Implicit-Arguments" title="Implicit Arguments"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Implicit</span> <span class="pre">Arguments</span></code></a>, <a class="reference internal" href="../language/extensions/implicit-arguments.html#coq:flag.Strict-Implicit" title="Strict Implicit"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Strict</span> <span class="pre">Implicit</span></code></a>,
<a class="reference internal" href="../language/extensions/implicit-arguments.html#coq:flag.Printing-Implicit-Defensive" title="Printing Implicit Defensive"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Implicit</span> <span class="pre">Defensive</span></code></a></p>
</div>
</div>
<div class="section" id="compatibility-issues">
<span id="compatibility-issues-ssr"></span><h3>Compatibility issues<a class="headerlink" href="#compatibility-issues" title="Permalink to this headline">¶</a></h3>
<p>Requiring the above modules creates an environment that is mostly
compatible with the rest of Coq, up to a few discrepancies.</p>
<ul>
<li><p>New keywords (<code class="docutils literal notranslate"><span class="pre">is</span></code>) might clash with variable, constant, tactic or
tactical names, or with quasi-keywords in tactic or
notation commands.</p></li>
<li><p>New tactic(al)s names (<a class="reference internal" href="#coq:tacn.last" title="last"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">last</span></code></a>, <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a>, <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a>, <a class="reference internal" href="#coq:tacn.suffices" title="suffices"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suffices</span></code></a>,
<a class="reference internal" href="#coq:tacn.suff" title="suff"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suff</span></code></a>, <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>, <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>, <a class="reference internal" href="#coq:tacn.congr" title="congr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congr</span></code></a>, <a class="reference internal" href="#coq:tacn.unlock" title="unlock"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unlock</span></code></a>)
might clash with user tactic names.</p></li>
<li><p>Identifiers with both leading and trailing <code class="docutils literal notranslate"><span class="pre">_</span></code>, such as <code class="docutils literal notranslate"><span class="pre">_x_</span></code>, are
reserved by <span class="smallcaps">SSReflect</span> and cannot appear in scripts.</p></li>
<li><p>The extensions to the <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic are partly incompatible with those
available in current versions of Coq; in particular, <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span>
<span class="pre">(type</span> <span class="pre">of</span> <span class="pre">k)</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span> <span class="pre">*</span></code> or any other variant of <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>
will not work, and the <span class="smallcaps">SSReflect</span> syntax and semantics for occurrence selection
and rule chaining are different. Use an explicit rewrite direction
(<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">&lt;-</span> <span class="pre">…</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-&gt;</span> <span class="pre">…</span></code>) to access the Coq rewrite tactic.</p></li>
<li><p>New symbols (<code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>) might clash with adjacent
existing symbols.
This can be avoided by inserting white spaces.</p></li>
<li><p>New constant and theorem names might clash with the user theory.
This can be avoided by not importing all of <span class="smallcaps">SSReflect</span>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect.SsrSyntax</span><span>.</span><span>
</span></dt></dl>
</div>
<p>Note that the full
syntax of <span class="smallcaps">SSReflect</span>’s rewrite and reserved identifiers are enabled
only if the ssreflect module has been required and if <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code> has
been imported. Thus a file that requires (without importing) <code class="docutils literal notranslate"><span class="pre">ssreflect</span></code>
and imports <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code> can be required and imported without
automatically enabling <span class="smallcaps">SSReflect</span>’s extended rewrite syntax and
reserved identifiers.</p>
</li>
<li><p>Some user notations (in particular, defining an infix <code class="docutils literal notranslate"><span class="pre">;</span></code>) might
interfere with the &quot;open term&quot;, parenthesis-free syntax of tactics
such as <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a>, <a class="reference internal" href="#coq:tacn.set-(ssreflect)" title="set (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span> <span class="pre">(ssreflect)</span></code></a> and <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a>.</p></li>
<li><p>The generalization of <code class="docutils literal notranslate"><span class="pre">if</span></code> statements to non-Boolean conditions is turned off
by <span class="smallcaps">SSReflect</span>, because it is mostly subsumed by Coercion to <code class="docutils literal notranslate"><span class="pre">bool</span></code> of the
<code class="docutils literal notranslate"><span class="pre">sumXXX</span></code> types (declared in <code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code>) and the
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">if</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">is</span></span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span><span class="pre">then</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">else</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> construct
(see <a class="reference internal" href="#pattern-conditional-ssr"><span class="std std-ref">Pattern conditional</span></a>).  To use the
generalized form, turn off the <span class="smallcaps">SSReflect</span> Boolean <code class="docutils literal notranslate"><span class="pre">if</span></code> notation using the command:
<code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope</span></code>.</p></li>
<li><p>The following flags can be unset to make <span class="smallcaps">SSReflect</span> more compatible with
parts of Coq.</p></li>
</ul>
<dl class="coq flag">
<dt id="coq:flag.SsrRewrite">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>SsrRewrite</span></span></span></code><a class="headerlink" href="#coq:flag.SsrRewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the incompatible rewrite syntax is enabled (the default).
Disabling the <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> makes the syntax compatible with other parts of Coq.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.SsrIdents">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>SsrIdents</span></span></span></code><a class="headerlink" href="#coq:flag.SsrIdents" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether tactics can refer to <span class="smallcaps">SSReflect</span>-generated variables that are
in the form _xxx_.  Scripts with explicit references to such variables
are fragile; they are prone to failure if the proof is later modified or
if the details of variable name generation change in future releases of Coq.</p>
<p>The default is on, which gives an error message when the user tries to
create such identifiers.  Disabling the <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> generates a warning instead,
increasing compatibility with other parts of Coq.</p>
</dd></dl>

</div>
</div>
<div class="section" id="gallina-extensions">
<h2>Gallina extensions<a class="headerlink" href="#gallina-extensions" title="Permalink to this headline">¶</a></h2>
<p>Small-scale reflection makes an extensive use of the programming
subset of Gallina, Coq’s logical specification language. This subset
is quite suited to the description of functions on representations,
because it closely follows the well-established design of the ML
programming language. The <span class="smallcaps">SSReflect</span> extension provides three additions
to Gallina, for pattern assignment, pattern testing, and polymorphism;
these mitigate minor but annoying discrepancies between Gallina and
ML.</p>
<div class="section" id="pattern-assignment">
<h3>Pattern assignment<a class="headerlink" href="#pattern-assignment" title="Permalink to this headline">¶</a></h3>
<p>The <span class="smallcaps">SSReflect</span> extension provides the following construct for
irrefutable pattern matching, that is, destructuring assignment:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let:</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Note the colon <code class="docutils literal notranslate"><span class="pre">:</span></code> after the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword, which avoids any ambiguity
with a function definition or Coq’s basic destructuring let. The <code class="docutils literal notranslate"><span class="pre">let:</span></code>
construct differs from the latter as follows.</p>
<ul class="simple">
<li><p>The pattern can be nested (deep pattern matching); in particular,
this allows expression of the form:</p></li>
</ul>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">exist</span><span> (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">p_xy</span><span> := </span><span class="coqdoc-var">Hp</span><span> </span><span class="coqdoc-tactic">in</span><span> … .</span><span>
</span></span></div>
<ul>
<li><p>The destructured constructor is explicitly given in the pattern, and
is used for type inference.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-keyword">let</span><span>: (</span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span>) := </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>f is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">f</span><span>.</span><span>
</span></dt><dd><span>f
     : nat</span><span> *</span><span> nat</span><span> -&gt;</span><span> nat
</span></dd>
</dl>
</div>
<p>Using <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span><span class="operator"><span class="pre">:</span></span></code>, Coq infers a type for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>,
whereas with a usual <code class="docutils literal notranslate"><span class="pre">let</span></code> the same term requires an extra type
annotation in order to type check.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span>) := </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Cannot infer a type for this expression.
</span></dd>
</dl>
</div>
</div>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">let:</span></code> construct is just (more legible) notation for the primitive
Gallina expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">match</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">end</span></span></span></span></code>.</p>
<p>The <span class="smallcaps">SSReflect</span> destructuring assignment supports all the dependent
match annotations; the full syntax is</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let:</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>as</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>in</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>return</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>in</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>where the second <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are <em>types</em>.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">as</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code> keywords are both present, then <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is bound
in both the second <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>; variables
in the optional type <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the second term, and
other variables in the first  <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the third
<a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, however.</p>
</div>
<div class="section" id="pattern-conditional">
<span id="pattern-conditional-ssr"></span><h3>Pattern conditional<a class="headerlink" href="#pattern-conditional" title="Permalink to this headline">¶</a></h3>
<p>The following construct can be used for a refutable pattern matching,
that is, pattern testing:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>if</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>is</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>then</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>else</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Although this construct is not strictly ML (it does exist in variants
such as the pattern calculus or the ρ-calculus), it turns out to be
very convenient for writing functions on representations, because most
such functions manipulate simple data types such as Peano integers,
options, lists, or binary trees, and the pattern conditional above is
almost always the right construct for analyzing such simple types. For
example, the null and all list function(al)s can be defined as follows:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><div class="coqtop literal-block coqtop-hidden docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
</div>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">d</span><span>: </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>d is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">false</span><span>.</span><span>
</span></dt><dd><span>null is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd><span>a is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">all</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">x</span><span> &amp;&amp; </span><span class="coqdoc-var">all</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">true</span><span>.</span><span>
</span></dt><dd><span>all is defined
all is recursively defined (guarded on 1st argument)
</span></dd>
</dl>
</div>
</div>
<p>The pattern conditional also provides a notation for destructuring
assignment with a refutable pattern, adapted to the pure functional
setting of Gallina, which lacks a <code class="docutils literal notranslate"><span class="pre">Match_Failure</span></code> exception.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if…is</span></code> construct is just (more legible) notation
for the primitive Gallina expression
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">match</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="pre">|</span> <span><span><span class="pre">_</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">end</span></span></span></span></code>.</p>
<p>Similarly, it will always be displayed as the expansion of this form
in terms of primitive match expressions (where the default expression
may be replicated).</p>
<p>Explicit pattern testing also largely subsumes the generalization of
the <code class="docutils literal notranslate"><span class="pre">if</span></code> construct to all binary data types; compare
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">if</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">inl</span></span></span> <span><span><span class="pre">_</span></span></span> <span><span><span class="pre">then</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">else</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">if</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">then</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">else</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>The latter appears to be marginally shorter, but it is quite
ambiguous, and indeed often requires an explicit annotation
<code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">:</span> <span class="pre">{_}</span> <span class="pre">+</span> <span class="pre">{_})</span></code> to type check, which evens the character count.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> restricts by default the condition of a plain <code class="docutils literal notranslate"><span class="pre">if</span></code>
construct to the standard <code class="docutils literal notranslate"><span class="pre">bool</span></code> type; this avoids spurious type
annotations.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">orb</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> := </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">b2</span><span>.</span><span>
</span></dt><dd><span>orb is defined
</span></dd>
</dl>
</div>
</div>
<p>As pointed out in Section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>,
this restriction can be removed with
the command:</p>
<p><code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope.</span></code></p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if-is-then-else</span></code>
construct supports
the dependent match annotations:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>if</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>is</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>as</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>return</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>then</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>else</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>As in <code class="docutils literal notranslate"><span class="pre">let:</span></code>, the variable <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> (and those in the type pattern)
are bound in the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>; <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is also bound in the
third <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> (but not in the fourth <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>), while the
variables in the first <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the third
<a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>Another variant allows to treat the <code class="docutils literal notranslate"><span class="pre">else</span></code> case first:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>if</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>isn</span>'<span>t</span></span> <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span><span>then</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>else</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Note that <a class="reference internal" href="../language/core/variants.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> eventually binds variables in the third
<a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and not in the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</div>
<div class="section" id="parametric-polymorphism">
<span id="parametric-polymorphism-ssr"></span><h3>Parametric polymorphism<a class="headerlink" href="#parametric-polymorphism" title="Permalink to this headline">¶</a></h3>
<p>Unlike ML, polymorphism in core Gallina is explicit: the type
parameters of polymorphic functions must be declared explicitly, and
supplied at each point of use. However, Coq provides two features to
suppress redundant parameters.</p>
<ul class="simple">
<li><p>Sections are used to provide (possibly implicit) parameters for a
set of definitions.</p></li>
<li><p>Implicit arguments declarations are used to tell Coq to use type
inference to deduce some parameters from the context at each point of
call.</p></li>
</ul>
<p>The combination of these features provides a fairly good emulation of
ML-style polymorphism, but unfortunately this emulation breaks down
for higher-order programming. Implicit arguments are indeed not
inferred at all points of use, but only at points of call, leading to
expressions such as</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>T is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">null</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>null is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">all</span><span> : (</span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>all is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">all_null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span>) := </span><span class="coqdoc-var">all</span><span> (&#64;</span><span class="coqdoc-var">null</span><span> </span><span class="coqdoc-var">T</span><span>) </span><span class="coqdoc-var">s</span><span>.</span><span>
</span></dt><dd><span>all_null is defined
</span></dd>
</dl>
</div>
</div>
<p>Unfortunately, such higher-order expressions are quite frequent in
representation functions, especially those that use Coq's
<code class="docutils literal notranslate"><span class="pre">Structures</span></code> to emulate Haskell typeclasses.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> provides a variant of Coq’s implicit argument
declaration, which causes Coq to fill in some implicit parameters at
each point of use; e.g., the above definition can be written:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>T is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">null</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>null is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">all</span><span> : (</span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>all is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Prenex</span><span> </span><span class="coqdoc-var">Implicits</span><span> </span><span class="coqdoc-var">null</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">all_null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span>) := </span><span class="coqdoc-var">all</span><span> </span><span class="coqdoc-var">null</span><span> </span><span class="coqdoc-var">s</span><span>.</span><span>
</span></dt><dd><span>all_null is defined
</span></dd>
</dl>
</div>
</div>
<p>Better yet, it can be omitted entirely, since <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">all_null</span></span> <span class="name"><span class="pre">s</span></span></code> isn’t much of
an improvement over <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">all</span></span> <span class="name"><span class="pre">null</span></span> <span class="name"><span class="pre">s</span></span></code>.</p>
<p>The syntax of the new declaration is</p>
<dl class="coq cmd">
<dt id="coq:cmd.Prenex-Implicits">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Prenex</span></span> <span><span>Implicits</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident<sub>i</sub></span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.Prenex-Implicits" title="Permalink to this definition">¶</a></dt>
<dd><p>This command checks that each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code> is the name of a functional
constant, whose implicit arguments are prenex, i.e., the first
<span class="math notranslate nohighlight">\(n_i &gt; 0\)</span> arguments of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code> are implicit; then it assigns
<code class="docutils literal notranslate"><span class="pre">Maximal</span> <span class="pre">Implicit</span></code> status to these arguments.</p>
<p>As these prenex implicit arguments are ubiquitous and have often large
display strings, it is strongly recommended to change the default
display settings of Coq so that they are not printed (except after
a <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command). All <span class="smallcaps">SSReflect</span> library files thus start
with the incantation</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></span></div>
</dd></dl>

</div>
<div class="section" id="anonymous-arguments">
<h3>Anonymous arguments<a class="headerlink" href="#anonymous-arguments" title="Permalink to this headline">¶</a></h3>
<p>When in a definition, the type of a certain argument is mandatory, but
not its name, one usually uses “arrow” abstractions for prenex
arguments, or the <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> syntax for inner arguments. In <span class="smallcaps">SSReflect</span>,
the latter can be replaced by the open syntax <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">term</span></code> or
(equivalently) <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">term</span></code>, which are both syntactically equivalent to a
<code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> expression. This feature almost behaves as the
following extension of the binder syntax:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-binder"></span></span><span class="notation"><a class="reference internal" href="../language/core/assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>&amp;</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>of</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Caveat: <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">T</span></code> abbreviations have to appear at the end
of a binder list. For instance, the usual two-constructor polymorphic
type list, i.e., the one of the standard <code class="docutils literal notranslate"><span class="pre">List</span></code> library, can be
defined by the following declaration:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">A</span><span> &amp; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="wildcards">
<h3>Wildcards<a class="headerlink" href="#wildcards" title="Permalink to this headline">¶</a></h3>
<p>The terms passed as arguments to <span class="smallcaps">SSReflect</span> tactics can contain
<em>holes</em>, materialized by wildcards <code class="docutils literal notranslate"><span class="pre">_</span></code>. Since <span class="smallcaps">SSReflect</span> allows a more
powerful form of type inference for these arguments, it enhances the
possibilities of using such wildcards. These holes are in particular
used as a convenient shorthand for abstractions, especially in local
definitions or type expressions.</p>
<p>Wildcards may be interpreted as abstractions (see for example Sections
<a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a> and <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>), or their content can be
inferred from the whole context of the goal (see for example Section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>).</p>
</div>
<div class="section" id="definitions">
<span id="definitions-ssr"></span><h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.pose-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>pose</span></span></span></code><a class="headerlink" href="#coq:tacn.pose-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic allows to add a defined constant to a proof context.
<span class="smallcaps">SSReflect</span> generalizes this tactic in several ways. In particular, the
<span class="smallcaps">SSReflect</span> <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic supports <em>open syntax</em>: the body of the
definition does not need surrounding parentheses. For instance:</p>
</dd></dl>

<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></span></div>
<p>is a valid tactic expression.</p>
<p>The <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic is also improved for the local definition of higher-order terms.
Local definitions of functions can use the same syntax as
global ones.
For example, the tactic <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> supports parameters:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  f := </span><span class="ansi-bold">fun</span><span> x y : nat =&gt; x</span><span> +</span><span> y : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>The <span class="smallcaps">SSReflect</span> <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic also supports (co)fixpoints, by providing
the local counterpart of the <code class="docutils literal notranslate"><span class="pre">Fixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">CoFixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code>
constructs. For instance, the following tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-keyword">fix</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">x</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-keyword">else</span><span> 0.</span><span>
</span></span></div>
<p>defines a local fixpoint <code class="docutils literal notranslate"><span class="pre">f</span></code>, which mimics the standard plus operation
on natural numbers.</p>
<p>Similarly, local cofixpoints can be defined by a tactic of the form:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-keyword">cofix</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">arg</span><span> : </span><span class="coqdoc-var">T</span><span>) := … .</span><span>
</span></span></div>
<p>The possibility to include wildcards in the body of the definitions
offers a smooth way of defining local abstractions. The type of
“holes” is guessed by type inference, and the holes are abstracted.
For instance the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-var">_</span><span> + 1.</span><span>
</span></span></div>
<p>is shorthand for:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">n</span><span> + 1.</span><span>
</span></span></div>
<p>When the local definition of a function involves both arguments and
holes, hole abstractions appear first. For instance, the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></span></div>
<p>is shorthand for:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></span></div>
<p>The interaction of the <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic with the interpretation of implicit
arguments results in a powerful and concise syntax for local
definitions involving dependent types. For instance, the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> := (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>).</span><span>
</span></span></div>
<p>adds to the context the local definition:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">Tx</span><span> </span><span class="coqdoc-var">Ty</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">Tx</span><span>) (</span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Ty</span><span>) := (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>).</span><span>
</span></span></div>
<p>The generalization of wildcards makes the use of the <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic
resemble ML-like definitions of polymorphic functions.</p>
</div>
<div class="section" id="abbreviations">
<span id="abbreviations-ssr"></span><h3>Abbreviations<a class="headerlink" href="#abbreviations" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.set-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>set</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.set-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>The <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">set</span></code> tactic performs abbreviations; it introduces a
defined constant for a subterm appearing in the goal and/or in the
context.</p>
<p><span class="smallcaps">SSReflect</span> extends the <a class="reference internal" href="tactics.html#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a> tactic by supplying:</p>
<ul class="simple">
<li><p>an open syntax, similarly to the <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a> tactic;</p></li>
<li><p>a more aggressive matching algorithm;</p></li>
<li><p>an improved interpretation of wildcards, taking advantage of the
matching algorithm;</p></li>
<li><p>an improved occurrence selection mechanism allowing to abstract only
selected occurrences of a term.</p></li>
</ul>
</dd></dl>

<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-occ_switch"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>+</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>-</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">*</span></span> }</span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>where:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a fresh identifier chosen by the user.</p></li>
<li><p><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> 1 is an optional type annotation. The type annotation <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> 1
can be given in open syntax (no surrounding parentheses). If no
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (described hereafter) is present,
it is also the case for the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
On the other hand, in the presence of <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, parentheses
surrounding the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are mandatory.</p></li>
<li><p>In the occurrence switch <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, if the first element of the
list is a natural, this element should be a number, and not an Ltac
variable. The empty list <code class="docutils literal notranslate"><span class="pre">{}</span></code> is not interpreted as a valid occurrence
switch; it is rather used as a flag to signal the intent of the user to
clear the name following it (see <a class="reference internal" href="#ssr-rewrite-occ-switch"><span class="std std-ref">Occurrence switches and redex switches</span></a> and
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>).</p></li>
</ul>
<p>The tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>f is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> :  </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  ============================
  f x</span><span> +</span><span> f x</span><span> =</span><span> f x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  t := f x : nat
  ============================
  t</span><span> +</span><span> t</span><span> =</span><span> t
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := {2}(</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  t := f x : nat
  ============================
  f x</span><span> +</span><span> t</span><span> =</span><span> f x
</span></dd>
</dl>
</div>
</div>
<p>The type annotation may contain wildcards, which will be filled
with appropriate values by the matching process.</p>
<p>The tactic first tries to find a subterm of the goal matching
the second <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
(and its type), and stops at the first subterm it finds. Then
the occurrences of this subterm selected by the optional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
are replaced by <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and a definition <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
is added to the
context. If no <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> is present, then all the occurrences are
abstracted.</p>
<div class="section" id="matching">
<h4>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h4>
<p>The matching algorithm compares a pattern <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> with a subterm of the
goal by comparing their heads and then pairwise unifying their
arguments (modulo conversion). Head symbols match under the following
conditions.</p>
<ul class="simple">
<li><p>If the head of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is a constant, then it should be syntactically
equal to the head symbol of the subterm.</p></li>
<li><p>If this head is a projection of a canonical structure, then
canonical structure equations are used for the matching.</p></li>
<li><p>If the head of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is <em>not</em> a constant, the subterm should have the
same structure (λ abstraction, <code class="docutils literal notranslate"><span class="pre">let…in</span></code> structure, etc.).</p></li>
<li><p>If the head of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is a hole, the subterm should have at least as
many arguments as <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) :  </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  t := </span><span class="ansi-fg-light-magenta">Nat</span><span>.</span><span class="ansi-fg-light-green">add</span><span> x : nat</span><span> -&gt;</span><span> nat
  ============================
  t y</span><span> =</span><span> z
</span></dd>
</dl>
</div>
</div>
<ul>
<li><p>In the special case where <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is of the form
<code class="docutils literal notranslate"><span class="pre">(let</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">t0</span> <span class="pre">in</span> <span class="pre">f)</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn</span></code> , then the pattern <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is treated
as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn)</span></code>. For each
subterm in the goal having the form <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">um)</span></code> with m ≥ n, the
matching algorithm successively tries to find the largest partial
application <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">uj)</span></code> convertible to the head <code class="docutils literal notranslate"><span class="pre">t0</span></code> of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> 1) 2 3 = 6.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  (</span><span class="ansi-bold">let</span><span> f := </span><span class="ansi-bold">fun</span><span> x y z : nat =&gt; x</span><span> +</span><span> y</span><span> +</span><span> z </span><span class="ansi-bold">in</span><span> f 1) 2 3</span><span> =</span><span> 6
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">g</span><span>) 2.</span><span>
</span></dt><dd><span>1 goal
  
  t := unkeyed (</span><span class="ansi-bold">fun</span><span> y z : nat =&gt; S y</span><span> +</span><span> z) 2 : nat</span><span> -&gt;</span><span> nat
  ============================
  t 3</span><span> =</span><span> 6
</span></dd>
</dl>
</div>
</div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">unkeyed</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> is a shorthand for
the degenerate term <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">x</span></code>.</p>
</li>
</ul>
<p>Moreover:</p>
<ul>
<li><p>Multiple holes in <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are treated as independent placeholders.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  t := x</span><span> +</span><span> y : nat
  ============================
  t</span><span> =</span><span> z
</span></dd>
</dl>
</div>
</div>
</li>
<li><p>The type of the subterm matched should fit the type (possibly casted
by some type annotations) of the pattern <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p></li>
<li><p>The replacement of the subterm found by the instantiated pattern
should not capture variables. In the example above, <code class="docutils literal notranslate"><span class="pre">x</span></code> is bound
and should not be captured.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> + 1 = 0.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> +</span><span> 1</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> + 1.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
The pattern (_</span><span> +</span><span> 1) did not match and has holes. Did you mean pose?
</span></dd>
</dl>
</div>
</div>
</li>
<li><p>Typeclass inference should fill in any residual hole, but matching
should never assign a value to a global existential variable.</p></li>
</ul>
</div>
<div class="section" id="occurrence-selection">
<span id="occurrence-selection-ssr"></span><h4>Occurrence selection<a class="headerlink" href="#occurrence-selection" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> provides a generic syntax for the selection of occurrences
by their position indexes. These <em>occurrence switches</em> are shared by
all <span class="smallcaps">SSReflect</span> tactics that require control on subterm selection like
rewriting, generalization, …</p>
<p>An <em>occurrence switch</em> can be:</p>
<ul>
<li><p>A list of natural numbers <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>
of occurrences affected by the tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>f is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 8 = </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 2.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  f 2</span><span> +</span><span> f 8</span><span> =</span><span> f 2</span><span> +</span><span> f 2
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">x</span><span> := {+1 3}(</span><span class="coqdoc-var">f</span><span> 2).</span><span>
</span></dt><dd><span>1 goal
  
  x := f 2 : nat
  ============================
  x</span><span> +</span><span> f 8</span><span> =</span><span> f 2</span><span> +</span><span> x
</span></dd>
</dl>
</div>
</div>
<p>Notice that some occurrences of a given term may be
hidden to the user, for example because of a notation. Setting the
<a class="reference internal" href="vernacular-commands.html#coq:flag.Printing-All" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag causes these hidden occurrences to
be shown when the term is displayed.  This setting
should be used to find the correct coding of the occurrences to be
selected <a class="footnote-reference brackets" href="#id42" id="id1">11</a>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;a &lt; b&quot;:= (</span><span class="coqdoc-var">le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">a</span><span>) </span><span class="coqdoc-var">b</span><span>).</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> &lt;</span><span> y</span><span> -&gt;</span><span> S x</span><span> &lt;</span><span> S y
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  t := S x : nat
  ============================
  t</span><span> &lt;=</span><span> y</span><span> -&gt;</span><span> t</span><span> &lt;</span><span> S y
</span></dd>
</dl>
</div>
</div>
</li>
<li><p>A list of natural numbers <code class="docutils literal notranslate"><span class="pre">{n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>.
This is equivalent to the previous <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>, but the list
should start with a number, and not with an Ltac variable.</p></li>
<li><p>A list <code class="docutils literal notranslate"><span class="pre">{-</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code> of occurrences <em>not</em> to be affected by the
tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>f is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 8 = </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 2.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  f 2</span><span> +</span><span> f 8</span><span> =</span><span> f 2</span><span> +</span><span> f 2
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">x</span><span> := {-2}(</span><span class="coqdoc-var">f</span><span> 2).</span><span>
</span></dt><dd><span>1 goal
  
  x := f 2 : nat
  ============================
  x</span><span> +</span><span> f 8</span><span> =</span><span> f 2</span><span> +</span><span> x
</span></dd>
</dl>
</div>
</div>
<p>Note that, in this goal, it behaves like <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{1</span> <span class="pre">3}(f</span> <span class="pre">2).</span></code></p>
</li>
<li><p>In particular, the switch <code class="docutils literal notranslate"><span class="pre">{+}</span></code> selects <em>all</em> the occurrences. This
switch is useful to turn off the default behavior of a tactic that
automatically clears some assumptions (see Section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for
instance).</p></li>
<li><p>The switch <code class="docutils literal notranslate"><span class="pre">{-}</span></code> imposes that <em>no</em> occurrences of the term should be
affected by the tactic. The tactic: <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{-}(f</span> <span class="pre">2).</span></code> leaves the goal
unchanged and adds the definition <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">f</span> <span class="pre">2</span></code> to the context. This kind
of tactic may be used to take advantage of the power of the matching
algorithm in a local definition, instead of copying large terms by
hand.</p></li>
</ul>
<p>It is important to remember that matching <em>precedes</em> occurrence
selection.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> x</span><span> +</span><span> y</span><span> +</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">a</span><span> := {2}(</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  a := x</span><span> +</span><span> y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> a</span><span> +</span><span> z
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<p>Hence, in the following goal, the same tactic fails since there is
only one occurrence of the selected term.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>) + (</span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">z</span><span>) = </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> y</span><span> +</span><span> (z</span><span> +</span><span> z)</span><span> =</span><span> z</span><span> +</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">a</span><span> := {2}(</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Only 1 &lt; 2 occurrence of (x</span><span> +</span><span> y</span><span> +</span><span> (z</span><span> +</span><span> z))
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="basic-localization">
<span id="basic-localization-ssr"></span><h3>Basic localization<a class="headerlink" href="#basic-localization" title="Permalink to this headline">¶</a></h3>
<p>It is possible to define an abbreviation for a term appearing in the
context of a goal thanks to the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>set</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><blockquote>
<div><p>This variant of <a class="reference internal" href="#coq:tacn.set-(ssreflect)" title="set (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a> introduces a defined constant
called <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the context, and folds it in
the context entries mentioned on the right hand side of <code class="docutils literal notranslate"><span class="pre">in</span></code>.
The body of <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the first subterm matching these context
entries (taken in the given order).</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">t</span><span> (</span><span class="coqdoc-var">Hx</span><span> : </span><span class="coqdoc-var">x</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">t</span><span> = 4.</span><span>
</span></dt><dd><span>1 goal
  
  x, t : nat
  Hx : x</span><span> =</span><span> 3
  ============================
  x</span><span> +</span><span> t</span><span> =</span><span> 4
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">z</span><span> := 3 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">Hx</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, t : nat
  z := 3 : nat
  Hx : x</span><span> =</span><span> z
  ============================
  x</span><span> +</span><span> t</span><span> =</span><span> 4
</span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>set</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>*</span></span></span></code></dt>
<dd><blockquote>
<div><p>This variant matches <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and then folds <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> similarly
in all the given context entries but also folds <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the goal.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">t</span><span> (</span><span class="coqdoc-var">Hx</span><span> : </span><span class="coqdoc-var">x</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">t</span><span> = 4.</span><span>
</span></dt><dd><span>1 goal
  
  x, t : nat
  Hx : x</span><span> =</span><span> 3
  ============================
  x</span><span> +</span><span> t</span><span> =</span><span> 4
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">z</span><span> := 3 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">Hx</span><span> * .</span><span>
</span></dt><dd><span>1 goal
  
  x, t : nat
  z := 3 : nat
  Hx : x</span><span> =</span><span> z
  ============================
  x</span><span> +</span><span> t</span><span> =</span><span> S z
</span></dd>
</dl>
</div>
<p>Indeed, remember that 4 is just a notation for (S 3).</p>
</div>
</dd></dl>

<p>The use of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical is not limited to the localization of
abbreviations: for a complete description of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical, see
Section <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a> and <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>.</p>
</div>
</div>
<div class="section" id="basic-tactics">
<span id="basic-tactics-ssr"></span><h2>Basic tactics<a class="headerlink" href="#basic-tactics" title="Permalink to this headline">¶</a></h2>
<p>A sizable fraction of proof scripts consists of steps that do not
&quot;prove&quot; anything new, but instead perform menial bookkeeping tasks
such as selecting the names of constants and assumptions or splitting
conjuncts. Although they are logically trivial, bookkeeping steps are
extremely important because they define the structure of the data-flow
of a proof script. This is especially true for reflection-based
proofs, which often involve large numbers of constants and
assumptions. Good bookkeeping consists in always explicitly declaring
(i.e., naming) all new constants and assumptions in the script, and
systematically pruning irrelevant constants and assumptions in the
context. This is essential in the context of an interactive
development environment (IDE), because it facilitates navigating the
proof, allowing to instantly &quot;jump back&quot; to the point at which a
questionable assumption was added, and to find relevant assumptions by
browsing the pruned context. While novice or casual Coq users may find
the automatic name selection feature convenient, the usage of such a
feature severely undermines the readability and maintainability of
proof scripts, much like automatic variable declaration in programming
languages. The <span class="smallcaps">SSReflect</span> tactics are therefore designed to support
precise bookkeeping and to eliminate name generation heuristics. The
bookkeeping features of <span class="smallcaps">SSReflect</span> are implemented as tacticals (or
pseudo-tacticals), shared across most <span class="smallcaps">SSReflect</span> tactics, and thus form
the foundation of the <span class="smallcaps">SSReflect</span> proof language.</p>
<div class="section" id="bookkeeping">
<span id="bookkeeping-ssr"></span><h3>Bookkeeping<a class="headerlink" href="#bookkeeping" title="Permalink to this headline">¶</a></h3>
<p>During the course of a proof, Coq always presents the user with a
<em>sequent</em> whose general form is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ci : Ti
…
dj := ej : Tj
…
Fk : Pk
…
=================
forall (xl : Tl) …,
let ym := bm in … in
Pn -&gt; … -&gt; C
</pre></div>
</div>
<p>The <em>goal</em> to be proved appears below the double line; above the line
is the <em>context</em> of the sequent, a set of declarations of <em>constants</em>
<code class="docutils literal notranslate"><span class="pre">ci</span></code> , <em>defined constants</em> <code class="docutils literal notranslate"><span class="pre">dj</span></code> , and <em>facts</em> <code class="docutils literal notranslate"><span class="pre">Fk</span></code> that can be used to
prove the goal (usually, <code class="docutils literal notranslate"><span class="pre">Ti</span></code> , <code class="docutils literal notranslate"><span class="pre">Tj</span> <span class="pre">:</span> <span class="pre">Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Pk</span> <span class="pre">:</span> <span class="pre">Prop</span></code>).
The various
kinds of declarations can come in any order. The top part of the
context consists of declarations produced by the Section
commands <code class="docutils literal notranslate"><span class="pre">Variable</span></code>, <code class="docutils literal notranslate"><span class="pre">Let</span></code>, and <code class="docutils literal notranslate"><span class="pre">Hypothesis</span></code>.
This <em>section context</em> is never
affected by the <span class="smallcaps">SSReflect</span> tactics: they only operate on the lower part
— the <em>proof context</em>. As in the figure above, the goal often
decomposes into a series of (universally) quantified <em>variables</em>
<code class="docutils literal notranslate"><span class="pre">(xl</span> <span class="pre">:</span> <span class="pre">Tl)</span></code>, local <em>definitions</em>
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">ym</span> <span class="pre">:=</span> <span class="pre">bm</span> <span class="pre">in</span></code>, and <em>assumptions</em>
<code class="docutils literal notranslate"><span class="pre">Pn</span> <span class="pre">-&gt;</span></code>,
and a <em>conclusion</em> <code class="docutils literal notranslate"><span class="pre">C</span></code> (as in the context, variables, definitions, and
assumptions can appear in any order). The conclusion is what actually
needs to be proved — the rest of the goal can be seen as a part of the
proof context that happens to be “below the line”.</p>
<p>However, although they are logically equivalent, there are fundamental
differences between constants and facts, on the one hand, and variables
and assumptions, on the other. Constants and facts are <em>unordered</em>,
but <em>named</em> explicitly in the proof text; variables and assumptions
are <em>ordered</em>, but <em>unnamed</em>: the display names of variables may
change at any time because of α-conversion.</p>
<p>Similarly, basic deductive steps such as <code class="docutils literal notranslate"><span class="pre">apply</span></code> can only operate on the
goal because the Gallina terms that control their action (e.g., the
type of the lemma used by <code class="docutils literal notranslate"><span class="pre">apply</span></code>) only provide unnamed bound variables.
<a class="footnote-reference brackets" href="#id43" id="id2">12</a> Since the proof script can only refer directly to the context, it
must constantly shift declarations from the goal to the context and
conversely in between deductive steps.</p>
<p>In <span class="smallcaps">SSReflect</span>, these moves are performed by two <em>tacticals</em>, <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">:</span></code>, so that the bookkeeping required by a deductive step can be
directly associated with that step, and that tactics in an <span class="smallcaps">SSReflect</span>
script correspond to actual logical steps in the proof rather than
merely shuffle facts. Still, some isolated bookkeeping is unavoidable,
such as naming variables and assumptions at the beginning of a
proof. <span class="smallcaps">SSReflect</span> provides a specific <code class="docutils literal notranslate"><span class="pre">move</span></code> tactic for this purpose.</p>
<p>Now, <code class="docutils literal notranslate"><span class="pre">move</span></code> does essentially nothing: it is mostly a placeholder for
<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">:</span></code>. The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical moves variables, local definitions,
and assumptions to the context, while the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves facts and
constants to the goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>For example, the proof of <a class="footnote-reference brackets" href="#id44" id="id3">13</a></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">subnK</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> m n : nat, n</span><span> &lt;=</span><span> m</span><span> -&gt;</span><span> m</span><span> -</span><span> n</span><span> +</span><span> n</span><span> =</span><span> m
</span></dd>
</dl>
</div>
<p>might start with</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  le_n_m : n</span><span> &lt;=</span><span> m
  ============================
  m</span><span> -</span><span> n</span><span> +</span><span> n</span><span> =</span><span> m
</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">move</span></code> does nothing, but <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">le_m_n</span></code> changes
the variables and assumption of the goal in the constants
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code> and the fact <code class="docutils literal notranslate"><span class="pre">le_n_m</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code>, thus exposing the
conclusion <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is the converse of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>; indeed it removes facts and
constants from the context by turning them into variables and
assumptions.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> m : nat, n</span><span> &lt;=</span><span> m</span><span> -&gt;</span><span> m</span><span> -</span><span> n</span><span> +</span><span> n</span><span> =</span><span> m
</span></dd>
</dl>
</div>
<p>turns back <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into a variable and an assumption,
removing them from the proof context, and changing the goal to
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>,
which can be proved by induction on <code class="docutils literal notranslate"><span class="pre">n</span></code> using <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.</p>
</div>
<p>Because they are tacticals, <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> can be combined, as in</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">le_n_p</span><span>.</span><span>
</span></span></div>
<p>which simultaneously renames <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">le_n_p</span></code>,
respectively, by first turning them into unnamed variables, then
turning these variables back into constants and facts.</p>
<p>Furthermore, <span class="smallcaps">SSReflect</span> redefines the basic Coq tactics <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>,
and <code class="docutils literal notranslate"><span class="pre">apply</span></code> so that they can take better advantage of
<code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>. In these
<span class="smallcaps">SSReflect</span> variants, these tactics operate on the first variable or
constant of the goal and they do not use or change the proof context.
The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is used to operate on an element in the context.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For instance, the proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> could continue with <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.
Instead of <code class="docutils literal notranslate"><span class="pre">elim</span> <span class="pre">n</span></code> (note, no colon), this has the advantage of
removing n from the context. Better yet, this <code class="docutils literal notranslate"><span class="pre">elim</span></code> can be combined
with previous <code class="docutils literal notranslate"><span class="pre">move</span></code> and with the branching version of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical
(described in <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>),
to encapsulate the inductive step in a single
command:</p>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">subnK</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> m n : nat, n</span><span> &lt;=</span><span> m</span><span> -&gt;</span><span> m</span><span> -</span><span> n</span><span> +</span><span> n</span><span> =</span><span> m
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  le_n_m : n</span><span> &lt;=</span><span> m
  ============================
  m</span><span> -</span><span> n</span><span> +</span><span> n</span><span> =</span><span> m
</span></dd>
<dt><span></span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-var">m</span><span> =&gt; [</span><span class="coqdoc-var">_</span><span> | </span><span class="coqdoc-var">lt_n_m</span><span>].</span><span>
</span></dt><dd><span>2 goals
  
  m : nat
  ============================
  m</span><span> -</span><span> 0</span><span> +</span><span> 0</span><span> =</span><span> m

goal 2 is:
 m</span><span> -</span><span> S n</span><span> +</span><span> S n</span><span> =</span><span> m
</span></dd>
</dl>
</div>
<p>which breaks down the proof into two subgoals, the second one
having in its context
<code class="docutils literal notranslate"><span class="pre">lt_n_m</span> <span class="pre">:</span> <span class="pre">S</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code> and
<code class="docutils literal notranslate"><span class="pre">IHn</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tacticals can be explained very simply if one views
the goal as a stack of variables and assumptions piled on a conclusion:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pushes the context constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> as goal
variables <em>before</em> performing the tactic;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pops the top three goal variables as context
constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <em>after</em> the tactic has been performed.</p></li>
</ul>
<p>These pushes and pops do not need to balance out as in the examples
above; so <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">m</span> <span class="pre">le_n_m</span> <span class="pre">=&gt;</span> <span class="pre">p</span></code>
would rename <code class="docutils literal notranslate"><span class="pre">m</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code>, but leave an extra assumption <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code>
in the goal.</p>
<p>Basic tactics like <code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">elim</span></code> can also be used without the ’:’
tactical: for example, we can directly start a proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> by
induction on the top variable <code class="docutils literal notranslate"><span class="pre">m</span></code> with</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>=&gt; [|</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">IHm</span><span>] </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n</span><span>.</span><span>
</span></span></div>
<p>The general form of the localization tactical <code class="docutils literal notranslate"><span class="pre">in</span></code> is also best
explained in terms of the goal stack:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>tactic in a H1 H2 *.
</pre></div>
</div>
<p>is basically equivalent to</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>; </span><span class="coqdoc-var">tactic</span><span> =&gt; </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>.</span><span>
</span></span></div>
<p>with two differences: the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical will preserve the body of <code class="docutils literal notranslate"><span class="pre">a</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span></code>
is a defined constant, and if the <code class="docutils literal notranslate"><span class="pre">*</span></code> is omitted, it will use a
temporary abbreviation to hide the statement of the goal from
<code class="docutils literal notranslate"><span class="pre">tactic</span></code>.</p>
<p>The general form of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical can be used directly with the
<code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> and <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactics, so that one can write</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> *.</span><span>
</span></span></div>
<p>instead of</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span><span>
</span></span></div>
<p>This is quite useful for inductive proofs that involve many facts.</p>
<p>See Section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a> for
the general syntax and presentation of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
tactical.</p>
</div>
<div class="section" id="the-defective-tactics">
<span id="the-defective-tactics-ssr"></span><h3>The defective tactics<a class="headerlink" href="#the-defective-tactics" title="Permalink to this headline">¶</a></h3>
<p>In this section, we briefly present the three basic tactics performing
context manipulations and the main backward chaining tool.</p>
<div class="section" id="the-move-tactic">
<h4>The move tactic.<a class="headerlink" href="#the-move-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.move-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>move</span></span></span></code><a class="headerlink" href="#coq:tacn.move-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic, in its defective form, behaves like the <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">not</span><span> </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span>~</span><span> False
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  False</span><span> -&gt;</span><span> False
</span></dd>
</dl>
</div>
</div>
<p>More precisely, the <a class="reference internal" href="#coq:tacn.move-(ssreflect)" title="move (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span></code></a> tactic inspects the goal and does nothing
(<a class="reference internal" href="ltac.html#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a>) if an introduction step is possible, i.e., if the goal is a
product or a <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">…</span> <span class="pre">in</span></code>, and performs <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> otherwise.</p>
<p>Of course this tactic is most often used in combination with the bookkeeping
tacticals (see Sections <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a> and <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>).
These combinations mostly subsume the <a class="reference internal" href="tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>,
<a class="reference internal" href="tactics.html#coq:tacn.revert" title="revert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">revert</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.rename" title="rename"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rename</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.clear" title="clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">clear</span></code></a> and <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> tactics.</p>
</dd></dl>

</div>
<div class="section" id="the-case-tactic">
<span id="the-case-tactic-ssr"></span><h4>The case tactic<a class="headerlink" href="#the-case-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.case-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>case</span></span></span></code><a class="headerlink" href="#coq:tacn.case-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic performs <em>primitive case analysis</em> on (co)inductive
types; specifically, it destructs the top variable or assumption of
the goal, exposing its constructor(s) and its arguments, as well as
setting the value of its type family indices if it belongs to a type
family (see Section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>).</p>
<p>The <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic has a special behavior on equalities. If the
top assumption of the goal is an equality, the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic “destructs”
it as a set of equalities between the constructor arguments of its
left and right hand sides, as per the tactic injection. For example,
<code class="docutils literal notranslate"><span class="pre">case</span></code> changes the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(x, y) = (1, 2) -&gt; G.
</pre></div>
</div>
<p>into:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>x = 1 -&gt; y = 2 -&gt; G.
</pre></div>
</div>
<p>The <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a> can generate the following warning:</p>
<dl class="coq warn">
<dt id="coq:warn.SSReflect:-cannot-obtain-new-equations-out-of-...">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span><span>SSReflect:</span></span> <span><span>cannot</span></span> <span><span>obtain</span></span> <span><span>new</span></span> <span><span>equations</span></span> <span><span>out</span></span> <span><span>of</span></span> <span><span>...</span></span></span></code><a class="headerlink" href="#coq:warn.SSReflect:-cannot-obtain-new-equations-out-of-..." title="Permalink to this definition">¶</a></dt>
<dd><p>The tactic was run on an equation that cannot generate simpler equations,
for example <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<p>The warning can be silenced or made fatal by using the <a class="reference internal" href="vernacular-commands.html#coq:opt.Warnings" title="Warnings"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Warnings</span></code></a> option
and the <code class="docutils literal notranslate"><span class="pre">spurious-ssr-injection</span></code> key.</p>
<p>Finally, the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a> tactic of <span class="smallcaps">SSReflect</span> performs <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">False</span></span></code> elimination, even
if no branch is generated by this case operation. Hence the tactic
<a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a> on a goal of the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">False</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">G</span></span></code> will succeed and
prove the goal.</p>
</dd></dl>

</div>
<div class="section" id="the-elim-tactic">
<h4>The elim tactic<a class="headerlink" href="#the-elim-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.elim-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>elim</span></span></span></code><a class="headerlink" href="#coq:tacn.elim-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic performs inductive elimination on inductive types. In its
defective form, the tactic performs inductive elimination on a goal whose
top assumption has an inductive type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, m</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">elim</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  m : nat
  ============================
  m</span><span> &lt;=</span><span> 0

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> n : nat, m</span><span> &lt;=</span><span> n</span><span> -&gt;</span><span> m</span><span> &lt;=</span><span> S n
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="the-apply-tactic">
<span id="apply-ssr"></span><h4>The apply tactic<a class="headerlink" href="#the-apply-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.apply-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>apply</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.apply-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main backward chaining tactic of the proof system.
It takes as argument any <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and applies it to the goal.
Assumptions in the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> that don’t directly match the goal
may generate one or more subgoals.</p>
<p>In its defective form, this tactic is a synonym for:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>intro top; first [refine top | refine (top _) | refine (top _ _) | …]; clear top.
</pre></div>
</div>
<p>where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">top</span></span></code> is a fresh name, and the sequence of <a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactics
tries to catch the appropriate number of wildcards to be inserted. Note that
this use of the <a class="reference internal" href="tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic implies that the tactic tries to match
the goal up to expansion of constants and evaluation of subterms.</p>
</dd></dl>

<p><a class="reference internal" href="#coq:tacn.apply-(ssreflect)" title="apply (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> has a special behavior on goals containing
existential metavariables of sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">lt_trans</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span>, </span><span class="coqdoc-var">a</span><span> &lt; </span><span class="coqdoc-var">b</span><span> -&gt; </span><span class="coqdoc-var">b</span><span> &lt; </span><span class="coqdoc-var">c</span><span> -&gt; </span><span class="coqdoc-var">a</span><span> &lt; </span><span class="coqdoc-var">c</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>lt_trans is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">y</span><span>, 1 &lt; </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">y</span><span> &lt; 2 -&gt; </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> : { </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">n</span><span> &lt; 3 }, 0 &lt; </span><span class="coqdoc-var">proj1_sig</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> y : nat,
  1</span><span> &lt;</span><span> y</span><span> -&gt;</span><span> y</span><span> &lt;</span><span> 2</span><span> -&gt;</span><span> </span><span>exists</span><span> x : </span><span>{</span><span>n </span><span>: </span><span>nat </span><span>| </span><span>n</span><span> &lt;</span><span> 3</span><span>}</span><span>,</span><span> 0</span><span> &lt;</span><span> proj1_sig x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">y_gt1</span><span> </span><span class="coqdoc-var">y_lt2</span><span>; </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">ex_intro</span><span> </span><span class="coqdoc-var">_</span><span> (</span><span class="coqdoc-var">exist</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">_</span><span>)).</span><span>
</span></dt><dd><span>2 goals
  
  y : nat
  y_gt1 : 1</span><span> &lt;</span><span> y
  y_lt2 : y</span><span> &lt;</span><span> 2
  ============================
  y</span><span> &lt;</span><span> 3

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> Hyp0 : y</span><span> &lt;</span><span> 3, 0</span><span> &lt;</span><span> proj1_sig (exist (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; n</span><span> &lt;</span><span> 3) y Hyp0)
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">lt_trans</span><span> </span><span class="coqdoc-var">y_lt2</span><span> </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  y : nat
  y_gt1 : 1</span><span> &lt;</span><span> y
  y_lt2 : y</span><span> &lt;</span><span> 2
  ============================
  </span><span class="ansi-bold">forall</span><span> Hyp0 : y</span><span> &lt;</span><span> 3, 0</span><span> &lt;</span><span> proj1_sig (exist (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; n</span><span> &lt;</span><span> 3) y Hyp0)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">y_lt3</span><span>; </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">lt_trans</span><span> </span><span class="coqdoc-var">y_gt1</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>Note that the last <code class="docutils literal notranslate"><span class="pre">_</span></code> of the tactic
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(ex_intro</span> <span class="pre">_</span> <span class="pre">(exist</span> <span class="pre">_</span> <span class="pre">y</span> <span class="pre">_))</span></code>
represents a proof that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>. Instead of generating the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n : nat =&gt; n &lt; 3) y ?Goal).
</pre></div>
</div>
<p>the system tries to prove <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> calling the trivial tactic.
If it succeeds, let’s say because the context contains
<code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, then the
system generates the following goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n =&gt; n &lt; 3) y H).
</pre></div>
</div>
<p>Otherwise the missing proof is considered to be irrelevant, and is
thus discharged, generating the two goals shown above.</p>
<p>Last, the user can replace the trivial tactic by defining an Ltac
expression named <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="discharge">
<span id="discharge-ssr"></span><h3>Discharge<a class="headerlink" href="#discharge" title="Permalink to this headline">¶</a></h3>
<p>The general syntax of the discharging tactical <code class="docutils literal notranslate"><span class="pre">:</span></code> is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.…-:-…-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.…-:-…-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-d_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-clear_switch"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> }</span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>with the following requirements.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> must be one of the four basic tactics described in <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>,
i.e., <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code> or <code class="docutils literal notranslate"><span class="pre">apply</span></code>, the <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactic (section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>),
the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic (Section <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a>),
or the application of the <em>view</em>
tactical ‘/’ (Section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to one of <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, or <code class="docutils literal notranslate"><span class="pre">elim</span></code>.</p></li>
<li><p>The optional <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> specifies <em>equation generation</em> (Section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>),
and is only allowed if <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> is <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, or the
application of the view tactical ‘/’ (Section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>.</p></li>
<li><p>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> selects occurrences of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, as in <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>; <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
is not allowed if <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> is <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code>.</p></li>
<li><p>A clear item <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> specifies facts and constants to be
deleted from the proof context (as per the <code class="docutils literal notranslate"><span class="pre">clear</span></code> tactic).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical first <em>discharges</em> all the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, right to left,
and then performs the tactic, i.e., for each <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, starting with the last one :</p>
<ol class="arabic simple">
<li><p>The <span class="smallcaps">SSReflect</span> matching algorithm described in Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a> is
used to find occurrences of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in the goal, after filling any holes
‘_’ in the term; however if <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> is <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code>, a different matching
algorithm, described below, is used <a class="footnote-reference brackets" href="#id45" id="id4">14</a>.</p></li>
<li><p>These occurrences are replaced by a new variable; in particular, if
the term is a fact, this adds an assumption to the goal.</p></li>
<li><p>If the term is <em>exactly</em> the name of a constant or fact in the proof
context, it is deleted from the context, unless there is an
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>.</p></li>
</ol>
<p>Finally, the tactic is performed just after the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
has been generalized
— that is, between steps 2 and 3. The names listed in
the final <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (if it is present) are cleared first, before
<a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> n is discharged.</p>
<p>Switches affect the discharging of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> as follows.</p>
<ul class="simple">
<li><p>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> restricts generalization (step 2) to a specific subset
of the occurrences of the term, as per Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, and prevents clearing (step
3).</p></li>
<li><p>All the names specified by a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> are deleted from the
context in step 3, possibly in addition to the term.</p></li>
</ul>
<p>For example, the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">n</span><span> {2}</span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">refl_equal</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></span></div>
<ul class="simple">
<li><p>first generalizes <code class="docutils literal notranslate"><span class="pre">(refl_equal</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n)</span></code>;</p></li>
<li><p>then generalizes the second occurrence of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p>finally generalizes all the other occurrences of <code class="docutils literal notranslate"><span class="pre">n</span></code>, and clears <code class="docutils literal notranslate"><span class="pre">n</span></code>
from the proof context (assuming <code class="docutils literal notranslate"><span class="pre">n</span></code> is a proof constant).</p></li>
</ul>
<p>Therefore, this tactic changes any goal <code class="docutils literal notranslate"><span class="pre">G</span></code> into</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">n0</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n0</span><span> -&gt; </span><span class="coqdoc-var">G</span><span>.</span><span>
</span></span></div>
<p>where the name <code class="docutils literal notranslate"><span class="pre">n0</span></code> is picked by the Coq display function, and assuming
<code class="docutils literal notranslate"><span class="pre">n</span></code> appeared only in <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>Finally, note that a discharge operation generalizes defined constants
as variables, and not as local definitions. To override this behavior,
prefix the name of the local definition with a <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, like in <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">&#64;n</span></code>.</p>
<p>This is in contrast with the behavior of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical (see
Section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>), which preserves local
definitions by default.</p>
<div class="section" id="clear-rules">
<h4>Clear rules<a class="headerlink" href="#clear-rules" title="Permalink to this headline">¶</a></h4>
<p>The clear step will fail if the term is a proof constant that appears in
other facts; in that case, either the facts should be cleared
explicitly with a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, or the clear step should be disabled.
The latter can be done by adding an <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> or simply by putting
parentheses around term: both
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">(n).</span></code>
and
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">{+}n.</span></code>
generalize <code class="docutils literal notranslate"><span class="pre">n</span></code> without clearing <code class="docutils literal notranslate"><span class="pre">n</span></code> from the proof context.</p>
<p>The clear step will also fail if the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> contains a <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> that
is not in the <em>proof</em> context. Note that <span class="smallcaps">SSReflect</span> never clears a
section constant.</p>
<p>If the tactic is <code class="docutils literal notranslate"><span class="pre">move</span></code> or <code class="docutils literal notranslate"><span class="pre">case</span></code> and an equation <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is given, then clearing
(step 3) for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> is suppressed (see Section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
<p>Intro patterns (see Section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)
and the <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic (see Section <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)
let one place a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> in the middle of other items
(namely identifiers, views and rewrite rules).  This can trigger the
addition of proof context items to the ones being explicitly
cleared, and in turn this can result in <code class="docutils literal notranslate"><span class="pre">clear</span></code> errors (e.g., if the
context item automatically added occurs in the goal).  The
relevant sections describe ways to avoid the unintended clearing of
context items.</p>
</div>
<div class="section" id="matching-for-apply-and-exact">
<h4>Matching for apply and exact<a class="headerlink" href="#matching-for-apply-and-exact" title="Permalink to this headline">¶</a></h4>
<p>The matching algorithm for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> of the <span class="smallcaps">SSReflect</span>
<code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactics exploits the type of the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to interpret
wildcards in the
other <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> and to determine which occurrences of these should be
generalized. Therefore, occur switches are not needed for <code class="docutils literal notranslate"><span class="pre">apply</span></code> and
<code class="docutils literal notranslate"><span class="pre">exact</span></code>.</p>
<p>Indeed, the <span class="smallcaps">SSReflect</span> tactic <code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">H</span> <span class="pre">x</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(&#64;H</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_</span> <span class="pre">x);</span> <span class="pre">clear</span> <span class="pre">H</span> <span class="pre">x</span></code>,
with an appropriate number of wildcards between <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Note that this means that matching for <code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code> has much more
context to interpret wildcards; in particular, it can accommodate the
<code class="docutils literal notranslate"><span class="pre">_</span></code> <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, which would always be rejected after <code class="docutils literal notranslate"><span class="pre">move:</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>f is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>g is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">Hfg</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span>) </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  Hfg : </span><span class="ansi-bold">forall</span><span> x : nat, f x</span><span> =</span><span> g x
  a, b : nat
  ============================
  f a</span><span> =</span><span> g b
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">trans_equal</span><span> (</span><span class="coqdoc-var">Hfg</span><span> </span><span class="coqdoc-var">_</span><span>) </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  Hfg : </span><span class="ansi-bold">forall</span><span> x : nat, f x</span><span> =</span><span> g x
  a, b : nat
  ============================
  g a</span><span> =</span><span> g b
</span></dd>
</dl>
</div>
</div>
<p>This tactic is equivalent (see Section
<a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>) to:
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(trans_equal</span> <span class="pre">(Hfg</span> <span class="pre">_)</span> <span class="pre">_).</span></code>
and this is a common idiom for applying transitivity on the left hand
side of an equation.</p>
</div>
<div class="section" id="the-abstract-tactic">
<span id="abstract-ssr"></span><h4>The abstract tactic<a class="headerlink" href="#the-abstract-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.abstract-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>abstract:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.abstract-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic assigns an abstract constant previously introduced with the
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[:</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">]</span></span></span></span></code> intro pattern (see Section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>).</p>
</dd></dl>

<p>In a goal like the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : &lt;hidden&gt;
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>The tactic <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">abstract</span></span><span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">abs</span></span> <span class="name"><span class="pre">n</span></span></code> first generalizes the goal with respect to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>
(that is not visible to the abstract constant <code class="docutils literal notranslate"><span class="pre">abs</span></code>) and then assigns
abs. The resulting goal is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>Once this subgoal is closed, all other goals having <code class="docutils literal notranslate"><span class="pre">abs</span></code> in their
context see the type assigned to <code class="docutils literal notranslate"><span class="pre">abs</span></code>. In this case:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : forall n, m &lt; 5 + n
=============
…
</pre></div>
</div>
<p>For a more detailed example, the reader should refer to
Section <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>.</p>
</div>
</div>
<div class="section" id="introduction-in-the-context">
<span id="introduction-ssr"></span><h3>Introduction in the context<a class="headerlink" href="#introduction-in-the-context" title="Permalink to this headline">¶</a></h3>
<p>The application of a tactic to a given goal can generate (quantified)
variables, assumptions, or definitions, which the user may want to
<em>introduce</em> as new facts, constants or defined constants,
respectively. If the tactic splits the goal into several subgoals,
each of them may require the introduction of different constants and
facts. Furthermore it is very common to immediately decompose or
rewrite with an assumption instead of adding it to the context, as the
goal can often be simplified and even proved after this.</p>
<p>All these operations are performed by the introduction tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>,
whose general syntax is</p>
<dl class="coq tacn">
<dt id="coq:tacn.=&gt;">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>=&gt;</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.=>" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-s_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>/=</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>//</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>//=</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_view"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>{</span></span><span><span>}</span></span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span><span>/</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/ltac:(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>)</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>&gt;</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>_</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>*</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>+</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span><span>-&gt;</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>&lt;-</span></span></span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>-</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_block"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>[^</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[^~</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical first executes <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a>, then the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>s,
left to right. An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> specifies a
simplification operation; a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
specifies context pruning as in <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>.
The <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>s can be seen as a variant of <em>intro patterns</em>
(see <a class="reference internal" href="tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>); each performs an introduction operation, i.e., pops some
variables or assumptions from the goal.</p>
<div class="section" id="simplification-items">
<h4>Simplification items<a class="headerlink" href="#simplification-items" title="Permalink to this headline">¶</a></h4>
<p>An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can simplify the set of subgoals or the subgoals themselves.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">//</span></code> removes all the “trivial” subgoals that can be resolved by the
<span class="smallcaps">SSReflect</span> tactic <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> described in <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>, i.e.,
it executes <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">done</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/=</span></code> simplifies the goal by performing partial evaluation, as per the
tactic <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.simpl" title="simpl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> <a class="footnote-reference brackets" href="#id46" id="id5">15</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">//=</span></code> combines both kinds of simplification; it is equivalent to
<code class="docutils literal notranslate"><span class="pre">/=</span> <span class="pre">//</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">simpl;</span> <span class="pre">try</span> <span class="pre">done</span></code>.</p></li>
</ul>
<p>When an <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> immediately precedes a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, then the
<a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> is executed
<em>after</em> the <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, e.g., <code class="docutils literal notranslate"><span class="pre">{IHn}//</span></code> will solve some subgoals,
possibly using the fact <code class="docutils literal notranslate"><span class="pre">IHn</span></code>, and will erase <code class="docutils literal notranslate"><span class="pre">IHn</span></code> from the context
of the remaining subgoals.</p>
</div>
<div class="section" id="views">
<h4>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h4>
<p>The first entry in the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> grammar rule, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">/</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>,
represents a view (see Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).
It interprets the top of the stack with the view <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
It is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">move/</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> that immediately precedes an <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is complemented with the name of the view if an only if the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is a simple proof context entry <a class="footnote-reference brackets" href="#id51" id="id6">20</a>.
E.g., <code class="docutils literal notranslate"><span class="pre">{}/v</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">/v{v}</span></code>.
This behavior can be avoided by separating the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
from the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">-</span></code> intro pattern or by putting
parentheses around the view.</p>
<p>A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> that immediately precedes an <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a>
is executed after the view application.</p>
<p>If the next <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> is a view, then the view is
applied to the assumption in top position once all the
previous <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> have been performed.</p>
<p>The second entry in the <a class="reference internal" href="#grammar-token-i_view"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_view</span></code></a> grammar rule,
<code class="docutils literal notranslate"><span class="pre">/ltac:(</span></code> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> <code class="docutils literal notranslate"><span class="pre">)</span></code>, executes <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a>.
Notations can be used to name tactics,  for example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Tactic Notation</span><span> &quot;my&quot; &quot;ltac&quot; &quot;code&quot; := </span><span class="coqdoc-tactic">idtac</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;'myop'&quot; := (</span><span class="coqdoc-keyword">ltac</span><span>:(</span><span class="coqdoc-var">my</span><span> </span><span class="coqdoc-keyword">ltac</span><span> </span><span class="coqdoc-var">code</span><span>)) : </span><span class="coqdoc-var">ssripat_scope</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-59:
&gt; Notation &quot;'myop'&quot; := (ltac:(my ltac code)) : ssripat_scope.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold">Warning:</span><span> This notation contains Ltac expressions: it will not be used for
printing. [non-reversible-notation,parsing]
</span></dd>
</dl>
</div>
<p>lets one write just <code class="docutils literal notranslate"><span class="pre">/myop</span></code> in the intro pattern. Note the scope
annotation: views are interpreted opening the <code class="docutils literal notranslate"><span class="pre">ssripat</span></code> scope.  We
provide the following ltac views: <code class="docutils literal notranslate"><span class="pre">/[dup]</span></code> to duplicate the top of
the stack, <code class="docutils literal notranslate"><span class="pre">/[swap]</span></code> to swap the two first elements and <code class="docutils literal notranslate"><span class="pre">/[apply]</span></code>
to apply the top of the stack to the next.</p>
</div>
<div class="section" id="intro-patterns">
<h4>Intro patterns<a class="headerlink" href="#intro-patterns" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> supports the following <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>s.</p>
<dl>
<dt><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a></dt><dd><p>pops the top variable, assumption, or local definition into
a new constant, fact, or defined constant <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, respectively.
Note that defined constants cannot be introduced when δ-expansion is
required to expose the top variable or assumption.
A <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (even an empty one) immediately preceding an
<a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is complemented with that <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> if and only if
the identifier is a simple proof context entry <a class="footnote-reference brackets" href="#id51" id="id7">20</a>.
As a consequence,  by prefixing the
<a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> with <code class="docutils literal notranslate"><span class="pre">{}</span></code> one can <em>replace</em> a context entry.
This behavior can be avoided by separating the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
from the <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">-</span></code> intro pattern.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></dt><dd><p>pops every variable occurring in the rest of the stack.
Type class instances are popped even if they don't occur
in the rest of the stack.
The tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">&gt;</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">?</span> <span class="pre">?</span></code> on a goal such as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x y, x &lt; y -&gt; G
</pre></div>
</div>
<p>A typical use if <code class="docutils literal notranslate"><span class="pre">move=&gt;&gt;</span> <span class="pre">H</span></code> to name <code class="docutils literal notranslate"><span class="pre">H</span></code> the first assumption,
in the example above <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>pops the top variable into an anonymous constant or fact, whose name
is picked by the tactic interpreter. <span class="smallcaps">SSReflect</span> only generates names that cannot
appear later in the user script <a class="footnote-reference brackets" href="#id47" id="id8">16</a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_</span></code></dt><dd><p>pops the top variable into an anonymous constant that will be deleted
from the proof context of all the subgoals produced by the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical.
They should thus never be displayed, except in an error message if the
constant is still actually used in the goal or context after the last
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> has been executed (<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can erase goals or
terms where the constant appears).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>pops all the remaining apparent variables/assumptions as anonymous
constants/facts. Unlike <code class="docutils literal notranslate"><span class="pre">?</span></code> and <code class="docutils literal notranslate"><span class="pre">move</span></code>, the <code class="docutils literal notranslate"><span class="pre">*</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not
expand definitions in the goal to expose quantifiers, so it may be useful
to repeat a <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> tactic, e.g., on the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall a b : bool, a &lt;&gt; b
</pre></div>
</div>
<p>a first <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> adds only <code class="docutils literal notranslate"><span class="pre">_a_</span> <span class="pre">:</span> <span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">_b_</span> <span class="pre">:</span> <span class="pre">bool</span></code>
to the context; it takes a second <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> to add <code class="docutils literal notranslate"><span class="pre">_Hyp_</span> <span class="pre">:</span> <span class="pre">_a_</span> <span class="pre">=</span> <span class="pre">_b_</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>temporarily introduces the top variable. It is discharged at the end
of the intro pattern. For example <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">+</span> <span class="pre">y</span></code> on a goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x y, P
</pre></div>
</div>
<p>is equivalent to <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">_x_</span> <span class="pre">y;</span> <span class="pre">move:</span> <span class="pre">_x_</span></code> that results in the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall x, P
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">occ</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">switch</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">-&gt;</span></span></span></span></code></dt><dd><p>(resp. <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>)
pops the top assumption (which should be a rewritable proposition) into an
anonymous fact, rewrites (resp. rewrites right to left) the goal with this
fact (using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic described in Section
<a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>, and honoring the optional occurrence selector), and
finally deletes the anonymous fact from the context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt><dd><p>when it is the
very <em>first</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> after tactic <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical <em>and</em> the tactic
is not a move, is a <em>branching</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It executes the sequence
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">i</span></sub></span></a></span></code> on the i-th subgoal produced by the tactic. The
execution of the tactic should thus generate exactly m subgoals, unless the
<code class="docutils literal notranslate"><span class="pre">[…]</span></code> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> comes after an initial <code class="docutils literal notranslate"><span class="pre">//</span></code> or <code class="docutils literal notranslate"><span class="pre">//=</span></code>
<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> that closes some of the goals produced by the tactic, in
which case exactly m subgoals should remain after the <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, or we have
the trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> [], which always does nothing,
regardless of the number of remaining subgoals.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt><dd><p>when it is <em>not</em>
the first <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> or when the tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, is a
<em>destructing</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It starts by destructing the top
variable, using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic described in
<a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>. It then behaves as the corresponding
branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, executing the
sequence <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">i</span></sub></span></a></span></code>  in the i-th subgoal generated by the
case analysis; unless we have the trivial destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>
<code class="docutils literal notranslate"><span class="pre">[]</span></code>, the latter should generate exactly m subgoals, i.e., the top
variable should have an inductive type with exactly m constructors <a class="footnote-reference brackets" href="#id48" id="id9">17</a>.
While it is good style to use the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> i * to pop the variables
and assumptions corresponding to each constructor, this is not enforced by
<span class="smallcaps">SSReflect</span>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-</span></code></dt><dd><p>does nothing, but counts as an intro pattern. It can also be used to
force the interpretation of <code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code> as a case analysis like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">-[H1</span> <span class="pre">H2]</span></code>. It
can also be used to indicate explicitly the link between a view and a name
like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/eqP-H1</span></code>.  Last, it can serve as a separator between
views.  Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a> <a class="footnote-reference brackets" href="#id50" id="id10">19</a> explains in which
respect the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/v1/v2</span></code> differs from the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span>
<span class="pre">/v1-/v2</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[:</span></code> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> <code class="docutils literal notranslate"><span class="pre">…]</span></code></dt><dd><p>introduces in the context an abstract constant
for each <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.  Its type has to be fixed later on by using the
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> tactic.  Before then the type displayed is <code class="docutils literal notranslate"><span class="pre">&lt;hidden&gt;</span></code>.</p>
</dd>
</dl>
<p>Note that <span class="smallcaps">SSReflect</span> does not support the syntax <code class="docutils literal notranslate"><span class="pre">(ipat,</span> <span class="pre">…,</span> <span class="pre">ipat)</span></code> for
destructing intro patterns.</p>
</div>
<div class="section" id="clear-switch">
<h4>Clear switch<a class="headerlink" href="#clear-switch" title="Permalink to this headline">¶</a></h4>
<p>Clears are deferred until the end of the intro pattern.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Nat.leb</span><span> 0 </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">true</span><span> -&gt; (</span><span class="coqdoc-var">Nat.leb</span><span> 0 </span><span class="coqdoc-var">x</span><span>) &amp;&amp; (</span><span class="coqdoc-var">Nat.leb</span><span> </span><span class="coqdoc-var">y</span><span> 2) = </span><span class="coqdoc-var">true</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  </span><span class="ansi-fg-light-magenta">Nat</span><span>.</span><span class="ansi-fg-light-green">leb</span><span> 0 x</span><span> =</span><span> true</span><span> -&gt;</span><span> </span><span class="ansi-fg-light-magenta">Nat</span><span>.</span><span class="ansi-fg-light-green">leb</span><span> 0 x</span><span> &amp;&amp;</span><span> </span><span class="ansi-fg-light-magenta">Nat</span><span>.</span><span class="ansi-fg-light-green">leb</span><span> y 2</span><span> =</span><span> true
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; {</span><span class="coqdoc-var">x</span><span>} -&gt;.</span><span>
</span></dt><dd><span>1 goal
  
  y : nat
  ============================
  true</span><span> &amp;&amp;</span><span> </span><span class="ansi-fg-light-magenta">Nat</span><span>.</span><span class="ansi-fg-light-green">leb</span><span> y 2</span><span> =</span><span> true
</span></dd>
</dl>
</div>
</div>
<p>If the cleared names are reused in the same intro pattern, a renaming
is performed behind the scenes.</p>
<p>Facts mentioned in a clear switch must be valid names in the proof
context (excluding the section context).</p>
</div>
<div class="section" id="branching-and-destructuring">
<h4>Branching and destructuring<a class="headerlink" href="#branching-and-destructuring" title="Permalink to this headline">¶</a></h4>
<p>The rules for interpreting branching and destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> are
motivated by the fact that it would be pointless to have a branching
pattern if the tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, and in most of the remaining cases
the tactic is <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, which implies destructuring.
The rules above imply that:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b.</span></code></p></li>
</ul>
<p>are all equivalent, so which one to use is a matter of style; <code class="docutils literal notranslate"><span class="pre">move</span></code> should
be used for casual decomposition, such as splitting a pair, and <code class="docutils literal notranslate"><span class="pre">case</span></code>
should be used for actual decompositions, in particular for type families
(see <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>) and proof by contradiction.</p>
<p>The trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be used to force the branching
interpretation, e.g.:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[]</span> <span class="pre">[a</span> <span class="pre">b]</span> <span class="pre">c.</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[[a</span> <span class="pre">b]</span> <span class="pre">c].</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case;</span> <span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c.</span></code></p></li>
</ul>
<p>are all equivalent.</p>
</div>
<div class="section" id="block-introduction">
<h4>Block introduction<a class="headerlink" href="#block-introduction" title="Permalink to this headline">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> supports the following <a class="reference internal" href="#grammar-token-i_block"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_block</span></code></a>s.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[^</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p><em>block destructing</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It performs a case analysis
on the top variable and introduces, in one go, all the variables coming
from the case analysis. The names of these variables are obtained by
taking the names used in the inductive type declaration and prefixing them
with <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. If the intro pattern immediately follows a call
to <code class="docutils literal notranslate"><span class="pre">elim</span></code> with a custom eliminator (see <a class="reference internal" href="#custom-elim-ssr"><span class="std std-ref">Interpreting eliminations</span></a>), then
the names are taken from the ones used in the type of the eliminator.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">r</span><span> := { </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">nat</span><span>; </span><span class="coqdoc-var">b</span><span> := (</span><span class="coqdoc-var">a</span><span>, 3); </span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">bool</span><span>; }.</span><span>
</span></dt><dd><span>r is defined
a is defined
b is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">r</span><span> -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  r</span><span> -&gt;</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">move</span><span> =&gt; [^ </span><span class="coqdoc-var">x</span><span> ].</span><span>
</span></dt><dd><span>
1 goal
  
  xa : nat
  xb := </span><span>(</span><span>xa</span><span>,</span><span> 3</span><span>)</span><span> : nat</span><span> *</span><span> nat
  _x?_ : bool
  ============================
  True
</span></dd>
</dl>
</div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[^~</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p><em>block destructing</em> using <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as a suffix.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[^~</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p><em>block destructing</em> using <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a> as a suffix.</p>
<p>Only a <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> is allowed between the elimination tactic and
the block destructing.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="generation-of-equations">
<span id="generation-of-equations-ssr"></span><h3>Generation of equations<a class="headerlink" href="#generation-of-equations" title="Permalink to this headline">¶</a></h3>
<p>The generation of named equations option stores the definition of a
new constant as an equation. The tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">En</span><span>: (</span><span class="coqdoc-var">size</span><span> </span><span class="coqdoc-var">l</span><span>) =&gt; </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">l</span></code> is a list, replaces <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">l</span></code> by <code class="docutils literal notranslate"><span class="pre">n</span></code> in the goal and
adds the fact <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">:</span> <span class="pre">size</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">n</span></code> to the context.
This is quite different from:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">n</span><span> := (</span><span class="coqdoc-var">size</span><span> </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></span></div>
<p>which generates a definition <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">(size</span> <span class="pre">l)</span></code>. It is not possible to
generalize or rewrite such a definition; on the other hand, it is
automatically expanded during computation, whereas expanding the
equation <code class="docutils literal notranslate"><span class="pre">En</span></code> requires explicit rewriting.</p>
<p>The use of this equation name generation option with a <code class="docutils literal notranslate"><span class="pre">case</span></code> or an
<code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic changes the status of the first <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, in order to
deal with the possible parameters of the constants introduced.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> :</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">a</span><span> &lt;&gt; </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  ============================
  a</span><span> &lt;&gt;</span><span> b
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">a</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span>].</span><span>
</span></dt><dd><span>2 goals
  
  a, b : nat
  E : a</span><span> =</span><span> 0
  ============================
  0</span><span> &lt;&gt;</span><span> b

goal 2 is:
 S n</span><span> &lt;&gt;</span><span> b
</span></dd>
</dl>
</div>
</div>
<p>If the user does not provide a branching <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> as first
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, or if the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not provide enough names for
the arguments of a constructor, then the constants generated are introduced
under fresh <span class="smallcaps">SSReflect</span> names.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> :</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">a</span><span> &lt;&gt; </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  ============================
  a</span><span> &lt;&gt;</span><span> b
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">a</span><span> =&gt; </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  a, b : nat
  E : a</span><span> =</span><span> 0
  H : 0</span><span> =</span><span> b
  ============================
  False

goal 2 is:
 False
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> 2.</span><span>
</span></dt><dd><span>goal 2 is:
  
  a, b, _n_ : nat
  E : a</span><span> =</span><span> S _n_
  H : S _n_</span><span> =</span><span> b
  ============================
  False
</span></dd>
</dl>
</div>
</div>
<p>Combining the generation of named equations mechanism with the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>
tactic strengthens the power of a case analysis. On the other hand,
when combined with the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a> tactic, this feature is mostly useful for
debug purposes, to trace the values of decomposed parameters and
pinpoint failing branches.</p>
</div>
<div class="section" id="type-families">
<span id="type-families-ssr"></span><h3>Type families<a class="headerlink" href="#type-families" title="Permalink to this headline">¶</a></h3>
<p>When the top assumption of a goal has an inductive type, two specific
operations are possible: the case analysis performed by the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>
tactic, and the application of an induction principle, performed by
the <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a> tactic. When this top assumption has an inductive type, which
is moreover an instance of a type family, Coq may need help from the
user to specify which occurrences of the parameters of the type should
be substituted.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>case:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span><span>/</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>elim:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span><span>/</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>A specific <code class="docutils literal notranslate"><span class="pre">/</span></code> switch indicates the type family parameters of the type
of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> immediately following this <code class="docutils literal notranslate"><span class="pre">/</span></code> switch.
The <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> on the right side of the <code class="docutils literal notranslate"><span class="pre">/</span></code> switch are discharged as
described in Section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>. The case analysis or elimination
will be done on the type of the top assumption after these discharge
operations.</p>
<p>Every <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> preceding the <code class="docutils literal notranslate"><span class="pre">/</span></code> is interpreted as an argument of this
type, which should be an instance of an inductive type family. These terms
are not actually generalized, but rather selected for substitution.
Occurrence switches can be used to restrict the substitution. If a term is
left completely implicit (e.g., writing just <code class="docutils literal notranslate"><span class="pre">_</span></code>), then a pattern is
inferred by looking at the type of the top assumption. This allows for the
compact syntax:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">case</span><span>: {2}</span><span class="coqdoc-var">_</span><span> / </span><span class="coqdoc-var">eqP</span><span>.</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">_</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">==</span> <span class="pre">_)</span></code>, since
<code class="docutils literal notranslate"><span class="pre">eqP</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">reflect</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">reflect</span></code> is a type family with
one index.</p>
<p>Moreover, if the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> list is too short, it is padded with an
initial sequence of <code class="docutils literal notranslate"><span class="pre">_</span></code> of the right length.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function that
adds an element at the end of a given list.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">LastCases</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd><span>A is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
 | </span><span class="coqdoc-var">nil</span><span> =&gt; </span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">nil</span><span>
 | </span><span class="coqdoc-var">hd</span><span> :: </span><span class="coqdoc-var">tl</span><span> =&gt; </span><span class="coqdoc-var">hd</span><span> :: (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">tl</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>add_last is defined
add_last is recursively defined (guarded on 2nd argument)
</span></dd>
</dl>
</div>
<p>Then we define an inductive predicate for case analysis on lists
according to their last element:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">last_spec</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">LastSeq0</span><span> : </span><span class="coqdoc-var">last_spec</span><span> </span><span class="coqdoc-var">nil</span><span>
| </span><span class="coqdoc-var">LastAdd</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">last_spec</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s</span><span>).</span><span>
</span></dt><dd><span>last_spec is defined
last_spec_rect is defined
last_spec_ind is defined
last_spec_rec is defined
last_spec_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">lastP</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>, </span><span class="coqdoc-var">last_spec</span><span> </span><span class="coqdoc-var">l</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  ============================
  </span><span class="ansi-bold">forall</span><span> l, last_spec l
</span></dd>
<dt><span></span><span class="coqdoc-var">Admitted</span><span>.</span><span>
</span></dt><dd><span>lastP is declared
</span></dd>
</dl>
</div>
<p>We are now ready to use <code class="docutils literal notranslate"><span class="pre">lastP</span></code> in conjunction with <code class="docutils literal notranslate"><span class="pre">case</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">l</span><span> : (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>) * 2 = </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l : list A
  ============================
  length l</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> l)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l : list A
  ============================
  length nil</span><span> *</span><span> 2</span><span> =</span><span> length (nil</span><span> ++</span><span> nil)

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> (s : list A) (x : A),
 length (add_last x s)</span><span> *</span><span> 2</span><span> =</span><span> length (add_last x s</span><span> ++</span><span> add_last x s)
</span></dd>
</dl>
</div>
<p>Applied to the same goal, the tactic <code class="docutils literal notranslate"><span class="pre">case:</span> <span class="pre">l</span> <span class="pre">/</span> <span class="pre">(lastP</span> <span class="pre">l)</span></code>
generates the same subgoals, but <code class="docutils literal notranslate"><span class="pre">l</span></code> has been cleared from both contexts:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: </span><span class="coqdoc-var">l</span><span> / (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  ============================
  length nil</span><span> *</span><span> 2</span><span> =</span><span> length (nil</span><span> ++</span><span> nil)

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> (s : list A) (x : A),
 length (add_last x s)</span><span> *</span><span> 2</span><span> =</span><span> length (add_last x s</span><span> ++</span><span> add_last x s)
</span></dd>
</dl>
</div>
<p>Again applied to the same goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: {1 3}</span><span class="coqdoc-var">l</span><span> / (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l : list A
  ============================
  length nil</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> nil)

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> (s : list A) (x : A),
 length (add_last x s)</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> add_last x s)
</span></dd>
</dl>
</div>
<p>Note that the selected occurrences on the left of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
switch have been substituted with <code class="docutils literal notranslate"><span class="pre">l</span></code> instead of being affected by
the case analysis.</p>
</div>
<p>The equation name generation feature combined with a type family <code class="docutils literal notranslate"><span class="pre">/</span></code>
switch generates an equation for the <em>first</em> dependent <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
specified by the user. Again starting with the above goal, the
command:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">l</span><span> : (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>) * 2 = </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l : list A
  ============================
  length l</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> l)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span>: {1 3}</span><span class="coqdoc-var">l</span><span> / (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>) =&gt; [|</span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span>].</span><span>
</span></dt><dd><span>2 goals
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l : list A
  E : l</span><span> =</span><span> nil
  ============================
  length nil</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> nil)

goal 2 is:
 length (add_last x s)</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> add_last x s)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> 2.</span><span>
</span></dt><dd><span>goal 2 is:
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  l, s : list A
  x : A
  E : l</span><span> =</span><span> add_last x s
  ============================
  length (add_last x s)</span><span> *</span><span> 2</span><span> =</span><span> length (l</span><span> ++</span><span> add_last x s)
</span></dd>
</dl>
</div>
</div>
<p>There must be at least one <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to the left of the <code class="docutils literal notranslate"><span class="pre">/</span></code> switch; this
prevents any confusion with the view feature. However, the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
to the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> are optional, and if they are omitted, the first
assumption provides the instance of the type family.</p>
<p>The equation always refers to the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> in the actual tactic
call, before any padding with initial <code class="docutils literal notranslate"><span class="pre">_</span></code>. Thus, if an inductive type
has two family parameters, it is possible to have <span class="smallcaps">SSReflect</span> generate an
equation for the second one by omitting the pattern for the first;
note however that this will fail if the type of the second parameter
depends on the value of the first parameter.</p>
</dd></dl>

</div>
</div>
<div class="section" id="control-flow">
<h2>Control flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h2>
<div class="section" id="indentation-and-bullets">
<span id="indentation-ssr"></span><h3>Indentation and bullets<a class="headerlink" href="#indentation-and-bullets" title="Permalink to this headline">¶</a></h3>
<p>A linear development of Coq scripts gives little information on the
structure of the proof. In addition, replaying a proof after some
changes in the statement to be proved will usually not display
information to distinguish between the various branches of case
analysis for instance.</p>
<p>To help the user in this organization of the proof script at development
time, <span class="smallcaps">SSReflect</span> provides some bullets to highlight the structure of branching
proofs. The available bullets are <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code>.  Combined with
tabulation, this lets us highlight four nested levels of branching; the most
we have ever needed is three. Indeed, the use of “simpl and closing”
switches, of terminators (see Section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and
selectors (see Section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) is powerful enough to avoid most
of the time more than two levels of indentation.</p>
<p>Here is a fragment of such a structured script:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case E1: (abezoutn _ _) =&gt; [[| k1] [| k2]].
- rewrite !muln0 !gexpn0 mulg1 =&gt; H1.
  move/eqP: (sym_equal F0); rewrite -H1 orderg1 eqn_mul1.
  by case/andP; move/eqP.
- rewrite muln0 gexpn0 mulg1 =&gt; H1.
  have F1: t %| t * S k2.+1 - 1.
    apply: (@dvdn_trans (orderg x)); first by rewrite F0; exact: dvdn_mull.
    rewrite orderg_dvd; apply/eqP; apply: (mulgI x).
    rewrite -{1}(gexpn1 x) mulg1 gexpn_add leq_add_sub //.
    by move: P1; case t.
  rewrite dvdn_subr in F1; last by exact: dvdn_mulr.
  + rewrite H1 F0 -{2}(muln1 (p ^ l)); congr (_ * _).
    by apply/eqP; rewrite -dvdn1.
  + by move: P1; case: (t) =&gt; [| [| s1]].
- rewrite muln0 gexpn0 mul1g =&gt; H1.
...
</pre></div>
</div>
</div>
<div class="section" id="terminators">
<span id="terminators-ssr"></span><h3>Terminators<a class="headerlink" href="#terminators" title="Permalink to this headline">¶</a></h3>
<p>To further structure scripts, <span class="smallcaps">SSReflect</span> supplies <em>terminating</em>
tacticals to explicitly close off tactics. When replaying scripts, we
then have the nice property that an error immediately occurs when a
closed tactic fails to prove its subgoal.</p>
<p>It is hence recommended practice that the proof of any subgoal should
end with a tactic that <em>fails if it does not solve the current goal</em>,
like <a class="reference internal" href="../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.contradiction" title="contradiction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradiction</span></code></a> or <a class="reference internal" href="tactics.html#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a>.</p>
<p>In fact, <span class="smallcaps">SSReflect</span> provides a generic tactical that turns any tactic
into a closing one (similar to <a class="reference internal" href="../proofs/automatic-tactics/auto.html#coq:tacn.now" title="now"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">now</span></code></a>). Its general syntax is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.by">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></code><a class="headerlink" href="#coq:tacn.by" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The Ltac expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">by</span></span></span> <span><span><span class="pre">[</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span class="pre">|</span> <span><span><span class="pre">…]</span></span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">do</span></span></span> <span><span><span class="pre">[done</span></span></span> <span class="pre">|</span> <span><span><span class="pre">by</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span class="pre">|</span> <span><span><span class="pre">by</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span class="pre">|</span> <span><span><span class="pre">…]</span></span></span></span></code>, which corresponds to the
standard Ltac expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">first</span></span></span> <span><span><span class="pre">[done</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">done</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">done</span></span></span> <span class="pre">|</span> <span><span><span class="pre">…]</span></span></span></span></code>.</p>
<p>In the script provided as example in Section <a class="reference internal" href="#indentation-ssr"><span class="std std-ref">Indentation and bullets</span></a>, the
paragraph corresponding to each sub-case ends with a tactic line prefixed
with a <code class="docutils literal notranslate"><span class="pre">by</span></code>, like in:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">eqP</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> -</span><span class="coqdoc-var">dvdn1</span><span>.</span><span>
</span></span></div>
<dl class="coq tacn">
<dt id="coq:tacn.done">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>done</span></span></span></code><a class="headerlink" href="#coq:tacn.done" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.by" title="by"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">by</span></code></a> tactical is implemented using the user-defined, and extensible,
<a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic. This <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic tries to solve the current goal by some
trivial means and fails if it doesn’t succeed. Indeed, the tactic
expression <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">done</span></span></span></span></code>.</p>
<p>Conversely, the tactic <code class="docutils literal notranslate"><span class="pre">by</span> <span class="pre">[</span> <span class="pre">]</span></code> is equivalent to <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a>.</p>
<p>The default implementation of the <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic, in the <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>
file, is:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">done</span><span> :=</span><span>
  </span><span class="coqdoc-tactic">trivial</span><span>; </span><span class="coqdoc-tactic">hnf</span><span>; </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">solve</span><span>
   [ </span><span class="coqdoc-tactic">do</span><span> ![</span><span class="coqdoc-tactic">solve</span><span> [</span><span class="coqdoc-tactic">trivial</span><span> | </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">sym_equal</span><span>; </span><span class="coqdoc-tactic">trivial</span><span>]</span><span>
         | </span><span class="coqdoc-tactic">discriminate</span><span> | </span><span class="coqdoc-var">contradiction</span><span> | </span><span class="coqdoc-tactic">split</span><span>]</span><span>
   | </span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">not_locked_false_eq_true</span><span>; </span><span class="coqdoc-tactic">assumption</span><span>
   | </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">H</span><span> : ~ </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">solve</span><span> [</span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">trivial</span><span>] </span><span class="coqdoc-keyword">end</span><span> ].</span><span>
</span></span></div>
<p>The lemma <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">not_locked_false_eq_true</span></span></code> is needed to discriminate
<em>locked</em> boolean predicates (see Section <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a>). The iterator
tactical <code class="docutils literal notranslate"><span class="pre">do</span></code> is presented in Section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>. This tactic can be
customized by the user, for instance to include an <a class="reference internal" href="../proofs/automatic-tactics/auto.html#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> tactic.</p>
</dd></dl>

<p>A natural and common way of closing a goal is to apply a lemma that
is the exact one needed for the goal to be solved. The defective form
of the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">exact</span><span>.</span><span>
</span></span></div>
<p>is equivalent to:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">do</span><span> [</span><span class="coqdoc-var">done</span><span> | </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">top</span><span>].</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name assigned to the top assumption of the goal.
This applied form is supported by the <code class="docutils literal notranslate"><span class="pre">:</span></code> discharge tactical, and the
tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">exact</span><span>: </span><span class="coqdoc-var">MyLemma</span><span>.</span><span>
</span></span></div>
<p>is equivalent to:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">MyLemma</span><span>.</span><span>
</span></span></div>
<p>(see Section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for the documentation of the apply: combination).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The list of tactics (possibly chained by semicolons) that
follows the <code class="docutils literal notranslate"><span class="pre">by</span></code> keyword is considered to be a parenthesized block applied to
the current goal. Hence for example if the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>.</span><span>
</span></span></div>
<p>succeeds, then the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">my_lemma2</span><span>.</span><span>
</span></span></div>
<p>usually fails since it is equivalent to:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">by</span><span> (</span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">my_lemma2</span><span>).</span><span>
</span></span></div>
</div>
</div>
<div class="section" id="selectors">
<span id="selectors-ssr"></span><h3>Selectors<a class="headerlink" href="#selectors" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.last">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>last</span></span></span></code><a class="headerlink" href="#coq:tacn.last" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.first-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>first</span></span></span></code><a class="headerlink" href="#coq:tacn.first-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>When composing tactics, the two tacticals <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code> let the user
restrict the application of a tactic to only one of the subgoals
generated by the previous tactic. This covers the frequent cases where
a tactic generates two subgoals one of which can be easily disposed
of.</p>
<p>This is another powerful way of linearization of scripts, since it
happens very often that a trivial subgoal can be solved in a less than
one line tactic. For instance, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">last</span></span></span> <span><span><span class="pre">by</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code>
tries to solve the last subgoal generated by the first
tactic using the given second tactic, and fails if it does not succeed.
Its analogue <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span><span><span class="pre">;</span></span></span> <span><span><span class="pre">first</span></span></span> <span><span><span class="pre">by</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></code>
tries to solve the first subgoal generated by the first tactic using the
second given tactic, and fails if it does not succeed.</p>
</dd></dl>

<p><span class="smallcaps">SSReflect</span> also offers an extension of this facility, by supplying
tactics to <em>permute</em> the subgoals generated by a tactic.</p>
<dl class="coq tacv">
<dt id="coq:tacv.last-first">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>last</span></span> <span><span>first</span></span></span></code><a class="headerlink" href="#coq:tacv.last-first" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacv.first-last">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>first</span></span> <span><span>last</span></span></span></code><a class="headerlink" href="#coq:tacv.first-last" title="Permalink to this definition">¶</a></dt>
<dd><p>These two equivalent tactics invert the order of the subgoals in focus.</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>last</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <span><span>first</span></span></span></code></dt>
<dd><p>If <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a>'s value is <span class="math notranslate nohighlight">\(k\)</span>,
this tactic rotates the <span class="math notranslate nohighlight">\(n\)</span> subgoals <span class="math notranslate nohighlight">\(G_1\)</span> , …, <span class="math notranslate nohighlight">\(G_n\)</span>
in focus. Subgoal <span class="math notranslate nohighlight">\(G_{n + 1 − k}\)</span> becomes the first, and the
circular order of subgoals remains unchanged.</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id11">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>first</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <span><span>last</span></span></span></code><a class="headerlink" href="#id11" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a>'s value is <span class="math notranslate nohighlight">\(k\)</span>,
this tactic rotates the <span class="math notranslate nohighlight">\(n\)</span> subgoals <span class="math notranslate nohighlight">\(G_1\)</span> , …, <span class="math notranslate nohighlight">\(G_n\)</span>
in focus. Subgoal <span class="math notranslate nohighlight">\(G_{k + 1 \bmod n}\)</span> becomes the first, and the circular order
of subgoals remains unchanged.</p>
</dd></dl>

</dd></dl>

<p>Finally, the tactics <code class="docutils literal notranslate"><span class="pre">last</span></code> and <code class="docutils literal notranslate"><span class="pre">first</span></code> combine with the branching syntax
of Ltac: if the tactic generates n subgoals on a given goal,
then the tactic</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">tactic</span><span> ; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-var">k</span><span> [ </span><span class="coqdoc-var">tactic1</span><span> |…| </span><span class="coqdoc-var">tacticm</span><span> ] || </span><span class="coqdoc-var">tacticn</span><span>.</span><span>
</span></span></div>
<p>applies <code class="docutils literal notranslate"><span class="pre">tactic1</span></code> to the
<span class="math notranslate nohighlight">\(n−k+1\)</span>-th goal, … <code class="docutils literal notranslate"><span class="pre">tacticm</span></code> to the <span class="math notranslate nohighlight">\(n−k+m\)</span>-th goal and <code class="docutils literal notranslate"><span class="pre">tacticn</span></code>
to the others.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function that
adds an element at the end of a given list.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">C1</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 1 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C2</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 2 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C3</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 3 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C4</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 4 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>test is defined
test_ind is defined
test_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">example</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">t</span><span> : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  t : test n
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: </span><span class="coqdoc-var">t</span><span>; </span><span class="coqdoc-var">last</span><span> 2 [</span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">k</span><span>| </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">l</span><span>]; </span><span class="coqdoc-tactic">idtac</span><span>.</span><span>
</span></dt><dd><span>4 goals
  
  n : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n0 : nat, n0</span><span> =</span><span> 1</span><span> -&gt;</span><span> True

goal 2 is:
 k</span><span> =</span><span> 2</span><span> -&gt;</span><span> True
goal 3 is:
 l</span><span> =</span><span> 3</span><span> -&gt;</span><span> True
goal 4 is:
 </span><span class="ansi-bold">forall</span><span> n0 : nat, n0</span><span> =</span><span> 4</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="iteration">
<span id="iteration-ssr"></span><h3>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt id="coq:tacn.do-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>do</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span></code><a class="headerlink" href="#coq:tacn.do-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactical offers an accurate control on the repetition of tactics.
<a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> is a <em>multiplier</em>.</p>
<p>Brackets can only be omitted if a single tactic is given <em>and</em> a
multiplier is present.</p>
</dd></dl>

<p>A tactic of the form:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">do</span><span> [ </span><span class="coqdoc-var">tactic</span><span> 1 | … | </span><span class="coqdoc-var">tactic</span><span> </span><span class="coqdoc-var">n</span><span> ].</span><span>
</span></span></div>
<p>is equivalent to the standard Ltac expression:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">first</span><span> [ </span><span class="coqdoc-var">tactic</span><span> 1 | … | </span><span class="coqdoc-var">tactic</span><span> </span><span class="coqdoc-var">n</span><span> ].</span><span>
</span></span></div>
<p>The optional multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> specifies how many times the action of
<code class="docutils literal notranslate"><span class="pre">tactic</span></code> should be repeated on the current subgoal.</p>
<p>There are four kinds of multipliers:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-mult"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <span><span>!</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>!</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a> <span><span>?</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Their meaning is as follows.</p>
<ul class="simple">
<li><p>With <code class="docutils literal notranslate"><span class="pre">n!</span></code>, the step tactic is repeated exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times (where <code class="docutils literal notranslate"><span class="pre">n</span></code> is a
positive integer argument).</p></li>
<li><p>With <code class="docutils literal notranslate"><span class="pre">!</span></code>, the step tactic is repeated as many times as possible, and done
at least once.</p></li>
<li><p>With <code class="docutils literal notranslate"><span class="pre">?</span></code>, the step tactic is repeated as many times as possible,
optionally.</p></li>
<li><p>Finally, with <code class="docutils literal notranslate"><span class="pre">n?</span></code>, the step tactic is repeated up to <code class="docutils literal notranslate"><span class="pre">n</span></code> times, optionally.</p></li>
</ul>
<p>For instance, the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">tactic</span><span>; </span><span class="coqdoc-tactic">do</span><span> 1? </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">mult_comm</span><span>.</span><span>
</span></span></div>
<p>rewrites at most one time the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by tactic, whereas the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">tactic</span><span>; </span><span class="coqdoc-tactic">do</span><span> 2! </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">mult_comm</span><span>.</span><span>
</span></span></div>
<p>rewrites exactly two times the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by <code class="docutils literal notranslate"><span class="pre">tactic</span></code>, and fails if this rewrite is not possible in some
subgoal.</p>
<p>Note that the combination of multipliers and rewrite is so often used
that multipliers are in fact integrated to the syntax of the
<span class="smallcaps">SSReflect</span> rewrite tactic, see Section <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>.</p>
</div>
<div class="section" id="localization">
<span id="localization-ssr"></span><h3>Localization<a class="headerlink" href="#localization" title="Permalink to this headline">¶</a></h3>
<p>In Sections <a class="reference internal" href="#basic-localization-ssr"><span class="std std-ref">Basic localization</span></a> and <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>, we have
already presented the <em>localization</em> tactical <code class="docutils literal notranslate"><span class="pre">in</span></code>, whose general syntax is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.in">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>*</span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.in" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a name in the
context. On the left side of <code class="docutils literal notranslate"><span class="pre">in</span></code>,
<a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a> can be <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>, <code class="docutils literal notranslate"><span class="pre">rewrite</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code>,
or any tactic formed with the general iteration tactical <code class="docutils literal notranslate"><span class="pre">do</span></code> (see Section
<a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>).</p>
<p>The operation described by the tactic is performed in the facts listed after
<code class="docutils literal notranslate"><span class="pre">in</span></code> and in the goal if a <code class="docutils literal notranslate"><span class="pre">*</span></code> ends the list of names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical successively:</p>
<ul class="simple">
<li><p>generalizes the selected hypotheses, possibly “protecting” the goal
if <code class="docutils literal notranslate"><span class="pre">*</span></code> is not present;</p></li>
<li><p>performs <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code></a>, on the obtained goal;</p></li>
<li><p>reintroduces the generalized facts, under the same names.</p></li>
</ul>
<p>This defective form of the <code class="docutils literal notranslate"><span class="pre">do</span></code> tactical is useful to avoid clashes
between standard Ltac <code class="docutils literal notranslate"><span class="pre">in</span></code> and the <span class="smallcaps">SSReflect</span> tactical in.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">mytac</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>mytac is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">H1</span><span> : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>) (</span><span class="coqdoc-var">H2</span><span> : </span><span class="coqdoc-var">y</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = 6.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  H1 : x</span><span> =</span><span> y
  H2 : y</span><span> =</span><span> 3
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> 6
</span></dd>
<dt><span></span><span class="coqdoc-tactic">do</span><span> [</span><span class="coqdoc-var">mytac</span><span> </span><span class="coqdoc-var">H2</span><span>] </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H1</span><span> *.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  H2 : y</span><span> =</span><span> 3
  H1 : x</span><span> =</span><span> 3
  ============================
  x</span><span> +</span><span> 3</span><span> =</span><span> 6
</span></dd>
</dl>
</div>
<p>the last tactic rewrites the hypothesis <code class="docutils literal notranslate"><span class="pre">H2</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">3</span></code> both in
<code class="docutils literal notranslate"><span class="pre">H1</span> <span class="pre">:</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> and in the goal <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">6</span></code>.</p>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">in</span></code> keeps the body of local definitions. To erase the body
of a local definition during the generalization phase, the name of the
local definition must be written between parentheses, like in
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">H</span> <span class="pre">in</span> <span class="pre">H1</span> <span class="pre">(def_n)</span> <span class="pre">H2.</span></code></p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span><span>)</span></span></span></span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>*</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is the most general form of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical.
In its simplest form, the last option lets one rename hypotheses that
can’t be cleared (like section variables). For example, <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:=</span> <span class="pre">x)</span></code>
generalizes over <code class="docutils literal notranslate"><span class="pre">x</span></code> and reintroduces the generalized variable under the
name <code class="docutils literal notranslate"><span class="pre">y</span></code> (and does not clear <code class="docutils literal notranslate"><span class="pre">x</span></code>).
For a more precise description of this form of localization, refer
to <a class="reference internal" href="#advanced-generalization-ssr"><span class="std std-ref">Advanced generalization</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="structure">
<span id="structure-ssr"></span><h3>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h3>
<p>Forward reasoning structures the script by explicitly specifying some
assumptions to be added to the proof context. It is closely associated
with the declarative style of proof, since an extensive use of these
highlighted statements makes the script closer to a (very detailed)
textbook proof.</p>
<p>Forward chaining tactics allow to state an intermediate lemma and start a
piece of script dedicated to the proof of this statement. The use of closing
tactics (see Section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and of indentation makes
syntactically explicit the portion of the script building the proof of the
intermediate statement.</p>
<div class="section" id="the-have-tactic">
<h4>The have tactic.<a class="headerlink" href="#the-have-tactic" title="Permalink to this headline">¶</a></h4>
<dl class="coq tacn">
<dt id="coq:tacn.have">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.have" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main <span class="smallcaps">SSReflect</span> forward reasoning tactic. It can
be used in two modes: one starts a new (sub)proof for an intermediate
result in the main proof, and the other provides explicitly a proof
term for this intermediate step.</p>
<p>This tactic supports open syntax for <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. Applied to a goal <code class="docutils literal notranslate"><span class="pre">G</span></code>, it
generates a first subgoal requiring a proof of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in the context of
<code class="docutils literal notranslate"><span class="pre">G</span></code>. The second generated subgoal is of the form <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">term</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">G</span></span></span></span></code>, where term
becomes the new top assumption, instead of being introduced with a
fresh name. At the proof-term level, the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic creates a β
redex, and introduces the lemma under a fresh name, automatically
chosen.</p>
</dd></dl>

<p>Like in the case of the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">pose</span></span></span> <span><span><span class="pre">(ssreflect)</span></span></span></span></code> tactic (see Section <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a>), the types of
the holes are abstracted in term.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-var">_</span><span> * 0 = 0.</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> *</span><span> 0</span><span> =</span><span> 0

goal 2 is:
 (</span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> *</span><span> 0</span><span> =</span><span> 0)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
<p>The invocation of <code class="docutils literal notranslate"><span class="pre">have</span></code> is equivalent to:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> * 0 = 0.</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> *</span><span> 0</span><span> =</span><span> 0

goal 2 is:
 (</span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> *</span><span> 0</span><span> =</span><span> 0)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic also enjoys the same abstraction mechanism as the <a class="reference internal" href="#coq:tacn.pose-(ssreflect)" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span> <span class="pre">(ssreflect)</span></code></a>
tactic for the non-inferred implicit arguments. For instance, the
tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>) = (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span> + 0).</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (T : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : T) (y : nat), </span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span> =</span><span> </span><span>(</span><span>x</span><span>,</span><span> y</span><span> +</span><span> 0</span><span>)</span><span>

goal 2 is:
 (</span><span class="ansi-bold">forall</span><span> (T : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : T) (y : nat), </span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span> =</span><span> </span><span>(</span><span>x</span><span>,</span><span> y</span><span> +</span><span> 0</span><span>)</span><span>)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
<p>opens a new subgoal where the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> is quantified.</p>
</div>
<p>The behavior of the defective have tactic makes it possible to
generalize it in the following general construction:</p>
<dl class="coq tacn">
<dt id="id12">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#id12" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Open syntax is supported for both <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. For the description
of <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, see Section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>. The first mode of the
have tactic, which opens a sub-proof for an intermediate result, uses
tactics of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></code></dt>
<dd></dd></dl>

<p>which behaves like:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-var">term</span><span> ; </span><span class="coqdoc-tactic">first</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">tactic</span><span>.</span><span>
</span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">clear_switch</span><span> </span><span class="coqdoc-var">i_item</span><span>.</span><span>
</span></span></div>
<p>Note that the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> <em>precedes</em> the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, which
allows to reuse
a name of the context, possibly used by the proof of the assumption,
to introduce the new assumption itself.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">by</span></code> feature is especially convenient when the proof script of the
statement is very short, basically when it fits in one line like in:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H23</span><span> : 3 + 2 = 2 + 3 </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">addnC</span><span>.</span><span>
</span></span></div>
<p>The possibility of using <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> supplies a very concise syntax for
the further use of the intermediate step. For instance,</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : 3 * </span><span class="coqdoc-var">a</span><span> - 1 = </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a : nat
  ============================
  3</span><span> *</span><span> a</span><span> -</span><span> 1</span><span> =</span><span> a
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> -&gt; : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  a : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> *</span><span> a</span><span> =</span><span> a

goal 2 is:
 a</span><span> -</span><span> 1</span><span> =</span><span> a
</span></dd>
</dl>
</div>
<p>Note how the second goal was rewritten using the stated equality.
Also note that in this last subgoal, the intermediate result does not
appear in the context.</p>
</div>
<p>Thanks to the deferred execution of clears, the following idiom is
also supported (assuming x occurs in the goal only):</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">have</span><span> {</span><span class="coqdoc-var">x</span><span>} -&gt; : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></span></div>
<p>Another frequent use of the intro patterns combined with <code class="docutils literal notranslate"><span class="pre">have</span></code> is the
destruction of existential assumptions like in the tactic:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> [</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>]: </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> &gt; 0; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">first</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x : nat
  Px : x</span><span> &gt;</span><span> 0
  ============================
  True

goal 2 is:
 </span><span>exists</span><span> x : nat</span><span>,</span><span> x</span><span> &gt;</span><span> 0
</span></dd>
</dl>
</div>
</div>
<p>An alternative use of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is to provide the explicit proof
term for the intermediate lemma, using tactics of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This tactic creates a new assumption of type the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
If the
optional <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is present, this assumption is introduced under the
name <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. Note that the body of the constant is lost for the user.</p>
<p>Again, non-inferred implicit arguments and explicit holes are
abstracted.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span>) = (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  ============================
  True
</span></dd>
</dl>
</div>
<p>adds to the context <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Prop.</span></code> This is a schematic example, but
the feature is specially useful when the proof term to give involves
for instance a lemma with some hidden implicit arguments.</p>
</div>
<p>After the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, a list of binders is allowed.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ZArith</span><span> </span><span class="coqdoc-var">Lia</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>[Loading ML file ring_plugin.cmxs (using legacy method) ... done]
[Loading ML file zify_plugin.cmxs (using legacy method) ... done]
[Loading ML file micromega_plugin.cmxs (using legacy method) ... done]
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>) : 2 * </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> x y : nat, 2</span><span> *</span><span> x</span><span> +</span><span> y</span><span> =</span><span> x</span><span> +</span><span> x</span><span> +</span><span> y
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>A proof term provided after <code class="docutils literal notranslate"><span class="pre">:=</span></code> can mention these bound variables
(that are automatically introduced with the given names).
Since the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be omitted, to avoid ambiguity,
bound variables can be surrounded
with parentheses even if no type is specified:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span> (</span><span class="coqdoc-var">x</span><span>) : 2 * </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  (</span><span class="ansi-bold">forall</span><span> x : nat, 2</span><span> *</span><span> x</span><span> =</span><span> x</span><span> +</span><span> x)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
<p>The <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can be used to interpret the asserted
hypothesis with views (see Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) or simplify the resulting
goals.</p>
<p>The <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a> tactic also supports a <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier that allows for
asserting that a given statement implies the current goal without
copying the goal itself.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">suff</span><span> </span><span class="coqdoc-var">H</span><span> : 2 + 2 = 3; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">first</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  H : 2</span><span> +</span><span> 2</span><span> =</span><span> 3</span><span> -&gt;</span><span> True
  ============================
  True

goal 2 is:
 2</span><span> +</span><span> 2</span><span> =</span><span> 3</span><span> -&gt;</span><span> True
</span></dd>
</dl>
</div>
<p>Note that H is introduced in the second goal.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier is not
compatible with the presence of a list of binders.</p>
</div>
<div class="section" id="generating-let-in-context-entries-with-have">
<span id="generating-let-ssr"></span><h4>Generating let in context entries with have<a class="headerlink" href="#generating-let-in-context-entries-with-have" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5, the <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a> tactic supports a “transparent” modifier
to generate <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">in</span></code> context entries: the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> symbol in front of the
context entry name.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Depth</span><span> 15.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>Ord is defined
Ord_rect is defined
Ord_ind is defined
Ord_rec is defined
Ord_sind is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;'I_ n&quot; := (</span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 8, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-var">format</span><span> &quot;''I_' n&quot;).</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Arguments</span><span> </span><span class="coqdoc-var">Sub</span><span> {</span><span class="coqdoc-var">_</span><span>} </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  i := Sub m
         (</span><span class="ansi-fg-light-magenta">ZifyClasses</span><span>.</span><span class="ansi-fg-light-green">rew_iff_rev</span><span> (m</span><span> &lt;</span><span> n) (</span><span class="ansi-fg-light-magenta">Z</span><span>.</span><span class="ansi-fg-light-green">of_nat</span><span> m</span><span> &lt;</span><span> </span><span class="ansi-fg-light-magenta">Z</span><span>.</span><span class="ansi-fg-light-green">of_nat</span><span> n)%Z
            (</span><span class="ansi-fg-light-magenta">ZifyClasses</span><span>.</span><span class="ansi-fg-light-green">mkrel</span><span> nat Z lt </span><span class="ansi-fg-light-magenta">Z</span><span>.</span><span class="ansi-fg-light-green">of_nat</span><span> </span><span class="ansi-fg-light-magenta">Z</span><span>.</span><span class="ansi-fg-light-green">lt</span><span> </span><span class="ansi-fg-light-magenta">Nat2Z</span><span>.</span><span class="ansi-fg-light-green">inj_lt</span><span> m 
               (...) eq_refl n (...) eq_refl)
            (</span><span class="ansi-bold">let</span><span> H0 : ...%Z := ... </span><span class="ansi-bold">in</span><span> ... ...)) : </span><span>'I_</span><span>n
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>Note that the subterm produced by <a class="reference internal" href="../addendum/micromega.html#coq:tacn.lia" title="lia"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lia</span></code></a> is in general huge and
uninteresting, and hence one may want to hide it.
For this purpose the <code class="docutils literal notranslate"><span class="pre">[:</span> <span class="pre">name]</span></code> intro pattern and the tactic
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> (see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a>) are provided.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-tactic">abstract</span><span>: </span><span class="coqdoc-var">pm</span><span>; </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  pm : m</span><span> &lt;</span><span> n</span><span> </span><span>(*</span><span>1</span><span>*)</span><span>
  i := Sub m pm : </span><span>'I_</span><span>n
  ============================
  True
</span></dd>
</dl>
</div>
<p>The type of <code class="docutils literal notranslate"><span class="pre">pm</span></code> can be cleaned up by its annotation <code class="docutils literal notranslate"><span class="pre">(*1*)</span></code> by just
simplifying it. The annotations are there for technical reasons only.</p>
</div>
<p>When intro patterns for abstract constants are used in conjunction
with`` have`` and an explicit term, they must be used as follows:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">pm</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  ============================
  S m</span><span> &lt;=</span><span> n

goal 2 is:
 True
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  pm : S m</span><span> &lt;=</span><span> n</span><span> </span><span>(*</span><span>1</span><span>*)</span><span>
  i := Sub m pm</span><span> </span><span>:</span><span> </span><span>'I_</span><span>n : </span><span>'I_</span><span>n
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>In this case, the abstract constant <code class="docutils literal notranslate"><span class="pre">pm</span></code> is assigned by using it in
the term that follows <code class="docutils literal notranslate"><span class="pre">:=</span></code> and its corresponding goal is left to be
solved. Goals corresponding to intro patterns for abstract constants
are opened in the order in which the abstract constants are declared
(not in the “order” in which they are used in the term).</p>
<p>Note that abstract constants do respect scopes. Hence, if a variable
is declared after their introduction, it has to be properly
generalized (i.e., explicitly passed to the abstract constant when one
makes use of it).</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">k</span><span> : '</span><span class="coqdoc-var">I_</span><span>(</span><span class="coqdoc-var">n</span><span>+</span><span class="coqdoc-var">k</span><span>) </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-tactic">abstract</span><span>: </span><span class="coqdoc-var">pm</span><span> </span><span class="coqdoc-var">k</span><span>; </span><span class="coqdoc-var">lia</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : m</span><span> +</span><span> 1</span><span> &lt;</span><span> n
  pm : (</span><span class="ansi-bold">forall</span><span> k : nat, m</span><span> &lt;</span><span> n</span><span> +</span><span> k)</span><span> </span><span>(*</span><span>1</span><span>*)</span><span>
  i := </span><span class="ansi-bold">fun</span><span> k : nat =&gt; Sub m (pm k) : </span><span class="ansi-bold">forall</span><span> k : nat, </span><span>'I_</span><span>(n</span><span> +</span><span> k)
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>Last, notice that the use of intro patterns for abstract constants is
orthogonal to the transparent flag <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> for <code class="docutils literal notranslate"><span class="pre">have</span></code>.</p>
</div>
<div class="section" id="the-have-tactic-and-typeclass-resolution">
<h4>The have tactic and typeclass resolution<a class="headerlink" href="#the-have-tactic-and-typeclass-resolution" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5, the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic behaves as follows with respect to
typeclass inference.</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">ty</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>ty is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">t</span><span> : </span><span class="coqdoc-var">ty</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>t is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  ty

goal 2 is:
 True
</span></dd>
</dl>
</div>
<p>Full inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a
proof of such instantiated statement.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span> := .</span><span>
</span></span></div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. Unresolved instances are
quantified in <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a proof of such quantified
statement. Note that no proof term follows <code class="docutils literal notranslate"><span class="pre">:=</span></code>; hence two subgoals are
generated.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span> := </span><span class="coqdoc-var">t</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  foo : ty
  ============================
  True
</span></dd>
</dl>
</div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> := </span><span class="coqdoc-var">t</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  foo : ty
  ============================
  True
</span></dd>
</dl>
</div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">t</span></code>. Unresolved instances are
quantified in the (inferred) type of <code class="docutils literal notranslate"><span class="pre">t</span></code> and abstracted in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</div></blockquote>
<dl class="coq flag">
<dt id="coq:flag.SsrHave-NoTCResolution">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>SsrHave</span></span> <span><span>NoTCResolution</span></span></span></code><a class="headerlink" href="#coq:flag.SsrHave-NoTCResolution" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> restores the behavior of <span class="smallcaps">SSReflect</span> 1.4 and below (never resolve typeclasses).</p>
</dd></dl>

</div>
<div class="section" id="variants-the-suff-and-wlog-tactics">
<h4>Variants: the suff and wlog tactics<a class="headerlink" href="#variants-the-suff-and-wlog-tactics" title="Permalink to this headline">¶</a></h4>
<p>As is often the case in mathematical textbooks, forward reasoning
may be used in slightly different variants. One of these variants is
to show that the intermediate step L easily implies the initial goal
G. By easily we mean here that the proof of L ⇒ G is shorter than the
one of L itself. This kind of reasoning step usually starts with: “It
suffices to show that …”.</p>
<p>This is such a frequent way of reasoning that <span class="smallcaps">SSReflect</span> has a variant
of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic called <code class="docutils literal notranslate"><span class="pre">suffices</span></code> (whose abridged name is <code class="docutils literal notranslate"><span class="pre">suff</span></code>).
The
<code class="docutils literal notranslate"><span class="pre">have</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactics are equivalent and have the same syntax but:</p>
<ul>
<li><p>the order of the generated subgoals is inverted;</p></li>
<li><p>the optional clear item is still performed in the <em>second</em>
branch, which means that the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">suff</span><span> {</span><span class="coqdoc-var">H</span><span>} </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> &gt;= 0.</span><span>
</span></span></div>
<p>fails if the context of the current goal indeed contains an
assumption named <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
</li>
</ul>
<p>The rationale of this clearing policy is to make possible “trivial”
refinements of an assumption, without changing its name in the main
branch of the reasoning.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> modifier can follow the <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axioms</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>G is declared
P is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">G</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  G
</span></dd>
<dt><span></span><span class="coqdoc-var">suff</span><span> </span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">P</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  H : P
  ============================
  G

goal 2 is:
 (P</span><span> -&gt;</span><span> G)</span><span> -&gt;</span><span> G
</span></dd>
</dl>
</div>
<p>Note that, in contrast with <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">suff</span></code>, the name H has been introduced
in the first goal.</p>
</div>
<p>Another useful construct is reduction, showing that a particular case
is in fact general enough to prove a general property. This kind of
reasoning step usually starts with: “Without loss of generality, we
can suppose that …”. Formally, this corresponds to the proof of a goal
<code class="docutils literal notranslate"><span class="pre">G</span></code> by introducing a cut: <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. Hence the user shall
provide a proof for both <code class="docutils literal notranslate"><span class="pre">(wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G)</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code> and
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. However, such cuts are usually rather
painful to perform by
hand, because the statement <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> is tedious to write by hand,
and sometimes even to read.</p>
<p><span class="smallcaps">SSReflect</span> implements this kind of reasoning step through the <a class="reference internal" href="#coq:tacn.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>
tactic, whose short name is <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>. It offers support to describe
the shape of the cut statements, by providing the simplifying
hypothesis and by pointing at the elements of the initial goals that
should be generalized. The general syntax of without loss is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.wlog">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>wlog</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>suff</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.wlog" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.without-loss">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>without</span></span> <span><span>loss</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>suff</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.without-loss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>where each <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a constant in the context
of the goal. Open syntax is supported for <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>In its defective form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>wlog:</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>without</span></span> <span><span>loss:</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>on a goal G, it creates two subgoals: a first one to prove the
formula (term -&gt; G) -&gt; G and a second one to prove the formula
term -&gt; G.</p>
<p>If the optional list of <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is present
on the left side of <code class="docutils literal notranslate"><span class="pre">/</span></code>, these constants are generalized in the
premise (term -&gt; G) of the first subgoal. By default bodies of local
definitions are erased. This behavior can be inhibited by prefixing the
name of the local definition with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> character.</p>
<p>In the second subgoal, the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">clear_switch</span><span> </span><span class="coqdoc-var">i_item</span><span>.</span><span>
</span></span></div>
<p>is performed if at least one of these optional switches is present in
the <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic.</p>
<p>The <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic is specially useful when a symmetry argument
simplifies a proof. Here is an example showing the beginning of the
proof that quotient and reminder of natural number euclidean division
are unique.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">quo_rem_unicity</span><span> </span><span class="coqdoc-var">d</span><span> </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span> </span><span class="coqdoc-var">r1</span><span> </span><span class="coqdoc-var">r2</span><span> :</span><span>
  </span><span class="coqdoc-var">q1</span><span>*</span><span class="coqdoc-var">d</span><span> + </span><span class="coqdoc-var">r1</span><span> = </span><span class="coqdoc-var">q2</span><span>*</span><span class="coqdoc-var">d</span><span> + </span><span class="coqdoc-var">r2</span><span> -&gt; </span><span class="coqdoc-var">r1</span><span> &lt; </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-var">r2</span><span> &lt; </span><span class="coqdoc-var">d</span><span> -&gt; (</span><span class="coqdoc-var">q1</span><span>, </span><span class="coqdoc-var">r1</span><span>) = (</span><span class="coqdoc-var">q2</span><span>, </span><span class="coqdoc-var">r2</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  d, q1, q2, r1, r2 : nat
  ============================
  q1</span><span> *</span><span> d</span><span> +</span><span> r1</span><span> =</span><span> q2</span><span> *</span><span> d</span><span> +</span><span> r2</span><span> -&gt;</span><span> r1</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> r2</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> </span><span>(</span><span>q1</span><span>,</span><span> r1</span><span>)</span><span> =</span><span> </span><span>(</span><span>q2</span><span>,</span><span> r2</span><span>)</span><span>
</span></dd>
<dt><span></span><span class="coqdoc-var">wlog</span><span>: </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span> </span><span class="coqdoc-var">r1</span><span> </span><span class="coqdoc-var">r2</span><span> / </span><span class="coqdoc-var">q1</span><span> &lt;= </span><span class="coqdoc-var">q2</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  d, q1, q2, r1, r2 : nat
  ============================
  (</span><span class="ansi-bold">forall</span><span> q3 q4 r3 r4 : nat,
   q3</span><span> &lt;=</span><span> q4</span><span> -&gt;</span><span>
   q3</span><span> *</span><span> d</span><span> +</span><span> r3</span><span> =</span><span> q4</span><span> *</span><span> d</span><span> +</span><span> r4</span><span> -&gt;</span><span> r3</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> r4</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> </span><span>(</span><span>q3</span><span>,</span><span> r3</span><span>)</span><span> =</span><span> </span><span>(</span><span>q4</span><span>,</span><span> r4</span><span>)</span><span>)</span><span> -&gt;</span><span>
  q1</span><span> *</span><span> d</span><span> +</span><span> r1</span><span> =</span><span> q2</span><span> *</span><span> d</span><span> +</span><span> r2</span><span> -&gt;</span><span> r1</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> r2</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> </span><span>(</span><span>q1</span><span>,</span><span> r1</span><span>)</span><span> =</span><span> </span><span>(</span><span>q2</span><span>,</span><span> r2</span><span>)</span><span>

goal 2 is:
 q1</span><span> &lt;=</span><span> q2</span><span> -&gt;</span><span>
 q1</span><span> *</span><span> d</span><span> +</span><span> r1</span><span> =</span><span> q2</span><span> *</span><span> d</span><span> +</span><span> r2</span><span> -&gt;</span><span> r1</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> r2</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> </span><span>(</span><span>q1</span><span>,</span><span> r1</span><span>)</span><span> =</span><span> </span><span>(</span><span>q2</span><span>,</span><span> r2</span><span>)</span><span>
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">case</span><span> (</span><span class="coqdoc-var">le_gt_dec</span><span> </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span>)=&gt; </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">symmetry</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">arith</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  d, q1, q2, r1, r2 : nat
  ============================
  q1</span><span> &lt;=</span><span> q2</span><span> -&gt;</span><span>
  q1</span><span> *</span><span> d</span><span> +</span><span> r1</span><span> =</span><span> q2</span><span> *</span><span> d</span><span> +</span><span> r2</span><span> -&gt;</span><span> r1</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> r2</span><span> &lt;</span><span> d</span><span> -&gt;</span><span> </span><span>(</span><span>q1</span><span>,</span><span> r1</span><span>)</span><span> =</span><span> </span><span>(</span><span>q2</span><span>,</span><span> r2</span><span>)</span><span>
</span></dd>
</dl>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span></code> variant is simpler, since it cuts <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. It thus opens the goals
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>
and <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code>.</p>
<p>In its simplest form, the <code class="docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span> <span class="pre">:</span> <span class="pre">…</span></code> tactic is equivalent to
<code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span> <span class="pre">:</span> <span class="pre">…</span></code> followed by <code class="docutils literal notranslate"><span class="pre">last</span> <span class="pre">first</span></code>. When the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is used
with the <code class="docutils literal notranslate"><span class="pre">generally</span></code> (or <code class="docutils literal notranslate"><span class="pre">gen</span></code>) modifier, it accepts an extra identifier
followed by a comma before the usual intro pattern. The identifier
will name the new hypothesis in its more general form, while the intro
pattern will be used to process its instance.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axioms</span><span> </span><span class="coqdoc-var">eqn</span><span> </span><span class="coqdoc-var">leqn</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>eqn is declared
leqn is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Declare Scope</span><span> </span><span class="coqdoc-var">this_scope</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;a != b&quot; := (</span><span class="coqdoc-var">eqn</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 70) : </span><span class="coqdoc-var">this_scope</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;a &lt;= b&quot; := (</span><span class="coqdoc-var">leqn</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 70) : </span><span class="coqdoc-var">this_scope</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">this_scope</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-tactic">simple</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">ngt0</span><span> : 0 &lt; </span><span class="coqdoc-var">n</span><span> ) : </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  ngt0 : 0</span><span> &lt;</span><span> n
  ============================
  P n
</span></dd>
<dt><span></span><span class="coqdoc-var">gen</span><span> </span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">ltnV</span><span>, /</span><span class="coqdoc-var">andP</span><span>[</span><span class="coqdoc-var">nge0</span><span> </span><span class="coqdoc-var">neq0</span><span>] : </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">ngt0</span><span> / (0 &lt;= </span><span class="coqdoc-var">n</span><span>) &amp;&amp; (</span><span class="coqdoc-var">n</span><span> != 0); </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">first</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  n : nat
  ngt0 : 0</span><span> &lt;</span><span> n
  ltnV : </span><span class="ansi-bold">forall</span><span> n : nat, 0</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> (0</span><span> &lt;=</span><span> n)</span><span> &amp;&amp;</span><span> (n </span><span>!= </span><span>0)
  nge0 : 0</span><span> &lt;=</span><span> n
  neq0 : n </span><span>!= </span><span>0
  ============================
  P n

goal 2 is:
 (0</span><span> &lt;=</span><span> n)</span><span> &amp;&amp;</span><span> (n </span><span>!= </span><span>0)
</span></dd>
</dl>
</div>
</div>
<div class="section" id="advanced-generalization">
<span id="advanced-generalization-ssr"></span><h5>Advanced generalization<a class="headerlink" href="#advanced-generalization" title="Permalink to this headline">¶</a></h5>
<p>The complete syntax for the items on the left hand side of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
separator is the following one:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>wlog</span></span> <span><span>…</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span><span>)</span></span></span></span></span><span class="notation-sup">?</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Clear operations are intertwined with generalization operations. This
helps in particular avoiding dependency issues while generalizing some
facts.</p>
<p>If an <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is prefixed with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> mark, then a let-in redex is
created, which keeps track of its body (if any). The syntax
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole"><span class="pre">c_pattern</span></span></a><span><span><span class="pre">)</span></span></span></span></code> allows to generalize an arbitrary term using a
given name. Note that its simplest form <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> is just a renaming of
<code class="docutils literal notranslate"><span class="pre">y</span></code> into <code class="docutils literal notranslate"><span class="pre">x</span></code>. In particular, this can be useful in order to simulate the
generalization of a section variable, otherwise not allowed. Indeed,
renaming does not require the original variable to be cleared.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">(&#64;x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> generates a let-in abstraction but with the
following caveat: <code class="docutils literal notranslate"><span class="pre">x</span></code> will not bind <code class="docutils literal notranslate"><span class="pre">y</span></code>, but its body, whenever <code class="docutils literal notranslate"><span class="pre">y</span></code> can be
unfolded. This covers the case of both local and global definitions, as
illustrated in the following example.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd><span>x is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>addx is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  ============================
  x</span><span> &lt;=</span><span> addx x
</span></dd>
<dt><span></span><span class="coqdoc-var">wlog</span><span> </span><span class="coqdoc-var">H</span><span> : (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span>) (&#64;</span><span class="coqdoc-var">twoy</span><span> := </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>) / </span><span class="coqdoc-var">twoy</span><span> = 2 * </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x : nat
  ============================
  (</span><span class="ansi-bold">forall</span><span> y : nat, </span><span class="ansi-bold">let</span><span> twoy := y</span><span> +</span><span> y </span><span class="ansi-bold">in</span><span> twoy</span><span> =</span><span> 2</span><span> *</span><span> y</span><span> -&gt;</span><span> y</span><span> &lt;=</span><span> twoy)</span><span> -&gt;</span><span>
  x</span><span> &lt;=</span><span> addx x

goal 2 is:
 y</span><span> &lt;=</span><span> twoy
</span></dd>
</dl>
</div>
<p>To avoid unfolding the term captured by the pattern <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">x</span></code>, one can use
the pattern <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">(addx</span> <span class="pre">x)</span></code>, which would produce the following first
subgoal</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">Lia</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>x is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>addx is defined
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x : nat
  ============================
  x</span><span> &lt;=</span><span> addx x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">wlog</span><span> </span><span class="coqdoc-var">H</span><span> : (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span>) (&#64;</span><span class="coqdoc-var">twoy</span><span> := </span><span class="coqdoc-var">id</span><span> (</span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>)) / </span><span class="coqdoc-var">twoy</span><span> = 2 * </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x : nat
  ============================
  (</span><span class="ansi-bold">forall</span><span> y : nat, </span><span class="ansi-bold">let</span><span> twoy := addx y </span><span class="ansi-bold">in</span><span> twoy</span><span> =</span><span> 2</span><span> *</span><span> y</span><span> -&gt;</span><span> y</span><span> &lt;=</span><span> addx y)</span><span> -&gt;</span><span>
  x</span><span> &lt;=</span><span> addx x

goal 2 is:
 y</span><span> &lt;=</span><span> addx y
</span></dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="rewriting">
<span id="rewriting-ssr"></span><h2>Rewriting<a class="headerlink" href="#rewriting" title="Permalink to this headline">¶</a></h2>
<p>The generalized use of reflection implies that most of the
intermediate results handled are properties of effectively computable
functions. The most efficient means of establishing such results are
computation and simplification of expressions involving such
functions, i.e., rewriting. <span class="smallcaps">SSReflect</span> therefore includes an
extended <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic that unifies and combines most of the
rewriting functionalities.</p>
<div class="section" id="an-extended-rewrite-tactic">
<h3>An extended rewrite tactic<a class="headerlink" href="#an-extended-rewrite-tactic" title="Permalink to this headline">¶</a></h3>
<p>The main features of the rewrite tactic are:</p>
<ul class="simple">
<li><p>it can perform an entire series of such operations in any subset of
the goal and/or context;</p></li>
<li><p>it allows to perform rewriting, simplifications, folding/unfolding
of definitions, closing of goals;</p></li>
<li><p>several rewriting operations can be chained in a single tactic;</p></li>
<li><p>control over the occurrence at which rewriting is to be performed is
significantly enhanced.</p></li>
</ul>
<p>The general form of an <span class="smallcaps">SSReflect</span> rewrite tactic is:</p>
<dl class="coq tacn">
<dt id="coq:tacn.rewrite-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>rewrite</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-rstep"><span class="hole">rstep</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.rewrite-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The combination of a rewrite tactic with the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical (see Section
<a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>) performs rewriting in both the context and the goal.</p>
<p>A rewrite step <a class="reference internal" href="#grammar-token-rstep"><code class="xref std std-token docutils literal notranslate"><span class="pre">rstep</span></code></a> has the general form:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-rstep"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-rstep"><span class="hole">rstep</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_prefix"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>-</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>[</span></span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span><span>]</span></span></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>as</span></span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span><span>/</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>An <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> contains annotations to qualify where and how the rewrite
operation should be performed.</p>
<ul>
<li><p>The optional initial <code class="docutils literal notranslate"><span class="pre">-</span></code> indicates the direction of the rewriting of
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>:
if present, the direction is right-to-left and it is left-to-right otherwise.</p></li>
<li><p>The multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> (see Section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)
specifies if and how the
rewrite operation should be repeated.</p></li>
<li><p>A rewrite operation matches the occurrences of a <em>rewrite pattern</em>,
and replaces these occurrences by another term, according to the
given <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The optional <em>redex switch</em> <code class="docutils literal notranslate"><span class="pre">[r_pattern]</span></code>,
which should
always be surrounded by brackets, gives explicitly this rewrite
pattern. In its simplest form, it is a regular term. If no explicit
redex switch is present, the rewrite pattern to be matched is inferred
from the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</p></li>
<li><p>This optional term, or the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, may be preceded by an
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (see Section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) or a
<a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (see Section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>),
these two possibilities being exclusive.</p>
<p>An occurrence switch selects
the occurrences of the rewrite pattern that should be affected by the
rewrite operation.</p>
<p>A clear switch, even an empty one, is performed <em>after</em> the
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> is actually processed and is complemented with the name of
the rewrite rule if and only if it is a simple proof context entry <a class="footnote-reference brackets" href="#id51" id="id13">20</a>.
As a consequence, one can
write <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">{}H</span></code> to rewrite with <code class="docutils literal notranslate"><span class="pre">H</span></code> and dispose <code class="docutils literal notranslate"><span class="pre">H</span></code> immediately
afterwards.
This behavior can be avoided by putting parentheses around the rewrite rule.</p>
</li>
</ul>
<p>A <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> can be one of the following.</p>
<ul>
<li><p>A <em>simplification</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>,
represented by a <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> (see Section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>). Simplification operations are intertwined with the possible
other rewrite operations specified by the list of <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</p></li>
<li><p>A <em>folding/unfolding</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The tactic
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/term</span></code> unfolds the
<a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a> of <code class="docutils literal notranslate"><span class="pre">term</span></code> in every occurrence of the first matching of
<code class="docutils literal notranslate"><span class="pre">term</span></code> in the goal. In particular, if <code class="docutils literal notranslate"><span class="pre">my_def</span></code> is a (local or global)
defined constant, the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/my_def.</span></code> is analogous to:
<code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">my_def</span></code>.
Conversely, <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/my_def.</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">my_def</span></code>.
When an unfold <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> is combined with a
redex pattern, a conversion
operation is performed. A tactic of the form
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-[term1]/term2.</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">change</span> <span class="pre">term1</span> <span class="pre">with</span> <span class="pre">term2.</span></code> If <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a
single constant and <code class="docutils literal notranslate"><span class="pre">term1</span></code> head symbol is not <code class="docutils literal notranslate"><span class="pre">term2</span></code>, then the head
symbol of <code class="docutils literal notranslate"><span class="pre">term1</span></code> is repeatedly unfolded until <code class="docutils literal notranslate"><span class="pre">term2</span></code> appears.</p></li>
<li><dl class="simple">
<dt>A <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> can be:</dt><dd><ul class="simple">
<li><p>a term whose type has the form:
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x1</span> <span class="pre">:</span> <span class="pre">A1</span> <span class="pre">)…(xn</span> <span class="pre">:</span> <span class="pre">An</span> <span class="pre">),</span> <span class="pre">eq</span> <span class="pre">term1</span> <span class="pre">term2</span></code>, where
<code class="docutils literal notranslate"><span class="pre">eq</span></code> is the Leibniz equality or a registered setoid
equality;</p></li>
<li><p>a list of terms <code class="docutils literal notranslate"><span class="pre">(t1</span> <span class="pre">,…,tn)</span></code>, each <code class="docutils literal notranslate"><span class="pre">ti</span></code> having a type as above, and
the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">(t1</span> <span class="pre">,…,tn</span> <span class="pre">).</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">[rewrite</span> <span class="pre">r_prefix</span> <span class="pre">t1</span> <span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span> <span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">tn</span> <span class="pre">].</span></code>;</p></li>
<li><p>an anonymous rewrite lemma <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code>, where <code class="docutils literal notranslate"><span class="pre">term</span></code> has a type as above.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">double</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>double is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">double</span><span> (</span><span class="coqdoc-var">double</span><span> </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></dt><dd><span>ddouble is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">x</span><span> = 4 * </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  ============================
  ddouble x</span><span> =</span><span> 4</span><span> *</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">_</span><span>]/</span><span class="coqdoc-var">double</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : nat
  ============================
  double x</span><span> +</span><span> double x</span><span> =</span><span> 4</span><span> *</span><span> x
</span></dd>
</dl>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <span class="smallcaps">SSReflect</span> terms containing holes are <em>not</em> typed as
abstractions in this context. Hence the following script fails.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>f is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> f y x
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> -[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span>]/(</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>Toplevel input, characters 0-22:
&gt; rewrite -[f y]/(y + _).
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> fold pattern (y</span><span> +</span><span> _) does not match redex (f y)
</span></dd>
</dl>
</div>
<p>but the following script succeeds</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> -[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span>]/(</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x
</span></dd>
</dl>
</div>
</div>
</li>
</ul>
<dl class="coq flag">
<dt id="coq:flag.SsrOldRewriteGoalsOrder">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>SsrOldRewriteGoalsOrder</span></span></span></code><a class="headerlink" href="#coq:flag.SsrOldRewriteGoalsOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the order in which generated subgoals (side conditions)
are added to the
proof context.  The <a class="reference internal" href="../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> is off by default, which puts subgoals generated
by conditional rules first, followed by the main goal.  When it is on,
the main goal appears first.  If your proofs are organized to complete
proving the main goal before side conditions, turning the flag on will save you
from having to add <a class="reference internal" href="#coq:tacv.last-first" title="last first"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">last</span> <span class="pre">first</span></code></a> tactics that would be needed
to keep the main goal as the currently focused goal.</p>
</dd></dl>

</div>
<div class="section" id="remarks-and-examples">
<h3>Remarks and examples<a class="headerlink" href="#remarks-and-examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="rewrite-redex-selection">
<h4>Rewrite redex selection<a class="headerlink" href="#rewrite-redex-selection" title="Permalink to this headline">¶</a></h4>
<p>The general strategy of <span class="smallcaps">SSReflect</span> is to grasp as many redexes as
possible and to let the user select the ones to be rewritten thanks to
the improved syntax for the control of rewriting.</p>
<p>This may be a source of incompatibilities between the two rewrite
tactics.</p>
<p>In a rewrite tactic of the form:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">occ_switch</span><span> [</span><span class="coqdoc-var">term1</span><span>]</span><span class="coqdoc-var">term2</span><span>.</span><span>
</span></span></div>
<p><code class="docutils literal notranslate"><span class="pre">term1</span></code> is the explicit rewrite redex and <code class="docutils literal notranslate"><span class="pre">term2</span></code> is the rewrite rule.
This execution of this tactic unfolds as follows.</p>
<ul class="simple">
<li><p>First <code class="docutils literal notranslate"><span class="pre">term1</span></code> and <code class="docutils literal notranslate"><span class="pre">term2</span></code> are βι normalized. Then <code class="docutils literal notranslate"><span class="pre">term2</span></code>
is put in head
normal form if the Leibniz equality constructor <code class="docutils literal notranslate"><span class="pre">eq</span></code> is not the head
symbol. This may involve ζ reductions.</p></li>
<li><p>Then, the matching algorithm (see Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)
determines the
first subterm of the goal matching the rewrite pattern. The rewrite
pattern is given by <code class="docutils literal notranslate"><span class="pre">term1</span></code>, if an explicit redex pattern switch is
provided, or by the type of <code class="docutils literal notranslate"><span class="pre">term2</span></code> otherwise. However, matching skips
over matches that would lead to trivial rewrites. All the occurrences
of this subterm in the goal are candidates for rewriting.</p></li>
<li><p>Then only the occurrences coded by <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (see again Section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>) are finally selected for rewriting.</p></li>
<li><p>The left-hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code> is unified with the subterm found by
the matching algorithm, and if this succeeds, all the selected
occurrences in the goal are replaced by the right-hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code>.</p></li>
<li><p>Finally the goal is βι normalized.</p></li>
</ul>
<p>In the case <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a list of terms, the first top-down (in the
goal) left-to-right (in the list) matching rule gets selected.</p>
</div>
<div class="section" id="chained-rewrite-steps">
<h4>Chained rewrite steps<a class="headerlink" href="#chained-rewrite-steps" title="Permalink to this headline">¶</a></h4>
<p>The possibility to chain rewrite operations in a single tactic makes
scripts more compact and gathers in a single command line a bunch of
surgical operations that would be described by a one sentence in a
pen and paper proof.</p>
<p>Performing rewrite and simplification operations in a single tactic
enhances significantly the concision of scripts. For instance the
tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">rewrite</span><span> /</span><span class="coqdoc-var">my_def</span><span> {2}[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>]/= </span><span class="coqdoc-var">my_eq</span><span> //=.</span><span>
</span></span></div>
<p>unfolds <code class="docutils literal notranslate"><span class="pre">my_def</span></code> in the goal, simplifies the second occurrence of the
first subterm matching pattern <code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">_]</span></code>, rewrites <code class="docutils literal notranslate"><span class="pre">my_eq</span></code>, simplifies the
goals and closes trivial goals.</p>
<p>Here are some concrete examples of chained rewrite operations, in the
proof of basic results on natural numbers arithmetic.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addn0</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">m</span><span> + 0 = </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>addn0 is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addnS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></dt><dd><span>addnS is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addSnnS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>addSnnS is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addnCA</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">m</span><span> + (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">p</span><span>) = </span><span class="coqdoc-var">n</span><span> + (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">p</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  m, n, p : nat
  ============================
  m</span><span> +</span><span> (n</span><span> +</span><span> p)</span><span> =</span><span> n</span><span> +</span><span> (m</span><span> +</span><span> p)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; [ | </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">Hrec</span><span>] </span><span class="coqdoc-var">p</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> ?</span><span class="coqdoc-var">addSnnS</span><span> -?</span><span class="coqdoc-var">addnS</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addnC</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  ============================
  m</span><span> +</span><span> n</span><span> =</span><span> n</span><span> +</span><span> m
</span></dd>
<dt><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> -{1}[</span><span class="coqdoc-var">n</span><span>]</span><span class="coqdoc-var">addn0</span><span> </span><span class="coqdoc-var">addnCA</span><span> </span><span class="coqdoc-var">addn0</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">?</span></code> switch for parallel rewrite operations in the
proof of <code class="docutils literal notranslate"><span class="pre">addnCA</span></code>.</p>
</div>
<div class="section" id="explicit-redex-switches-are-matched-first">
<h4>Explicit redex switches are matched first<a class="headerlink" href="#explicit-redex-switches-are-matched-first" title="Permalink to this headline">¶</a></h4>
<p>If an <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> involves a <em>redex switch</em>, the first step is to find a
subterm matching this redex pattern, independently from the left-hand
side of the equality the user wants to rewrite.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">u</span><span>, </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">u</span><span> = </span><span class="coqdoc-var">u</span><span> + </span><span class="coqdoc-var">t</span><span>) </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> t u : nat, t</span><span> +</span><span> u</span><span> =</span><span> u</span><span> +</span><span> t
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> y</span><span> +</span><span> x
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> t u : nat, t</span><span> +</span><span> u</span><span> =</span><span> u</span><span> +</span><span> t
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> =</span><span> x</span><span> +</span><span> y
</span></dd>
</dl>
</div>
</div>
<p>Note that if this first pattern matching is not compatible with the
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, the rewrite fails, even if the goal contains a
correct redex matching both the redex switch and the left-hand side of
the equality.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">u</span><span>, </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">u</span><span> * 0 = </span><span class="coqdoc-var">t</span><span>) </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> * 4 + 2 * 0 = </span><span class="coqdoc-var">x</span><span> + 2 * 0.</span><span>
</span></dt><dd><span>1 goal
  
  H : </span><span class="ansi-bold">forall</span><span> t u : nat, t</span><span> +</span><span> u</span><span> *</span><span> 0</span><span> =</span><span> t
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> *</span><span> 4</span><span> +</span><span> 2</span><span> *</span><span> 0</span><span> =</span><span> x</span><span> +</span><span> 2</span><span> *</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
pattern (x</span><span> +</span><span> y</span><span> *</span><span> 4) does not match LHS of H
</span></dd>
</dl>
</div>
<p>Indeed, the left-hand side of <code class="docutils literal notranslate"><span class="pre">H</span></code> does not match
the redex identified by the pattern <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">4</span></code>.</p>
</div>
</div>
<div class="section" id="occurrence-switches-and-redex-switches">
<span id="ssr-rewrite-occ-switch"></span><h4>Occurrence switches and redex switches<a class="headerlink" href="#occurrence-switches-and-redex-switches" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 0 = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span> + 0 + 0 + (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 0).</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> +</span><span> 0</span><span> =</span><span> x</span><span> +</span><span> y</span><span> +</span><span> y</span><span> +</span><span> 0</span><span> +</span><span> 0</span><span> +</span><span> (x</span><span> +</span><span> y</span><span> +</span><span> 0)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> {2}[</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">y</span><span> + 0](</span><span class="coqdoc-var">_</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span>, </span><span class="coqdoc-var">z</span><span> + 0 = </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  x, y : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> z : nat, z</span><span> +</span><span> 0</span><span> =</span><span> z

goal 2 is:
 x</span><span> +</span><span> y</span><span> +</span><span> 0</span><span> =</span><span> x</span><span> +</span><span> y</span><span> +</span><span> y</span><span> +</span><span> 0</span><span> +</span><span> 0</span><span> +</span><span> (x</span><span> +</span><span> y)
</span></dd>
</dl>
</div>
</div>
<p>The second subgoal is generated by the use of an anonymous lemma in
the rewrite tactic. The effect of the tactic on the initial goal is to
rewrite this lemma at the second occurrence of the first matching
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code> of the explicit rewrite redex <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
</div>
<div class="section" id="occurrence-selection-and-repetition">
<h4>Occurrence selection and repetition<a class="headerlink" href="#occurrence-selection-and-repetition" title="Permalink to this headline">¶</a></h4>
<p>Occurrence selection has priority over repetition switches. This means
the repetition of a rewrite tactic specified by a multiplier will
perform matching each time an elementary rewrite operation is
performed. Repeated rewrite tactics apply to every subgoal generated
by the previous tactic, including the previous instances of the
repetition.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">x</span><span> + 1 = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 1.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> 1</span><span> =</span><span> x</span><span> +</span><span> y</span><span> +</span><span> 1
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> 2!(</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">_</span><span> + 1 = </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd><span>4 goals
  
  x, y, z : nat
  ============================
  x</span><span> +</span><span> 1</span><span> =</span><span> z

goal 2 is:
 z</span><span> =</span><span> z
goal 3 is:
 x</span><span> +</span><span> y</span><span> +</span><span> 1</span><span> =</span><span> z
goal 4 is:
 z</span><span> =</span><span> z
</span></dd>
</dl>
</div>
</div>
<p>This last tactic generates <em>three</em> subgoals because
the second rewrite operation specified with the <code class="docutils literal notranslate"><span class="pre">2!</span></code> multiplier
applies to the two subgoals generated by the first rewrite.</p>
</div>
<div class="section" id="multi-rule-rewriting">
<h4>Multi-rule rewriting<a class="headerlink" href="#multi-rule-rewriting" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic can be provided a <em>tuple</em> of rewrite rules, or more
generally a tree of such rules, since this tuple can feature arbitrary
inner parentheses. We call <em>multirule</em> such a generalized rewrite
rule. This feature is of special interest when it is combined with
multiplier switches, which makes the rewrite tactic iterate the
rewrite operations prescribed by the rules on the current goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span> : </span><span class="coqdoc-var">nat</span><span>).</span><span>
</span></dt><dd><span>a is declared
b is declared
c is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqab</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>eqab is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqac</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">c</span><span>.</span><span>
</span></dt><dd><span>eqac is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  ============================
  a</span><span> =</span><span> a
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqac</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  ============================
  b</span><span> =</span><span> b
</span></dd>
</dl>
</div>
<p>Indeed, rule <code class="docutils literal notranslate"><span class="pre">eqab</span></code> is the first to apply among the ones
gathered in the tuple passed to the rewrite tactic. This multirule
<code class="docutils literal notranslate"><span class="pre">(eqab,</span> <span class="pre">eqac)</span></code> is actually a Coq term and we can name it with a
definition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi1</span><span> := (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqac</span><span>).</span><span>
</span></dt><dd><span>multi1 is defined
</span></dd>
</dl>
</div>
<p>In this case, the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1</span></code> is a synonym for
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(eqab,</span> <span class="pre">eqac)</span></code>.</p>
</div>
<p>More precisely, a multirule rewrites the first subterm to which one of
the rules applies in a left-to-right traversal of the goal, with the
first rule from the multirule tree in left-to-right order. Matching is
performed according to the algorithm described in
Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, but
literal matches have priority.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">d</span><span> := </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>d is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypotheses</span><span> </span><span class="coqdoc-var">eqd0</span><span> : </span><span class="coqdoc-var">d</span><span> = 0.</span><span>
</span></dt><dd><span>eqd0 is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi2</span><span> := (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqd0</span><span>).</span><span>
</span></dt><dd><span>multi2 is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">d</span><span> = </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  eqd0 : d</span><span> =</span><span> 0
  ============================
  d</span><span> =</span><span> b
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">multi2</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  eqd0 : d</span><span> =</span><span> 0
  ============================
  0</span><span> =</span><span> b
</span></dd>
</dl>
</div>
<p>Indeed, rule <code class="docutils literal notranslate"><span class="pre">eqd0</span></code> applies without unfolding the
definition of <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</div>
<p>For repeated rewrites, the selection process is
repeated anew.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eq_adda_b</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>eq_adda_b is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eq_adda_c</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">c</span><span>.</span><span>
</span></dt><dd><span>eq_adda_c is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqb0</span><span> : </span><span class="coqdoc-var">b</span><span> = 0.</span><span>
</span></dt><dd><span>eqb0 is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi3</span><span> := (</span><span class="coqdoc-var">eq_adda_b</span><span>, </span><span class="coqdoc-var">eq_adda_c</span><span>, </span><span class="coqdoc-var">eqb0</span><span>).</span><span>
</span></dt><dd><span>multi3 is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : 1 + </span><span class="coqdoc-var">a</span><span> = 12 + </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  eqd0 : d</span><span> =</span><span> 0
  eq_adda_b : </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> +</span><span> a</span><span> =</span><span> b
  eq_adda_c : </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> +</span><span> a</span><span> =</span><span> c
  eqb0 : b</span><span> =</span><span> 0
  ============================
  1</span><span> +</span><span> a</span><span> =</span><span> 12</span><span> +</span><span> a
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> 2!</span><span class="coqdoc-var">multi3</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b, c : nat
  eqab : a</span><span> =</span><span> b
  eqac : a</span><span> =</span><span> c
  eqd0 : d</span><span> =</span><span> 0
  eq_adda_b : </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> +</span><span> a</span><span> =</span><span> b
  eq_adda_c : </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> +</span><span> a</span><span> =</span><span> c
  eqb0 : b</span><span> =</span><span> 0
  ============================
  0</span><span> =</span><span> 12</span><span> +</span><span> a
</span></dd>
</dl>
</div>
<p>It uses <code class="docutils literal notranslate"><span class="pre">eq_adda_b</span></code> then <code class="docutils literal notranslate"><span class="pre">eqb0</span></code> on the left-hand
side only. Without the bound <code class="docutils literal notranslate"><span class="pre">2</span></code>, one would obtain <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
<p>The grouping of rules inside a multirule does not affect the selection
strategy, but can make it easier to include one rule set in another or
to (universally) quantify over the parameters of a subset of rules (as
there is special code that will omit unnecessary quantifiers for rules
that can be syntactically extracted). It is also possible to reverse
the direction of a rule subset, using a special dedicated syntax: the
tactic rewrite <code class="docutils literal notranslate"><span class="pre">(=~</span> <span class="pre">multi1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1_rev</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqba</span><span> : </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>eqba is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqca</span><span> : </span><span class="coqdoc-var">c</span><span> = </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>eqca is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi1_rev</span><span> := (</span><span class="coqdoc-var">eqba</span><span>, </span><span class="coqdoc-var">eqca</span><span>).</span><span>
</span></dt><dd><span>multi1_rev is defined
</span></dd>
</dl>
</div>
</div>
<p>except that the constants <code class="docutils literal notranslate"><span class="pre">eqba</span></code>, <code class="docutils literal notranslate"><span class="pre">eqab</span></code> and <code class="docutils literal notranslate"><span class="pre">mult1_rev</span></code>
have not been created.</p>
<p>Rewriting with multirules is useful to implement simplification or
transformation procedures, to be applied on terms of small to medium
size. For instance, the library <code class="docutils literal notranslate"><span class="pre">ssrnat</span></code> (Mathematical Components library)
provides two implementations
for arithmetic operations on natural numbers: an elementary one and a
tail recursive version, less inefficient but also less convenient for
reasoning purposes. The library also provides one lemma per such
operation, stating that both versions return the same values when
applied to the same arguments:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addE</span><span> : </span><span class="coqdoc-var">add</span><span> =2 </span><span class="coqdoc-var">addn</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">doubleE</span><span> : </span><span class="coqdoc-var">double</span><span> =1 </span><span class="coqdoc-var">doublen</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">add_mulE</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">add_mul</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">s</span><span> = </span><span class="coqdoc-var">addn</span><span> (</span><span class="coqdoc-var">muln</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">s</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">mulE</span><span> : </span><span class="coqdoc-var">mul</span><span> =2 </span><span class="coqdoc-var">muln</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">mul_expE</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">mul_exp</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">muln</span><span> (</span><span class="coqdoc-var">expn</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">p</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">expE</span><span> : </span><span class="coqdoc-var">exp</span><span> =2 </span><span class="coqdoc-var">expn</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">oddE</span><span> : </span><span class="coqdoc-var">odd</span><span> =1 </span><span class="coqdoc-var">oddn</span><span>.</span><span>
</span></span></div>
<p>The operation on the left-hand side of each lemma is the efficient
version, and the corresponding naive implementation is on the right-hand side.
In order to reason conveniently on expressions involving
the efficient operations, we gather all these rules in the definition
<code class="docutils literal notranslate"><span class="pre">trecE</span></code>:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">trecE</span><span> := (</span><span class="coqdoc-var">addE</span><span>, (</span><span class="coqdoc-var">doubleE</span><span>, </span><span class="coqdoc-var">oddE</span><span>), (</span><span class="coqdoc-var">mulE</span><span>, </span><span class="coqdoc-var">add_mulE</span><span>, (</span><span class="coqdoc-var">expE</span><span>, </span><span class="coqdoc-var">mul_expE</span><span>))).</span><span>
</span></span></div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">!trecE.</span></code>
restores the naive version of each operation in a goal involving the
efficient ones, e.g., for the purpose of a correctness proof.</p>
</div>
<div class="section" id="wildcards-vs-abstractions">
<h4>Wildcards vs abstractions<a class="headerlink" href="#wildcards-vs-abstractions" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic supports <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>s containing holes. For example, in
the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>,
the term <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat,</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0.</span></code>
Anyway this tactic is <em>not</em> equivalent to
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">y</span><span> * 0 + </span><span class="coqdoc-var">y</span><span> * (</span><span class="coqdoc-var">z</span><span> * 0) = 0.</span><span>
</span></dt><dd><span>1 goal
  
  y, z : nat
  ============================
  y</span><span> *</span><span> 0</span><span> +</span><span> y</span><span> *</span><span> (z</span><span> *</span><span> 0)</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">_</span><span> * 0 = 0).</span><span>
</span></dt><dd><span>2 goals
  
  y, z : nat
  ============================
  y</span><span> *</span><span> 0</span><span> =</span><span> 0

goal 2 is:
 0</span><span> +</span><span> y</span><span> *</span><span> (z</span><span> *</span><span> 0)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>while the other tactic results in</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> * 0 = 0).</span><span>
</span></dt><dd><span>2 goals
  
  y, z : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> x : nat, x</span><span> *</span><span> 0</span><span> =</span><span> 0

goal 2 is:
 0</span><span> +</span><span> y</span><span> *</span><span> (z</span><span> *</span><span> 0)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>The first tactic requires you to prove the instance of the (missing)
lemma that was used, while the latter requires you prove the quantified
form.</p>
</div>
</div>
<div class="section" id="when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">
<h4>When <span class="smallcaps">SSReflect</span> rewrite fails on standard Coq licit rewrite<a class="headerlink" href="#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite" title="Permalink to this headline">¶</a></h4>
<p>In a few cases, the <span class="smallcaps">SSReflect</span> rewrite tactic fails rewriting some
redexes that standard Coq successfully rewrites. There are two main
cases.</p>
<ul>
<li><p><span class="smallcaps">SSReflect</span> never accepts to rewrite indeterminate patterns like:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">foo</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">unit</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">tt</span><span>.</span><span>
</span></span></div>
<p><span class="smallcaps">SSReflect</span> will however accept the
ηζ expansion of this rule:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">fubar</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">unit</span><span>) : (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">u</span><span>) = </span><span class="coqdoc-var">tt</span><span>.</span><span>
</span></span></div>
</li>
<li><p>The standard rewrite tactic provided by Coq uses a different algorithm
to find instances of the rewrite rule.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd><span>g is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-var">g</span><span>.</span><span>
</span></dt><dd><span>f is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span> = 0.</span><span>
</span></dt><dd><span>H is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 3 + </span><span class="coqdoc-var">f</span><span> 3 = </span><span class="coqdoc-var">f</span><span> 6.</span><span>
</span></dt><dd><span>1 goal
  
  g : nat</span><span> -&gt;</span><span> nat
  ============================
  f 3</span><span> +</span><span> f 3</span><span> =</span><span> f 6
</span></dd>
<dt><span></span><span class="coqdoc-comment">(* we call the standard rewrite tactic here *)</span></dt><dt><span></span><span class="coqdoc-tactic">rewrite</span><span> -&gt; </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  g : nat</span><span> -&gt;</span><span> nat
  ============================
  0</span><span> +</span><span> 0</span><span> =</span><span> f 6
</span></dd>
</dl>
</div>
<p>This rewriting is not possible in <span class="smallcaps">SSReflect</span>, because
there is no occurrence of the head symbol <code class="docutils literal notranslate"><span class="pre">f</span></code> of the rewrite rule in the
goal.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>Toplevel input, characters 0-9:
&gt; rewrite H.
&gt; ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> The LHS of H
    (g _)
does not match any subterm of the goal
</span></dd>
</dl>
</div>
<p>Rewriting with <code class="docutils literal notranslate"><span class="pre">H</span></code> first requires unfolding the occurrences of
<code class="docutils literal notranslate"><span class="pre">f</span></code>
where the substitution is to be performed (here there is a single such
occurrence), using tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/f</span></code> (for a global replacement of
<code class="docutils literal notranslate"><span class="pre">f</span></code> by <code class="docutils literal notranslate"><span class="pre">g</span></code>) or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">pattern/f</span></code>, for a finer selection.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> /</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  g : nat</span><span> -&gt;</span><span> nat
  ============================
  0</span><span> +</span><span> 0</span><span> =</span><span> g 6
</span></dd>
</dl>
</div>
<p>Alternatively, one can override the pattern inferred from <code class="docutils literal notranslate"><span class="pre">H</span></code></p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  g : nat</span><span> -&gt;</span><span> nat
  ============================
  0</span><span> +</span><span> 0</span><span> =</span><span> f 6
</span></dd>
</dl>
</div>
</div>
</li>
</ul>
</div>
<div class="section" id="existential-metavariables-and-rewriting">
<h4>Existential metavariables and rewriting<a class="headerlink" href="#existential-metavariables-and-rewriting" title="Permalink to this headline">¶</a></h4>
<p>The rewrite tactic will not instantiate existing existential
metavariables when matching a redex pattern.</p>
<p>If a rewrite rule generates a goal with new existential metavariables
in the <code class="docutils literal notranslate"><span class="pre">Prop</span></code> sort, these will be generalized as for <code class="docutils literal notranslate"><span class="pre">apply</span></code>
(see <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>) and
corresponding new goals will be generated.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Warnings</span><span> &quot;-notation-overridden&quot;.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">leq</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd><span>leq is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;m &lt;= n&quot; := (</span><span class="coqdoc-var">leq</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">nat_scope</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;m &lt; n&quot;  := (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">nat_scope</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>Ord is defined
Ord_rect is defined
Ord_ind is defined
Ord_rec is defined
Ord_sind is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;'I_ n&quot; := (</span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 8, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-var">format</span><span> &quot;''I_' n&quot;).</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Arguments</span><span> </span><span class="coqdoc-var">Sub</span><span> {</span><span class="coqdoc-var">_</span><span>} </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">val</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span>) := </span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">_</span><span> := </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>val is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">insub</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> &#64;</span><span class="coqdoc-var">idP</span><span> (</span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">ReflectT</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">Px</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">None</span><span>.</span><span>
</span></dt><dd><span>insub is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">insubT</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>, </span><span class="coqdoc-var">insub</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>).</span><span>
</span></dt><dd><span>insubT is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : '</span><span class="coqdoc-var">I_2</span><span>) </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Some</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">insub</span><span> 2 </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : </span><span>'I_</span><span>2
  y : nat
  ============================
  Some x</span><span> =</span><span> insub 2 y
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">insubT</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x : </span><span>'I_</span><span>2
  y : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> Hyp0 : y</span><span> &lt;</span><span> 2, Some x</span><span> =</span><span> Some (Sub y Hyp0)

goal 2 is:
 y</span><span> &lt;</span><span> 2
</span></dd>
</dl>
</div>
<p>Since the argument corresponding to <code class="docutils literal notranslate"><span class="pre">Px</span></code> is not supplied by the user, the
resulting goal should be <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Sub</span> <span class="pre">y</span> <span class="pre">?Goal).</span></code>
Instead, <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic hides the existential variable.</p>
<p>As in <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>, the <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code> tactic is used to try to
solve the existential variable.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : '</span><span class="coqdoc-var">I_2</span><span>) </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">y</span><span> &lt; 2) : </span><span class="coqdoc-var">Some</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">insub</span><span> 2 </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : </span><span>'I_</span><span>2
  y : nat
  H : y</span><span> &lt;</span><span> 2
  ============================
  Some x</span><span> =</span><span> insub 2 y
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">insubT</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x : </span><span>'I_</span><span>2
  y : nat
  H : y</span><span> &lt;</span><span> 2
  ============================
  Some x</span><span> =</span><span> Some (Sub y H)
</span></dd>
</dl>
</div>
</div>
<p>As a temporary limitation, this behavior is available only if the
rewriting rule is stated using Leibniz equality (as opposed to setoid
relations). It will be extended to other rewriting relations in the
future.</p>
</div>
</div>
<div class="section" id="rewriting-under-binders">
<span id="under-ssr"></span><h3>Rewriting under binders<a class="headerlink" href="#rewriting-under-binders" title="Permalink to this headline">¶</a></h3>
<p>Goals involving objects defined with higher-order functions often
require &quot;rewriting under binders&quot;. While setoid rewriting is a
possible approach in this case, it is common to use regular rewriting
along with dedicated extensionality lemmas. This may cause some
practical issues during the development of the corresponding scripts,
notably as we might be forced to provide the rewrite tactic with
complete terms, as shown by the simple example below.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">subnn</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> - </span><span class="coqdoc-var">n</span><span> = 0.</span><span>
</span></dt><dd class="coqtop-hidden"><span>subnn is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">map</span><span> : (</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>) -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>map is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">sumlist</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>sumlist is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">eq_map</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">F2</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>,</span><span>
  (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">n</span><span>) -&gt;</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">map</span><span> </span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">map</span><span> </span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">l</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>eq_map is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">example_map</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">sumlist</span><span> (</span><span class="coqdoc-var">map</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">l</span><span>) = 0.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> m : nat =&gt; m</span><span> -</span><span> m) l)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>In this context, one cannot directly use <code class="docutils literal notranslate"><span class="pre">eq_map</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">eq_map</span><span>.</span><span>
</span></dt><dd><span>Toplevel input, characters 0-14:
&gt; rewrite eq_map.
&gt; ^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold">Error:</span><span> Unable to find an instance for the variable F2.
Rule's type:
(</span><span class="ansi-bold">forall</span><span> F1 F2 : nat</span><span> -&gt;</span><span> nat,
 (</span><span class="ansi-bold">forall</span><span> n : nat, F1 n</span><span> =</span><span> F2 n)</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> l : list nat, map F1 l</span><span> =</span><span> map F2 l)
</span></dd>
</dl>
</div>
<p>as we need to explicitly provide the non-inferable argument <code class="docutils literal notranslate"><span class="pre">F2</span></code>,
which corresponds here to the term we want to obtain <em>after</em> the
rewriting step. In order to perform the rewrite step, one has to
provide the term by hand as follows:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> (&#64;</span><span class="coqdoc-var">eq_map</span><span> </span><span class="coqdoc-var">_</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">nat</span><span> =&gt; 0)).</span><span>
</span></dt><dd><span>2 goals
  
  l : list nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> -</span><span> n</span><span> =</span><span> 0

goal 2 is:
 sumlist (map (</span><span class="ansi-bold">fun</span><span> _ : nat =&gt; 0) l)</span><span> =</span><span> 0
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">m</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">subnn</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> _ : nat =&gt; 0) l)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>The <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic lets one perform the same operation in a more
convenient way:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">example_map</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">sumlist</span><span> (</span><span class="coqdoc-var">map</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">l</span><span>) = 0.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> m : nat =&gt; m</span><span> -</span><span> m) l)</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-var">under</span><span> </span><span class="coqdoc-var">eq_map</span><span> =&gt; </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-tactic">do</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">subnn</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> _ : nat =&gt; 0) l)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
</div>
<div class="section" id="the-under-tactic">
<h4>The under tactic<a class="headerlink" href="#the-under-tactic" title="Permalink to this headline">¶</a></h4>
<p>The convenience <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic supports the following syntax:</p>
<dl class="coq tacn">
<dt id="coq:tacn.under">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>under</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>=&gt;</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>do</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.under" title="Permalink to this definition">¶</a></dt>
<dd><p>It operates under the context proved to be extensional by
lemma <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<dl class="coq exn">
<dt id="coq:exn.Incorrect-number-of-tactics-(expected-N-tactics,-was-given-M)">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span><span>Incorrect</span></span> <span><span>number</span></span> <span><span>of</span></span> <span><span>tactics</span></span> <span><span>(expected</span></span> <span><span>N</span></span> <span><span>tactics,</span></span> <span><span>was</span></span> <span><span>given</span></span> <span><span>M).</span></span></span></code><a class="headerlink" href="#coq:exn.Incorrect-number-of-tactics-(expected-N-tactics,-was-given-M)" title="Permalink to this definition">¶</a></dt>
<dd><p>This error can occur when using the version with a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause.</p>
</dd></dl>

<p>The multiplier part of <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> is not supported.</p>
</dd></dl>

<p>We distinguish two modes:
<a class="reference internal" href="#under-interactive"><span class="std std-ref">interactive mode</span></a>, without a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause, and
<a class="reference internal" href="#under-one-liner"><span class="std std-ref">one-liner mode</span></a>, with a <code class="docutils literal notranslate"><span class="pre">do</span></code> clause,
which are explained in more detail below.</p>
</div>
<div class="section" id="interactive-mode">
<span id="under-interactive"></span><h4>Interactive mode<a class="headerlink" href="#interactive-mode" title="Permalink to this headline">¶</a></h4>
<p>Let us redo the running example in interactive mode.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">example_map</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">sumlist</span><span> (</span><span class="coqdoc-var">map</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">l</span><span>) = 0.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> m : nat =&gt; m</span><span> -</span><span> m) l)</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-var">under</span><span> </span><span class="coqdoc-var">eq_map</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>2 focused goals (shelved: 1)
  
  l : list nat
  m : nat
  ============================
  </span><span>'Under[</span><span> </span><span>m</span><span> -</span><span> m</span><span> ]</span><span>

goal 2 is:
 sumlist (map </span><span class="ansi-fg-light-blue">?Goal</span><span> l)</span><span> =</span><span> 0
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">subnn</span><span>.</span><span>
</span></dt><dd><span>2 focused goals (shelved: 1)
  
  l : list nat
  m : nat
  ============================
  </span><span>'Under[</span><span> </span><span>0</span><span> ]</span><span>

goal 2 is:
 sumlist (map </span><span class="ansi-fg-light-blue">?Goal</span><span> l)</span><span> =</span><span> 0
</span></dd>
<dt><span>  </span><span class="coqdoc-var">over</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  ============================
  sumlist (map (</span><span class="ansi-bold">fun</span><span> _ : nat =&gt; 0) l)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
</div>
<p>The execution of the Ltac expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">].</span></span></span></span></code></p>
<p>involves the following steps.</p>
<ol class="arabic simple">
<li><p>It performs a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">rewrite</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
without failing like in the first example with <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">eq_map.</span></code>,
but creating evars (see <a class="reference internal" href="tactics.html#coq:tacn.evar" title="evar"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">evar</span></code></a>). If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">term</span></span></span></span></code> is prefixed by
a pattern or an occurrence selector, then the modifiers are honoured.</p></li>
<li><p>As an n-branch intro pattern is provided, <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> checks that
n+1 subgoals have been created. The last one is the main subgoal,
while the other ones correspond to premises of the rewrite rule (such as
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n,</span> <span class="pre">F1</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">F2</span> <span class="pre">n</span></code> for <code class="docutils literal notranslate"><span class="pre">eq_map</span></code>).</p></li>
<li><p>If so, <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> puts these n goals in head normal form (using
the defective form of the tactic <a class="reference internal" href="#coq:tacn.move-(ssreflect)" title="move (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span></code></a>), then executes
the corresponding intro pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole"><span class="pre">i_pattern</span><sub><span class="pre">i</span></sub></span></a></span></code> in each goal.</p></li>
<li><p>Then, <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> checks that the first n subgoals
are (quantified) Leibniz equalities, double implications or
registered relations (w.r.t. Class <code class="docutils literal notranslate"><span class="pre">RewriteRelation</span></code>) between a
term and an evar, e.g., <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">?F2</span> <span class="pre">m</span></code> in the running example.
(This support for setoid-like relations is enabled as soon as one does
both <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ssreflect.</span></code> and <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Setoid.</span></code>)</p></li>
<li><p>If so <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> protects these n goals against an
accidental instantiation of the evar.
These protected goals are displayed using the <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>
notation (e.g. <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">m</span> <span class="pre">]</span></code> in the running example).</p></li>
<li><p>The expression inside the <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code> notation can be
proved equivalent to the desired expression
by using a regular <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic.</p></li>
<li><p>Interactive editing of the first n goals has to be signalled by
using the <a class="reference internal" href="#coq:tacn.over" title="over"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">over</span></code></a> tactic or rewrite rule (see below), which
requires that the underlying relation is reflexive. (The running
example deals with Leibniz equality, but <code class="docutils literal notranslate"><span class="pre">PreOrder</span></code> relations are
also supported, for example.)</p></li>
<li><p>Finally, a post-processing step is performed in the main goal
to keep the name(s) for the bound variables chosen by the user in
the intro pattern for the first branch.</p></li>
</ol>
<div class="section" id="the-over-tactic">
<span id="over-ssr"></span><h5>The over tactic<a class="headerlink" href="#the-over-tactic" title="Permalink to this headline">¶</a></h5>
<p>Two equivalent facilities (a terminator and a lemma) are provided to
close intermediate subgoals generated by <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> (i.e., goals
displayed as <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>):</p>
<dl class="coq tacn">
<dt id="coq:tacn.over">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>over</span></span></span></code><a class="headerlink" href="#coq:tacn.over" title="Permalink to this definition">¶</a></dt>
<dd><p>This terminator tactic allows one to close goals of the form
<code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>.</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>by</span></span> <span><span>rewrite</span></span> <span><span>over</span></span></span></code></dt>
<dd><p>This is a variant of <a class="reference internal" href="#coq:tacn.over" title="over"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">over</span></code></a> in order to close <code class="docutils literal notranslate"><span class="pre">'Under[</span> <span class="pre">…</span> <span class="pre">]</span></code>
goals, relying on the <code class="docutils literal notranslate"><span class="pre">over</span></code> rewrite rule.</p>
</dd></dl>

<p>Note that a rewrite rule <code class="docutils literal notranslate"><span class="pre">UnderE</span></code> is available as well, if one wants
to &quot;unprotect&quot; the evar, without closing the goal automatically (e.g.,
to instantiate it manually with another rule than reflexivity).</p>
</div>
</div>
<div class="section" id="one-liner-mode">
<span id="under-one-liner"></span><h4>One-liner mode<a class="headerlink" href="#one-liner-mode" title="Permalink to this headline">¶</a></h4>
<p>The Ltac expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">]</span></span></span> <span><span><span class="pre">do</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">].</span></span></span></span></code></p>
<p>can be seen as a shorter form for the following expression:</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-i_item"><span class="hole"><span class="pre">i_item</span><sub><span class="pre">n</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">];</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">over</span></span></span> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">over</span></span></span> <span class="pre">|</span> <span><span><span class="pre">cbv</span></span></span> <span><span><span class="pre">beta</span></span></span> <span><span><span class="pre">iota</span></span></span> <span><span><span class="pre">].</span></span></span></span></code></p>
<p>Notes:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">beta-iota</span></code> reduction here is useful to get rid of the beta
redexes that could be introduced after the substitution of the evars
by the <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic.</p></li>
<li><p>Note that the provided tactics can as well
involve other <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactics. See below for a typical example
involving the <code class="docutils literal notranslate"><span class="pre">bigop</span></code> theory from the Mathematical Components library.</p></li>
<li><p>If there is only one tactic, the brackets can be omitted, e.g.:
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">i</span></span></span> <span><span><span class="pre">do</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">.</span></span></span></span></code> and that shorter form should be
preferred.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">do</span></code> clause is provided and the intro pattern is omitted,
then the default <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> <code class="docutils literal notranslate"><span class="pre">*</span></code> is applied to each branch.
E.g., the Ltac expression
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">do</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">]</span></span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">under</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">[</span></span></span> <span><span><span class="pre">*</span></span></span> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <span><span><span class="pre">*</span></span></span> <span><span><span class="pre">]</span></span></span> <span><span><span class="pre">do</span></span></span> <span><span><span class="pre">[</span></span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">…</span></span></span> <span class="pre">|</span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">]</span></span></span></span></code>
(and it can be noted here that the <a class="reference internal" href="#coq:tacn.under" title="under"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">under</span></code></a> tactic performs a
<code class="docutils literal notranslate"><span class="pre">move.</span></code> before processing the intro patterns <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">[</span> <span class="pre">*</span> <span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span> <span class="pre">*</span> <span class="pre">]</span></code>).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Coercion</span><span> </span><span class="coqdoc-var">is_true</span><span> : </span><span class="coqdoc-var">bool</span><span> &gt;-&gt; </span><span class="coqdoc-var">Sortclass</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>is_true is now a coercion
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Reserved Notation</span><span> &quot;\big [ op / idx ]_ ( m &lt;= i &lt; n | P ) F&quot;</span><span>
  (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 36, </span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 36, </span><span class="coqdoc-var">op</span><span>, </span><span class="coqdoc-var">idx</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 10, </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">i</span><span>, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 50,</span><span>
           </span><span class="coqdoc-var">format</span><span> &quot;'[' \big [ op / idx ]_ ( m  &lt;=  i  &lt;  n  |  P )  F ']'&quot;).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variant</span><span> </span><span class="coqdoc-var">bigbody</span><span> (</span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
  </span><span class="coqdoc-var">BigBody</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>), </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>), </span><span class="coqdoc-var">bigbody</span><span> </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>bigbody is defined
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">bigop</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">bigbody</span><span> </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">I</span><span>), </span><span class="coqdoc-var">R</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>bigop is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">eq_bigr_</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">idx</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">op</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">R</span><span>), </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>)</span><span>
         (</span><span class="coqdoc-var">r</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">F2</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>),</span><span>
    (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">is_true</span><span> (</span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span>) -&gt; </span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">x</span><span>) -&gt;</span><span>
    </span><span class="coqdoc-var">bigop</span><span> </span><span class="coqdoc-var">idx</span><span> </span><span class="coqdoc-var">r</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span> =&gt; </span><span class="coqdoc-var">BigBody</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">op</span><span> (</span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span>) (</span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">i</span><span>)) =</span><span>
    </span><span class="coqdoc-var">bigop</span><span> </span><span class="coqdoc-var">idx</span><span> </span><span class="coqdoc-var">r</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span> =&gt; </span><span class="coqdoc-var">BigBody</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">op</span><span> (</span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span>) (</span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">i</span><span>)).</span><span>
</span></dt><dd class="coqtop-hidden"><span>eq_bigr_ is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">eq_big_</span><span> :</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">idx</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">op</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">r</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">I</span><span>)</span><span>
         (</span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">P2</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">F2</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>),</span><span>
    (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">P2</span><span> </span><span class="coqdoc-var">x</span><span>) -&gt;</span><span>
    (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">is_true</span><span> (</span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">i</span><span>) -&gt; </span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">i</span><span> = </span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">i</span><span>) -&gt;</span><span>
    </span><span class="coqdoc-var">bigop</span><span> </span><span class="coqdoc-var">idx</span><span> </span><span class="coqdoc-var">r</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span> =&gt; </span><span class="coqdoc-var">BigBody</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">op</span><span> (</span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">i</span><span>) (</span><span class="coqdoc-var">F1</span><span> </span><span class="coqdoc-var">i</span><span>)) =</span><span>
    </span><span class="coqdoc-var">bigop</span><span> </span><span class="coqdoc-var">idx</span><span> </span><span class="coqdoc-var">r</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span> =&gt; </span><span class="coqdoc-var">BigBody</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">op</span><span> (</span><span class="coqdoc-var">P2</span><span> </span><span class="coqdoc-var">i</span><span>) (</span><span class="coqdoc-var">F2</span><span> </span><span class="coqdoc-var">i</span><span>)).</span><span>
</span></dt><dd class="coqtop-hidden"><span>eq_big_ is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Reserved Notation</span><span> &quot;\sum_ ( m &lt;= i &lt; n | P ) F&quot;</span><span>
  (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 41, </span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 41, </span><span class="coqdoc-var">i</span><span>, </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 50,</span><span>
           </span><span class="coqdoc-var">format</span><span> &quot;'[' \sum_ ( m  &lt;=  i  &lt;  n  |  P ) '/  '  F ']'&quot;).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">index_iota</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>index_iota is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Notation</span><span> &quot;\big [ op / idx ]_ ( m &lt;= i &lt; n | P ) F&quot; :=</span><span>
  (</span><span class="coqdoc-var">bigop</span><span> </span><span class="coqdoc-var">idx</span><span> (</span><span class="coqdoc-var">index_iota</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">BigBody</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">op</span><span> </span><span class="coqdoc-var">P</span><span>%</span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">F</span><span>)).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Notation</span><span> &quot;\sum_ ( m &lt;= i &lt; n | P ) F&quot; :=</span><span>
  (\</span><span class="coqdoc-var">big</span><span>[</span><span class="coqdoc-var">plus</span><span>/</span><span class="coqdoc-var">O</span><span>]</span><span class="coqdoc-var">_</span><span>(</span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">i</span><span> &lt; </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">P</span><span>%</span><span class="coqdoc-var">bool</span><span>) </span><span class="coqdoc-var">F</span><span>%</span><span class="coqdoc-var">nat</span><span>).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">eq_bigr</span><span> := (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">eq_bigr_</span><span> 0 </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">index_iota</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>)).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">eq_big</span><span> := (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">eq_big_</span><span> 0 </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">index_iota</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>)).</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">odd</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>odd is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">prime</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>prime is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">addnC</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>addnC is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">muln1</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> * 1 = </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>muln1 is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">eq_bigr</span><span>.</span><span>
</span></dt><dd><span>eq_bigr
     : </span><span class="ansi-bold">forall</span><span> (n m : nat) (P : nat</span><span> -&gt;</span><span> bool) (F1 F2 : nat</span><span> -&gt;</span><span> nat),
       (</span><span class="ansi-bold">forall</span><span> x : nat, P x</span><span> -&gt;</span><span> F1 x</span><span> =</span><span> F2 x)</span><span> -&gt;</span><span>
       </span><span>\sum_</span><span>(</span><span>n</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>P i</span><span>)</span><span> </span><span>F1 i</span><span> =</span><span> </span><span>\sum_</span><span>(</span><span>n</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>P i</span><span>)</span><span> </span><span>F2 i
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">eq_big</span><span>.</span><span>
</span></dt><dd><span>eq_big
     : </span><span class="ansi-bold">forall</span><span> (n m : nat) (P1 P2 : nat</span><span> -&gt;</span><span> bool) (F1 F2 : nat</span><span> -&gt;</span><span> nat),
       (</span><span class="ansi-bold">forall</span><span> x : nat, P1 x</span><span> =</span><span> P2 x)</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> i : nat, P1 i</span><span> -&gt;</span><span> F1 i</span><span> =</span><span> F2 i)</span><span> -&gt;</span><span>
       </span><span>\sum_</span><span>(</span><span>n</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>P1 i</span><span>)</span><span> </span><span>F1 i</span><span> =</span><span> </span><span>\sum_</span><span>(</span><span>n</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>P2 i</span><span>)</span><span> </span><span>F2 i
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test_big_nested</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) :</span><span>
  \</span><span class="coqdoc-var">sum_</span><span>(0 &lt;= </span><span class="coqdoc-var">a</span><span> &lt; </span><span class="coqdoc-var">m</span><span> | </span><span class="coqdoc-var">prime</span><span> </span><span class="coqdoc-var">a</span><span>) \</span><span class="coqdoc-var">sum_</span><span>(0 &lt;= </span><span class="coqdoc-var">j</span><span> &lt; </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">odd</span><span> (</span><span class="coqdoc-var">j</span><span> * 1)) (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">j</span><span>) =</span><span>
  \</span><span class="coqdoc-var">sum_</span><span>(0 &lt;= </span><span class="coqdoc-var">i</span><span> &lt; </span><span class="coqdoc-var">m</span><span> | </span><span class="coqdoc-var">prime</span><span> </span><span class="coqdoc-var">i</span><span>) \</span><span class="coqdoc-var">sum_</span><span>(0 &lt;= </span><span class="coqdoc-var">j</span><span> &lt; </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-var">j</span><span>) (</span><span class="coqdoc-var">j</span><span> + </span><span class="coqdoc-var">i</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  ============================
  </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>a</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>prime a</span><span>)</span><span> </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>n</span><span> </span><span>|</span><span> </span><span>odd (j</span><span> *</span><span> 1)</span><span>)</span><span> </span><span>(a</span><span> +</span><span> j)</span><span> =</span><span>
  </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>prime i</span><span>)</span><span> </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>n</span><span> </span><span>|</span><span> </span><span>odd j</span><span>)</span><span> </span><span>(j</span><span> +</span><span> i)
</span></dd>
<dt><span></span><span class="coqdoc-var">under</span><span> </span><span class="coqdoc-var">eq_bigr</span><span> =&gt; </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">prime_i</span><span> </span><span class="coqdoc-tactic">do</span><span>
  </span><span class="coqdoc-var">under</span><span> </span><span class="coqdoc-var">eq_big</span><span> =&gt; [ </span><span class="coqdoc-var">j</span><span> | </span><span class="coqdoc-var">j</span><span> </span><span class="coqdoc-var">odd_j</span><span> ] </span><span class="coqdoc-tactic">do</span><span>
    [ </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">muln1</span><span> </span><span class="coqdoc-var">j</span><span>) | </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">addnC</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">j</span><span>) ].</span><span>
</span></dt><dd><span>1 goal
  
  m, n : nat
  ============================
  </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>prime i</span><span>)</span><span> </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>n</span><span> </span><span>|</span><span> </span><span>odd j</span><span>)</span><span> </span><span>(j</span><span> +</span><span> i)</span><span> =</span><span>
  </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>m</span><span> </span><span>|</span><span> </span><span>prime i</span><span>)</span><span> </span><span>\sum_</span><span>(</span><span>0</span><span> </span><span>&lt;=</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>n</span><span> </span><span>|</span><span> </span><span>odd j</span><span>)</span><span> </span><span>(j</span><span> +</span><span> i)
</span></dd>
</dl>
</div>
<p>Remark how the final goal uses the name <code class="docutils literal notranslate"><span class="pre">i</span></code> (the name given in the
intro pattern) rather than <code class="docutils literal notranslate"><span class="pre">a</span></code> in the binder of the first summation.</p>
</div>
</div>
</div>
<div class="section" id="locking-unlocking">
<span id="locking-ssr"></span><h3>Locking, unlocking<a class="headerlink" href="#locking-unlocking" title="Permalink to this headline">¶</a></h3>
<p>As program proofs tend to generate large goals, it is important to be
able to control the partial evaluation performed by the simplification
operations that are performed by the tactics. These evaluations can,
for example, come from a <code class="docutils literal notranslate"><span class="pre">/=</span></code> simplification switch, or from rewrite
steps, which may expand large terms while performing conversion. We
definitely want to avoid repeating large subterms of the goal in the
proof script. We do this by “clamping down” selected function symbols
in the goal, which prevents them from being considered in
simplification or rewriting steps. This clamping is accomplished by
using the occurrence switches (see Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)
together with “term tagging” operations.</p>
<p><span class="smallcaps">SSReflect</span> provides two levels of tagging.</p>
<p>The first one uses auxiliary definitions to introduce a provably equal
copy of any term <code class="docutils literal notranslate"><span class="pre">t</span></code>. However this copy is (on purpose) <em>not
convertible</em> to <code class="docutils literal notranslate"><span class="pre">t</span></code> in the Coq system <a class="footnote-reference brackets" href="#id49" id="id14">18</a>. The job is done by the
following construction:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">master_key</span><span> : </span><span class="coqdoc-var">unit</span><span>. </span><span class="coqdoc-keyword">Proof</span><span>. </span><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">tt</span><span>. </span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">locked</span><span> </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">tt</span><span> := </span><span class="coqdoc-var">master_key</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>.</span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">lock</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">locked</span><span> </span><span class="coqdoc-var">x</span><span> :&gt; </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></span></div>
<p>Note that the definition of <em>master_key</em> is explicitly opaque. The
equation <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">locked</span> <span class="pre">t</span></code> given by the <code class="docutils literal notranslate"><span class="pre">lock</span></code> lemma can be used for
selective rewriting, blocking on the fly the reduction in the term <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd><span>A is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">has</span><span> (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> || (</span><span class="coqdoc-var">has</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">l</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">false</span><span>.</span><span>
</span></dt><dd><span>has is defined
has is recursively defined (guarded on 2nd argument)
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">l</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">true</span><span>) : </span><span class="coqdoc-var">has</span><span> </span><span class="coqdoc-var">p</span><span> ( </span><span class="coqdoc-var">x</span><span> :: </span><span class="coqdoc-var">y</span><span> :: </span><span class="coqdoc-var">l</span><span>) = </span><span class="coqdoc-var">true</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  p : A</span><span> -&gt;</span><span> bool
  x, y : A
  l : list A
  H : p x</span><span> =</span><span> true
  ============================
  has p (x </span><span>:: </span><span>y </span><span>:: </span><span>l)</span><span> =</span><span> true
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> {2}[</span><span class="coqdoc-var">cons</span><span>]</span><span class="coqdoc-var">lock</span><span> /= -</span><span class="coqdoc-var">lock</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  p : A</span><span> -&gt;</span><span> bool
  x, y : A
  l : list A
  H : p x</span><span> =</span><span> true
  ============================
  p x </span><span>|| </span><span>has p (y </span><span>:: </span><span>l)</span><span> =</span><span> true
</span></dd>
</dl>
</div>
</div>
<p>It is sometimes desirable to globally prevent a definition from being
expanded by simplification; this is done by adding <code class="docutils literal notranslate"><span class="pre">locked</span></code> in the
definition.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">lid</span><span> := </span><span class="coqdoc-var">locked</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></dt><dd><span>lid is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">lid</span><span> 3 = 3.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  lid 3</span><span> =</span><span> 3
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> /=.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  lid 3</span><span> =</span><span> 3
</span></dd>
<dt><span></span><span class="coqdoc-var">unlock</span><span> </span><span class="coqdoc-var">lid</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  3</span><span> =</span><span> 3
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt id="coq:tacn.unlock">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>unlock</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic unfolds such definitions while removing “locks”; i.e., it
replaces the occurrence(s) of <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> coded by the
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> with the corresponding body.</p>
</dd></dl>

<p>We found that it was usually preferable to prevent the expansion of
some functions by the partial evaluation switch <code class="docutils literal notranslate"><span class="pre">/=</span></code>, unless this
allowed the evaluation of a condition. This is possible thanks to another
mechanism of term tagging, resting on the following <em>Notation</em>:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;'nosimpl' t&quot; := (</span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">tt</span><span> := </span><span class="coqdoc-var">tt</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">t</span><span>).</span><span>
</span></span></div>
<p>The term <code class="docutils literal notranslate"><span class="pre">(nosimpl</span> <span class="pre">t)</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">t</span></code> <em>except</em> in a definition.
More precisely, given:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> := (</span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">bar</span><span>).</span><span>
</span></span></div>
<p>the term <code class="docutils literal notranslate"><span class="pre">foo</span></code> (or <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">t’)</span></code>) will <em>not</em> be expanded by the <em>simpl</em>
tactic unless it is in a forcing context (e.g., in <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">foo</span> <span class="pre">t’</span> <span class="pre">with</span> <span class="pre">…</span>
<span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">t’</span></code> will be reduced if this allows <code class="docutils literal notranslate"><span class="pre">match</span></code> to be reduced).
Note that <code class="docutils literal notranslate"><span class="pre">nosimpl</span> <span class="pre">bar</span></code> is simply notation for a term that reduces to
<code class="docutils literal notranslate"><span class="pre">bar</span></code>; hence <code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">foo</span></code> by <code class="docutils literal notranslate"><span class="pre">bar</span></code>, and
<code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">bar</span></code> by <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> trick only works if no reduction is apparent in
<code class="docutils literal notranslate"><span class="pre">t</span></code>; in particular, the declaration:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> (</span><span class="coqdoc-var">bar</span><span> </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></span></div>
<p>will usually not work. Anyway, the common practice is to tag only the
function, and to use the following definition, which blocks the
reduction as expected:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">bar</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></span></div>
</div>
<p>A standard example making this technique shine is the case of
arithmetic operations. We define for instance:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addn</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">plus</span><span>.</span><span>
</span></span></div>
<p>The operation <code class="docutils literal notranslate"><span class="pre">addn</span></code> behaves exactly like <code class="docutils literal notranslate"><span class="pre">plus</span></code>, except that
<code class="docutils literal notranslate"><span class="pre">(addn</span> <span class="pre">(S</span> <span class="pre">n)</span> <span class="pre">m)</span></code> will not simplify spontaneously to
<code class="docutils literal notranslate"><span class="pre">(S</span> <span class="pre">(addn</span> <span class="pre">n</span> <span class="pre">m))</span></code> (the two terms, however, are convertible).
In addition, the unfolding step <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/addn</span></code>
will replace <code class="docutils literal notranslate"><span class="pre">addn</span></code> directly with <code class="docutils literal notranslate"><span class="pre">plus</span></code>, so the <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> form is
essentially invisible.</p>
</div>
<div class="section" id="congruence">
<span id="congruence-ssr"></span><h3>Congruence<a class="headerlink" href="#congruence" title="Permalink to this headline">¶</a></h3>
<p>Because of the way matching interferes with parameters of type families,
the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">my_congr_property</span><span>.</span><span>
</span></span></div>
<p>will generally fail to perform congruence simplification, even on
rather simple cases. We therefore provide a more robust alternative in
which the function is supplied:</p>
<dl class="coq tacn">
<dt id="coq:tacn.congr">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>congr</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.congr" title="Permalink to this definition">¶</a></dt>
<dd><p>This tactic:</p>
<ul class="simple">
<li><p>checks that the goal is a Leibniz equality;</p></li>
<li><p>matches both sides of this equality with “term applied to some arguments”,
inferring the right number of arguments from the goal and the type of <code class="docutils literal notranslate"><span class="pre">term</span></code>
(this may expand some definitions or fixpoints);</p></li>
<li><p>generates the subgoals corresponding to pairwise equalities of the arguments present in the goal.</p></li>
</ul>
<p>The goal can be a non-dependent product <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">Q</span></code>. In that case, the
system asserts the equation <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, uses it to solve the goal, and
calls the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic on the remaining goal <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>. This can be useful
for instance to perform a transitivity step, like in the following
situation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  H : x</span><span> =</span><span> y
  ============================
  x</span><span> =</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-var">congr</span><span> (</span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">_</span><span>) : </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  y</span><span> =</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  x</span><span> =</span><span> y</span><span> -&gt;</span><span> x</span><span> =</span><span> z
</span></dd>
<dt><span></span><span class="coqdoc-var">congr</span><span> (</span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">_</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  y</span><span> =</span><span> z
</span></dd>
</dl>
</div>
</div>
<p>The optional <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a> forces the number of arguments for which the
tactic should generate equality proof obligations.</p>
<p>This tactic supports equalities between applications with dependent
arguments. Yet dependent arguments should have exactly the same
parameters on both sides, and these parameters should appear as first
arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> 0 </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">mult</span><span>.</span><span>
</span></dt><dd><span>f is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">g</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">nat</span><span>) := </span><span class="coqdoc-var">plus</span><span>.</span><span>
</span></dt><dd><span>g is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">f</span><span> 0 </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">g</span><span> 1 1 </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  f 0 x y</span><span> =</span><span> g 1 1 x y
</span></dd>
<dt><span></span><span class="coqdoc-var">congr</span><span> </span><span class="coqdoc-var">plus</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>This script shows that the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic matches <code class="docutils literal notranslate"><span class="pre">plus</span></code>
with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">0</span></code> on the left hand side and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">1</span> <span class="pre">1</span></code> on the right hand
side, and solves the goal.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">Hnm</span><span> : </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> + (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> - </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>) = </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  Hnm : m</span><span> &lt;=</span><span> n
  ============================
  S m</span><span> +</span><span> (S n</span><span> -</span><span> S m)</span><span> =</span><span> S n
</span></dd>
<dt><span></span><span class="coqdoc-var">congr</span><span> </span><span class="coqdoc-var">S</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> -/</span><span class="coqdoc-var">plus</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  Hnm : m</span><span> &lt;=</span><span> n
  ============================
  m</span><span> +</span><span> (S n</span><span> -</span><span> S m)</span><span> =</span><span> n
</span></dd>
</dl>
</div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/plus</span></code> folds back the expansion of <code class="docutils literal notranslate"><span class="pre">plus</span></code>,
which was necessary for matching both sides of the equality with
an application of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<p>Like most <span class="smallcaps">SSReflect</span> arguments, <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> can contain wildcards.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + (</span><span class="coqdoc-var">y</span><span> * (</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span> - </span><span class="coqdoc-var">x</span><span>)) = </span><span class="coqdoc-var">x</span><span> * 1 + (</span><span class="coqdoc-var">y</span><span> + 0) * </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y : nat
  ============================
  x</span><span> +</span><span> y</span><span> *</span><span> (y</span><span> +</span><span> x</span><span> -</span><span> x)</span><span> =</span><span> x</span><span> *</span><span> 1</span><span> +</span><span> (y</span><span> +</span><span> 0)</span><span> *</span><span> y
</span></dd>
<dt><span></span><span class="coqdoc-var">congr</span><span> ( </span><span class="coqdoc-var">_</span><span> + (</span><span class="coqdoc-var">_</span><span> * </span><span class="coqdoc-var">_</span><span>)).</span><span>
</span></dt><dd><span>3 goals
  
  x, y : nat
  ============================
  x</span><span> =</span><span> x</span><span> *</span><span> 1

goal 2 is:
 y</span><span> =</span><span> y</span><span> +</span><span> 0
goal 3 is:
 y</span><span> +</span><span> x</span><span> -</span><span> x</span><span> =</span><span> y
</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="contextual-patterns">
<span id="contextual-patterns-ssr"></span><h2>Contextual patterns<a class="headerlink" href="#contextual-patterns" title="Permalink to this headline">¶</a></h2>
<p>The simple form of patterns used so far, terms possibly containing
wild cards, often requires an additional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> to be specified.
While this may work pretty fine for small goals, the use of
polymorphic functions and dependent types may lead to an invisible
duplication of function arguments. These copies usually end up in
types hidden by the implicit-arguments machinery or by user-defined
notations. In these situations, computing the right occurrence numbers
is very tedious, because they must be counted on the goal as printed
after setting the <a class="reference internal" href="vernacular-commands.html#coq:flag.Printing-All" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag. Moreover, the resulting script is
not really informative for the reader, since it refers to occurrence
numbers he cannot easily see.</p>
<p>Contextual patterns mitigate these issues by allowing to specify
occurrences according to the context they occur in.</p>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h3>
<p>The following table summarizes the full syntax of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and the
corresponding subterm(s) identified by the pattern. In the third
column, we use s.m.r. for “the subterms matching the redex” specified
in the second column.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></p></th>
<th class="head"><p>redex</p></th>
<th class="head"><p>subterms affected</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p>all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>subterm of <code class="docutils literal notranslate"><span class="pre">term</span></code> selected by <code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
<td><p>all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the
occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term1</span></code> in all s.m.r.</p></td>
<td><p>in all the subterms identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term1</span></code></p></td>
<td><p>in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>
in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term2[term1</span> <span class="pre">/ident]</span></code></p></td>
</tr>
</tbody>
</table>
<p>The rewrite tactic supports two more patterns obtained prefixing the
first two with <code class="docutils literal notranslate"><span class="pre">in</span></code>. The intended meaning is that the pattern identifies
all subterms of the specified context. The <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic will infer a
pattern for the redex looking at the rule used for rewriting.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></p></th>
<th class="head"><p>redex</p></th>
<th class="head"><p>subterms affected</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>inferred from rule</p></td>
<td><p>in all s.m.r. in all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p>inferred from rule</p></td>
<td><p>in all s.m.r. in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>
in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
</tbody>
</table>
<p>The first <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> is the simplest form matching any context but
selecting a specific redex and has been described in the previous
sections. We have seen so far that the possibility of selecting a
redex using a term with holes is already a powerful means of redex
selection. Similarly, any terms provided by the user in the more
complex forms of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a>s
presented in the tables above can contain
holes.</p>
<p>For a quick glance at what can be expressed with the last
<a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a>,
consider the goal <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> and the tactic</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>]</span><span class="coqdoc-var">rule</span><span>.</span><span>
</span></span></div>
<p>It rewrites all occurrences of the left hand side of <code class="docutils literal notranslate"><span class="pre">rule</span></code>
inside <code class="docutils literal notranslate"><span class="pre">b</span></code>  only (<code class="docutils literal notranslate"><span class="pre">a</span></code>, and the hidden type of the equality, are ignored). Note that the
variant <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">[X</span> <span class="pre">in</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">X]rule</span></code> would have rewritten <code class="docutils literal notranslate"><span class="pre">b</span></code>
exactly (i.e., it would only work if <code class="docutils literal notranslate"><span class="pre">b</span></code> and the left-hand side
of rule can be unified).</p>
</div>
<div class="section" id="matching-contextual-patterns">
<h3>Matching contextual patterns<a class="headerlink" href="#matching-contextual-patterns" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and <a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a> involving terms
with holes are matched
against the goal in order to find a closed instantiation. This
matching proceeds as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></p></th>
<th class="head"><p>instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with the
subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term2</span></code> is matched against the goal, <code class="docutils literal notranslate"><span class="pre">term1</span></code>
is matched against the subterm of the instantiation of
<code class="docutils literal notranslate"><span class="pre">term1</span></code> identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term2[term1/ident]</span></code> is matched against
the goal, redex is unified with the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></p></td>
</tr>
</tbody>
</table>
<p>In the following patterns, the redex is intended to be inferred from
the rewrite rule.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></p></th>
<th class="head"><p>instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, the redex is matched against
the subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is matched against the
instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="contextual-pattern-in-set-and-the-tactical">
<h4>Contextual pattern in set and the : tactical<a class="headerlink" href="#contextual-pattern-in-set-and-the-tactical" title="Permalink to this headline">¶</a></h4>
<p>As already mentioned in Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, the <code class="docutils literal notranslate"><span class="pre">set</span></code>
tactic takes as an
argument a term in open syntax. This term is interpreted as the
simplest form of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a>. To avoid confusion in the grammar, open
syntax is supported only for the simplest form of patterns, while
parentheses are required around more complex patterns.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">b</span><span> + 1 = </span><span class="coqdoc-var">b</span><span> + (</span><span class="coqdoc-var">a</span><span> + 1).</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  ============================
  a</span><span> +</span><span> b</span><span> +</span><span> 1</span><span> =</span><span> b</span><span> +</span><span> (a</span><span> +</span><span> 1)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  t := b</span><span> +</span><span> (a</span><span> +</span><span> 1) : nat
  ============================
  a</span><span> +</span><span> b</span><span> +</span><span> 1</span><span> =</span><span> t
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> {}/</span><span class="coqdoc-var">t</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  ============================
  a</span><span> +</span><span> b</span><span> +</span><span> 1</span><span> =</span><span> b</span><span> +</span><span> (a</span><span> +</span><span> 1)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  a, b : nat
  t := a</span><span> +</span><span> 1 : nat
  ============================
  a</span><span> +</span><span> b</span><span> +</span><span> 1</span><span> =</span><span> b</span><span> +</span><span> t
</span></dd>
</dl>
</div>
</div>
<p>Since the user may define an infix notation for <code class="docutils literal notranslate"><span class="pre">in</span></code>, the result of the former
tactic may be ambiguous. The disambiguation rule implemented is to prefer
patterns over simple terms, but to interpret a pattern with double
parentheses as a simple term. For example, the following tactic would
capture any occurrence of the term <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">A</span></code>.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := ((</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">A</span><span>)).</span><span>
</span></span></div>
<p>Contextual patterns can also be used as arguments of the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical.
For example:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">refl_equal</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></span></div>
</div>
<div class="section" id="contextual-patterns-in-rewrite">
<h4>Contextual patterns in rewrite<a class="headerlink" href="#contextual-patterns-in-rewrite" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot;n .+1&quot; := (</span><span class="coqdoc-var">Datatypes.S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-tactic">left</span><span> </span><span class="coqdoc-keyword">associativity</span><span>,</span><span>
                     </span><span class="coqdoc-var">format</span><span> &quot;n .+1&quot;) : </span><span class="coqdoc-var">nat_scope</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addSn</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span>.+1 + </span><span class="coqdoc-var">n</span><span> = (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>).+1.</span><span>
</span></dt><dd><span>addSn is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addn0</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">m</span><span> + 0 = </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>addn0 is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addnC</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>addnC is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">f</span><span> : (</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span>) + </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span>) (</span><span class="coqdoc-var">z</span><span> + (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>).+1) = 0.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  x</span><span>.+1</span><span> +</span><span> y</span><span> +</span><span> f (x</span><span>.+1</span><span> +</span><span> y) (z</span><span> +</span><span> (x</span><span> +</span><span> y)</span><span>.+1</span><span>)</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">addSn</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  x</span><span>.+1</span><span> +</span><span> y</span><span> +</span><span> f (x</span><span> +</span><span> y)</span><span>.+1</span><span> (z</span><span> +</span><span> (x</span><span> +</span><span> y)</span><span>.+1</span><span>)</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>Note: the simplification rule <code class="docutils literal notranslate"><span class="pre">addSn</span></code> is applied only under the <code class="docutils literal notranslate"><span class="pre">f</span></code>
symbol.
Then, we simplify also the first addition and expand <code class="docutils literal notranslate"><span class="pre">0</span></code> into <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">addSn</span><span> -[</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>]</span><span class="coqdoc-var">addn0</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  (x</span><span> +</span><span> y)</span><span>.+1</span><span> +</span><span> f (x</span><span> +</span><span> y)</span><span>.+1</span><span> (z</span><span> +</span><span> (x</span><span> +</span><span> y)</span><span>.+1</span><span>)</span><span> =</span><span> 0</span><span> +</span><span> 0
</span></dd>
</dl>
</div>
<p>Note that the right-hand side of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is undetermined, but the
rewrite pattern specifies the redex explicitly. The right-hand side
of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is unified with the term identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>, here <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The following pattern does not specify a redex, since it identifies an
entire region; hence the rewrite rule has to be instantiated
explicitly. Thus the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> -{2}[</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>](</span><span class="coqdoc-var">addn0</span><span> 0).</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  (x</span><span> +</span><span> y)</span><span>.+1</span><span> +</span><span> f (x</span><span> +</span><span> y)</span><span>.+1</span><span> (z</span><span> +</span><span> (x</span><span> +</span><span> y)</span><span>.+1</span><span>)</span><span> =</span><span> 0</span><span> +</span><span> (0</span><span> +</span><span> 0)
</span></dd>
</dl>
</div>
<p>The following tactic is quite tricky:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">_</span><span>.+1 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">X</span><span>](</span><span class="coqdoc-var">addnC</span><span> </span><span class="coqdoc-var">x</span><span>.+1).</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  (x</span><span> +</span><span> y)</span><span>.+1</span><span> +</span><span> f (x</span><span> +</span><span> y)</span><span>.+1</span><span> (z</span><span> +</span><span> (y</span><span> +</span><span> x</span><span>.+1</span><span>))</span><span> =</span><span> 0</span><span> +</span><span> (0</span><span> +</span><span> 0)
</span></dd>
</dl>
</div>
<p>The explicit redex <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is important, since its <a class="reference internal" href="../proofs/writing-proofs/equality.html#term-head-constant"><span class="xref std std-term">head constant</span></a> <code class="docutils literal notranslate"><span class="pre">S</span></code>
differs from the head constant inferred from
<code class="docutils literal notranslate"><span class="pre">(addnC</span> <span class="pre">x.+1)</span></code> (that is <code class="docutils literal notranslate"><span class="pre">+</span></code>).
Moreover, the pattern <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code> is important to rule out
the first occurrence of <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.
Last, only the subterms of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code>
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code> are rewritten; thus the first argument of
<code class="docutils literal notranslate"><span class="pre">f</span></code> is skipped too.
Also note that the pattern <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is interpreted in the context
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>; thus it gets instantiated to
<code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">+</span> <span class="pre">x).+1</span></code> and not <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.</p>
<p>The last rewrite pattern allows to specify exactly the shape of the
term identified by X, which is thus unified with the left-hand side of
the rewrite rule.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">addnC</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  f : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
  ============================
  (x</span><span> +</span><span> y)</span><span>.+1</span><span> +</span><span> f (y</span><span> +</span><span> x</span><span>.+1</span><span>) (z</span><span> +</span><span> (y</span><span> +</span><span> x</span><span>.+1</span><span>))</span><span> =</span><span> 0</span><span> +</span><span> (0</span><span> +</span><span> 0)
</span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="patterns-for-recurrent-contexts">
<h3>Patterns for recurrent contexts<a class="headerlink" href="#patterns-for-recurrent-contexts" title="Permalink to this headline">¶</a></h3>
<p>The user can define shortcuts for recurrent contexts corresponding to
the <code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part. The notation scope identified with
<code class="docutils literal notranslate"><span class="pre">%pattern</span></code>
provides a special notation <code class="docutils literal notranslate"><span class="pre">(X</span> <span class="pre">in</span> <span class="pre">t)</span></code> the user must adopt
in order to define
context shortcuts.</p>
<p>The following example is taken from <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>, where the
<code class="docutils literal notranslate"><span class="pre">LHS</span></code> and <code class="docutils literal notranslate"><span class="pre">RHS</span></code> shortcuts are defined.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">RHS</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>)%</span><span class="coqdoc-tactic">pattern</span><span>.</span><span>
</span><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">LHS</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> = </span><span class="coqdoc-var">_</span><span>)%</span><span class="coqdoc-tactic">pattern</span><span>.</span><span>
</span></span></div>
<p>Shortcuts defined this way can be freely used in place of the trailing
<code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part of any contextual pattern. Some examples follow:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">rhs</span><span> := </span><span class="coqdoc-var">RHS</span><span>.</span><span>
</span><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">RHS</span><span>]</span><span class="coqdoc-var">rule</span><span>.</span><span>
</span><span class="coqdoc-tactic">case</span><span>: (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">RHS</span><span>).</span><span>
</span></span></div>
</div>
</div>
<div class="section" id="views-and-reflection">
<span id="views-and-reflection-ssr"></span><h2>Views and reflection<a class="headerlink" href="#views-and-reflection" title="Permalink to this headline">¶</a></h2>
<p>The bookkeeping facilities presented in Section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a> are
crafted to ease simultaneous introductions and generalizations of facts and
operations of casing, naming, etc. It also a common practice to make a stack
operation immediately followed by an <em>interpretation</em> of the fact
being pushed, that is, to apply a lemma to this fact before passing it
to a tactic for decomposition, application and so on.</p>
<p><span class="smallcaps">SSReflect</span> provides a convenient, unified syntax to combine these
interpretation operations with the proof stack operations. This <em>view
mechanism</em> relies on the combination of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch with
bookkeeping tactics and tacticals.</p>
<div class="section" id="interpreting-eliminations">
<span id="custom-elim-ssr"></span><h3>Interpreting eliminations<a class="headerlink" href="#interpreting-eliminations" title="Permalink to this headline">¶</a></h3>
<p>The view syntax combined with the <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic specifies an elimination
scheme to be used instead of the default, generated, one. Hence, the
<span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">V</span><span>.</span><span>
</span></span></div>
<p>is a synonym for:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">V</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">top</span><span>.</span><span>
</span></span></div>
<p>where top is a fresh name and V any second-order lemma.</p>
<p>Since an elimination view supports the two bookkeeping tacticals of
discharge and introduction (see Section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a>),
the <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">V</span><span>: </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></span></div>
<p>is a synonym for:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">V</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">x</span><span>; </span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable in the context, <code class="docutils literal notranslate"><span class="pre">y</span></code> a fresh name and <code class="docutils literal notranslate"><span class="pre">V</span></code>
any second order lemma; <span class="smallcaps">SSReflect</span> relaxes the syntactic restrictions of the Coq
<code class="docutils literal notranslate"><span class="pre">elim</span></code>. The first pattern following <code class="docutils literal notranslate"><span class="pre">:</span></code> can be a <code class="docutils literal notranslate"><span class="pre">_</span></code> wildcard if the
conclusion of the view <code class="docutils literal notranslate"><span class="pre">V</span></code> specifies a pattern for its last argument
(e.g., if <code class="docutils literal notranslate"><span class="pre">V</span></code> is a functional induction lemma generated by the
<code class="docutils literal notranslate"><span class="pre">Function</span></code> command).</p>
<p>The elimination view mechanism is compatible with the equation-name
generation (see Section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>The following script illustrates a toy example of this feature. Let us
define a function adding an element at the end of a list:</p>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">List</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">d</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd><span>d is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add_last</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) (</span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">d</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">s</span><span>} : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-var">z</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">z</span><span> :: </span><span class="coqdoc-var">nil</span><span>.</span><span>
</span></dt><dd><span>add_last is defined
add_last is recursively defined (guarded on 1st argument)
</span></dd>
</dl>
</div>
<p>One can define an alternative, reversed, induction principle on
inductively defined lists, by proving the following lemma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">last_ind_list</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>,</span><span>
  </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">nil</span><span> -&gt; (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">d</span><span>), </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">s</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span>)) -&gt;</span><span>
    </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">s</span><span>.</span><span>
</span></dt><dd><span>last_ind_list is declared
</span></dd>
</dl>
</div>
<p>Then, the combination of elimination views with equation names results
in a concise syntax for reasoning inductively using the user-defined
elimination scheme.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">d</span><span>) (</span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>): </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">l</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  d : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  x : d
  l : list d
  ============================
  l</span><span> =</span><span> l
</span></dd>
<dt><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">last_ind_list</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">l</span><span>=&gt; [| </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-var">v</span><span>]; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">first</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  d : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  x : d
  u : list d
  v : d
  l : list d
  E : l</span><span> =</span><span> add_last u v
  ============================
  u</span><span> =</span><span> u</span><span> -&gt;</span><span> add_last u v</span><span> =</span><span> add_last u v

goal 2 is:
 nil</span><span> =</span><span> nil
</span></dd>
</dl>
</div>
</div>
<p>User-provided eliminators (potentially generated with Coq’s <code class="docutils literal notranslate"><span class="pre">Function</span></code>
command) can be combined with the type family switches described
in Section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.
Consider an eliminator <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code> of type:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">foo_ind</span><span> : </span><span class="coqdoc-keyword">forall</span><span> …, </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">p1</span><span> … </span><span class="coqdoc-var">pm</span><span>.</span><span>
</span></span></div>
<p>and consider the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">foo_ind</span><span>: </span><span class="coqdoc-var">e1</span><span> … / </span><span class="coqdoc-var">en</span><span>.</span><span>
</span></span></div>
<p>The <code class="docutils literal notranslate"><span class="pre">elim/</span></code> tactic distinguishes two cases.</p>
<dl class="field-list simple">
<dt class="field-odd">truncated eliminator</dt>
<dd class="field-odd"><p>when <code class="docutils literal notranslate"><span class="pre">x</span></code> does not occur in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">p1</span> <span class="pre">…</span> <span class="pre">pm</span></code> and the
type of <code class="docutils literal notranslate"><span class="pre">en</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">en</span></code> is not <code class="docutils literal notranslate"><span class="pre">_</span></code>.
In that case, <code class="docutils literal notranslate"><span class="pre">en</span></code> is
passed to the eliminator as the last argument (<code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code>) and
<code class="docutils literal notranslate"><span class="pre">en−1</span> <span class="pre">…</span> <span class="pre">e1</span></code> are used as patterns to select in the goal the occurrences that
will be bound by the predicate <code class="docutils literal notranslate"><span class="pre">P</span></code>; thus it must be possible to unify
the subterm of the goal matched by <code class="docutils literal notranslate"><span class="pre">en−1</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched
by <code class="docutils literal notranslate"><span class="pre">en−2</span></code> with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on.</p>
</dd>
<dt class="field-even">regular eliminator</dt>
<dd class="field-even"><p>in all the other cases. Here it must be possible
to unify the term matched by <code class="docutils literal notranslate"><span class="pre">en</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched by
<code class="docutils literal notranslate"><span class="pre">en−1</span></code>
with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on. Note that standard eliminators have the shape
<code class="docutils literal notranslate"><span class="pre">…forall</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">…</span> <span class="pre">x</span></code>; thus <code class="docutils literal notranslate"><span class="pre">en</span></code> is the pattern identifying the
eliminated term, as expected.</p>
</dd>
</dl>
<p>As explained in Section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>, the initial prefix of
<code class="docutils literal notranslate"><span class="pre">ei</span></code> can be omitted.</p>
<p>Here is an example of a regular, but nontrivial, eliminator.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Here is a toy example illustrating this feature.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>[Loading ML file extraction_plugin.cmxs (using legacy method) ... done]
[Loading ML file funind_plugin.cmxs (using legacy method) ... done]
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd><span>plus is defined
plus is recursively defined (guarded on 2nd argument)
plus_equation is defined
plus_rect is defined
plus_ind is defined
plus_rec is defined
R_plus_correct is defined
R_plus_complete is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span><span>
</span></dt><dd><span>plus_ind :
</span><span class="ansi-bold">forall</span><span> [m : nat] [P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>],
(</span><span class="ansi-bold">forall</span><span> n p : nat, n</span><span> =</span><span> S p</span><span> -&gt;</span><span> P p (plus m p)</span><span> -&gt;</span><span> P (S p) (S (plus m p)))</span><span> -&gt;</span><span>
(</span><span class="ansi-bold">forall</span><span> n _x : nat,
 n</span><span> =</span><span> _x</span><span> -&gt;</span><span> </span><span class="ansi-bold">match</span><span> _x </span><span class="ansi-bold">with</span><span>
           | 0 =&gt; True
           | S _ =&gt; False
           </span><span class="ansi-bold">end</span><span> -&gt;</span><span> P _x m)</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : nat, P n (plus m n)

plus_ind is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">plus_ind</span><span> [m]%nat_scope [P]%function_scope 
  (f f0)%function_scope n%nat_scope
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  x, y, z : nat
  ============================
  plus (plus x y) z</span><span> =</span><span> plus x (plus y z)
</span></dd>
</dl>
</div>
<p>The following tactics are all valid and perform the same elimination
on this goal.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span>).</span><span>
</span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: {</span><span class="coqdoc-var">z</span><span>}(</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span>).</span><span>
</span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: {</span><span class="coqdoc-var">z</span><span>}</span><span class="coqdoc-var">_</span><span>.</span><span>
</span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></span></div>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>plus is defined
plus is recursively defined (guarded on 2nd argument)
plus_equation is defined
plus_rect is defined
plus_ind is defined
plus_rec is defined
R_plus_correct is defined
R_plus_complete is defined
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>plus_ind :
</span><span class="ansi-bold">forall</span><span> [m : nat] [P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>],
(</span><span class="ansi-bold">forall</span><span> n p : nat, n</span><span> =</span><span> S p</span><span> -&gt;</span><span> P p (plus m p)</span><span> -&gt;</span><span> P (S p) (S (plus m p)))</span><span> -&gt;</span><span>
(</span><span class="ansi-bold">forall</span><span> n _x : nat,
 n</span><span> =</span><span> _x</span><span> -&gt;</span><span> </span><span class="ansi-bold">match</span><span> _x </span><span class="ansi-bold">with</span><span>
           | 0 =&gt; True
           | S _ =&gt; False
           </span><span class="ansi-bold">end</span><span> -&gt;</span><span> P _x m)</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : nat, P n (plus m n)

plus_ind is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">plus_ind</span><span> [m]%nat_scope [P]%function_scope 
  (f f0)%function_scope n%nat_scope
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y, z : nat
  ============================
  plus (plus x y) z</span><span> =</span><span> plus x (plus y z)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  x, y : nat
  ============================
  </span><span class="ansi-bold">forall</span><span> n p : nat,
  n</span><span> =</span><span> S p</span><span> -&gt;</span><span>
  plus (plus x y) p</span><span> =</span><span> plus x (plus y p)</span><span> -&gt;</span><span>
  S (plus (plus x y) p)</span><span> =</span><span> plus x (plus y (S p))

goal 2 is:
 </span><span class="ansi-bold">forall</span><span> n _x : nat,
 n</span><span> =</span><span> _x</span><span> -&gt;</span><span>
 </span><span class="ansi-bold">match</span><span> _x </span><span class="ansi-bold">with</span><span>
 | 0 =&gt; True
 | S _ =&gt; False
 </span><span class="ansi-bold">end</span><span> -&gt;</span><span> plus x y</span><span> =</span><span> plus x (plus y _x)
</span></dd>
</dl>
</div>
<p>The two latter examples feature a wildcard pattern: in this case,
the resulting pattern is inferred from the type of the eliminator.
In both of these examples, it is <code class="docutils literal notranslate"><span class="pre">(plus</span> <span class="pre">_</span> <span class="pre">_)</span></code> that matches the subterm
<code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">(plus</span> <span class="pre">x</span> <span class="pre">y)</span> <span class="pre">z</span></code>, thus instantiating the last <code class="docutils literal notranslate"><span class="pre">_</span></code> with <code class="docutils literal notranslate"><span class="pre">z</span></code>.
Note that the tactic:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>plus is defined
plus is recursively defined (guarded on 2nd argument)
plus_equation is defined
plus_rect is defined
plus_ind is defined
plus_rec is defined
R_plus_correct is defined
R_plus_complete is defined
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>plus_ind :
</span><span class="ansi-bold">forall</span><span> [m : nat] [P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>],
(</span><span class="ansi-bold">forall</span><span> n p : nat, n</span><span> =</span><span> S p</span><span> -&gt;</span><span> P p (plus m p)</span><span> -&gt;</span><span> P (S p) (S (plus m p)))</span><span> -&gt;</span><span>
(</span><span class="ansi-bold">forall</span><span> n _x : nat,
 n</span><span> =</span><span> _x</span><span> -&gt;</span><span> </span><span class="ansi-bold">match</span><span> _x </span><span class="ansi-bold">with</span><span>
           | 0 =&gt; True
           | S _ =&gt; False
           </span><span class="ansi-bold">end</span><span> -&gt;</span><span> P _x m)</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : nat, P n (plus m n)

plus_ind is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">plus_ind</span><span> [m]%nat_scope [P]%function_scope 
  (f f0)%function_scope n%nat_scope
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y, z : nat
  ============================
  plus (plus x y) z</span><span> =</span><span> plus x (plus y z)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">y</span><span> / </span><span class="coqdoc-var">_</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
The given pattern matches the term y while the inferred pattern z doesn't
</span></dd>
</dl>
</div>
<p>triggers an error: in the conclusion
of the <code class="docutils literal notranslate"><span class="pre">plus_ind</span></code> eliminator, the first argument of the predicate
<code class="docutils literal notranslate"><span class="pre">P</span></code> should be the same as the second argument of <code class="docutils literal notranslate"><span class="pre">plus</span></code>, in the
second argument of <code class="docutils literal notranslate"><span class="pre">P</span></code>, but <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> do no unify.</p>
</div>
<p>Here is an example of a truncated eliminator:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Consider the goal:</p>
<div class="coqtop literal-block coqtop-hidden docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
</div>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">n_gt0</span><span> : 0 &lt; </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">pr_p</span><span> : </span><span class="coqdoc-var">prime</span><span> </span><span class="coqdoc-var">p</span><span>) :</span><span>
  </span><span class="coqdoc-var">p</span><span> %| \</span><span class="coqdoc-var">prod_</span><span>(</span><span class="coqdoc-var">i</span><span> &lt;- </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">i</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">i</span><span>.1 ^ </span><span class="coqdoc-var">i</span><span>.2 -&gt;</span><span>
    </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1.</span><span>
</span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">big_prop</span><span>: </span><span class="coqdoc-var">_</span><span> =&gt; [| </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-var">v</span><span> </span><span class="coqdoc-var">IHu</span><span> </span><span class="coqdoc-var">IHv</span><span> | [</span><span class="coqdoc-var">q</span><span> </span><span class="coqdoc-var">e</span><span>] /=].</span><span>
</span></span></div>
<p>where the type of the <code class="docutils literal notranslate"><span class="pre">big_prop</span></code> eliminator is</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">big_prop</span><span>: </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">Pb</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span>)</span><span>
  (</span><span class="coqdoc-var">idx</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">op1</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>), </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">idx</span><span> -&gt;</span><span>
  (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">R</span><span>, </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">x</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> (</span><span class="coqdoc-var">op1</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>)) -&gt;</span><span>
  </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">r</span><span> : </span><span class="coqdoc-var">seq</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">pred</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">F</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>),</span><span>
  (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> (</span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">i</span><span>)) -&gt;</span><span>
    </span><span class="coqdoc-var">Pb</span><span> (\</span><span class="coqdoc-var">big</span><span>[</span><span class="coqdoc-var">op1</span><span>/</span><span class="coqdoc-var">idx</span><span>]</span><span class="coqdoc-var">_</span><span>(</span><span class="coqdoc-var">i</span><span> &lt;- </span><span class="coqdoc-var">r</span><span> | </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span>) </span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">i</span><span>).</span><span>
</span></span></div>
<p>Since the pattern for the argument of Pb is not specified, the
inferred one, <code class="docutils literal notranslate"><span class="pre">big[_/_]_(i</span> <span class="pre">&lt;-</span> <span class="pre">_</span> <span class="pre">|</span> <span class="pre">_</span> <span class="pre">i)</span> <span class="pre">_</span> <span class="pre">i</span></code>, is used instead,
and after the introductions, the following goals are generated:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-var">subgoal</span><span> 1 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
  </span><span class="coqdoc-var">p</span><span> %| 1 -&gt; </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1</span><span>
</span><span class="coqdoc-var">subgoal</span><span> 2 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
  </span><span class="coqdoc-var">p</span><span> %| </span><span class="coqdoc-var">u</span><span> * </span><span class="coqdoc-var">v</span><span> -&gt; </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1</span><span>
</span><span class="coqdoc-var">subgoal</span><span> 3 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
  (</span><span class="coqdoc-var">q</span><span>, </span><span class="coqdoc-var">e</span><span>) \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">p</span><span> %| </span><span class="coqdoc-var">q</span><span> ^ </span><span class="coqdoc-var">e</span><span> -&gt;</span><span>
    </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1.</span><span>
</span></span></div>
<p>Note that the pattern matching algorithm instantiated all the
variables occurring in the pattern.</p>
</div>
</div>
<div class="section" id="interpreting-assumptions">
<span id="interpreting-assumptions-ssr"></span><h3>Interpreting assumptions<a class="headerlink" href="#interpreting-assumptions" title="Permalink to this headline">¶</a></h3>
<p>Interpreting an assumption in the context of a proof consists in
applying to it a lemma before generalizing and/or decomposing this
assumption. For instance, with the extensive use of boolean reflection
(see Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>), it is quite frequent
to need to decompose the logical interpretation of (the boolean
expression of) a fact, rather than the fact itself. This can be
achieved by a combination of <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> switches, like in the
following example, where <code class="docutils literal notranslate"><span class="pre">||</span></code> is a notation for the boolean
disjunction.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>P2Q is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">a</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> Q a
  a : bool
  ============================
  P (a </span><span>|| </span><span>a)</span><span> -&gt;</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HPa</span><span>; </span><span class="coqdoc-tactic">move</span><span>: {</span><span class="coqdoc-var">HPa</span><span>}(</span><span class="coqdoc-var">P2Q</span><span> </span><span class="coqdoc-var">HPa</span><span>) =&gt; </span><span class="coqdoc-var">HQa</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> Q a
  a : bool
  HQa : Q a
  ============================
  True
</span></dd>
</dl>
</div>
<p>which transforms the hypothesis <code class="docutils literal notranslate"><span class="pre">HPa</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">a</span></code>, which has been introduced
from the initial statement, into <code class="docutils literal notranslate"><span class="pre">HQa</span> <span class="pre">:</span> <span class="pre">Q</span> <span class="pre">a</span></code>.
This operation is so common that the tactic shell has specific
syntax for it. The following scripts:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
Q is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P2Q is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">a</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> Q a
  a : bool
  ============================
  P (a </span><span>|| </span><span>a)</span><span> -&gt;</span><span> True
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HPa</span><span>; </span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>: </span><span class="coqdoc-var">HPa</span><span> =&gt; </span><span class="coqdoc-var">HQa</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> Q a
  a : bool
  HQa : Q a
  ============================
  True
</span></dd>
</dl>
</div>
<p>or more directly:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>=&gt; </span><span class="coqdoc-var">HQa</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> Q a
  a : bool
  HQa : Q a
  ============================
  True
</span></dd>
</dl>
</div>
<p>are equivalent to the former one. The former script shows how to
interpret a fact (already in the context), thanks to the discharge
tactical (see Section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>), and the latter, how to interpret the top
assumption of a goal. Note that the number of wildcards to be inserted
to find the correct application of the view lemma to the hypothesis
has been automatically inferred.</p>
</div>
<p>The view mechanism is compatible with the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic and with the
equation-name generation mechanism (see Section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>):</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">Q2P</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">a</span><span> \/ </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>Q2P is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q2P : </span><span class="ansi-bold">forall</span><span> a b : bool, Q (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> P a</span><span> \/</span><span> P b
  a, b : bool
  ============================
  Q (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">case</span><span>/</span><span class="coqdoc-var">Q2P</span><span>=&gt; [</span><span class="coqdoc-var">HPa</span><span> | </span><span class="coqdoc-var">HPb</span><span>].</span><span>
</span></dt><dd><span>2 goals
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q2P : </span><span class="ansi-bold">forall</span><span> a b : bool, Q (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> P a</span><span> \/</span><span> P b
  a, b : bool
  HPa : P a
  ============================
  True

goal 2 is:
 True
</span></dd>
</dl>
</div>
<p>This view tactic performs:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HQ</span><span>; </span><span class="coqdoc-tactic">case</span><span>: {</span><span class="coqdoc-var">HQ</span><span>}(</span><span class="coqdoc-var">Q2P</span><span> </span><span class="coqdoc-var">HQ</span><span>) =&gt; [</span><span class="coqdoc-var">HPa</span><span> | </span><span class="coqdoc-var">HPb</span><span>].</span><span>
</span></span></div>
</div>
<p>The term on the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch is called a <em>view lemma</em>.
Any <span class="smallcaps">SSReflect</span> term coercing to a product type can be used as a view
lemma.</p>
<p>The examples we have given so far explicitly provide the direction of
the translation to be performed. In fact, view lemmas need not to be
oriented. The view mechanism is able to detect which application is
relevant for the current goal.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">PQequiv</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) &lt;-&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>PQequiv is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  PQequiv : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> &lt;-&gt;</span><span> Q a
  a, b : bool
  ============================
  P (a </span><span>|| </span><span>b)</span><span> -&gt;</span><span> True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">PQequiv</span><span>=&gt; </span><span class="coqdoc-var">HQab</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  PQequiv : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> &lt;-&gt;</span><span> Q a
  a, b : bool
  HQab : Q a
  ============================
  True
</span></dd>
</dl>
</div>
<p>has the same behavior as the first example above.</p>
<p>The view mechanism can insert automatically a <em>view hint</em> to transform
the double implication into the expected simple implication. The last
script is in fact equivalent to:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span><span>
</span><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">iffLR</span><span> (</span><span class="coqdoc-var">PQequiv</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>)).</span><span>
</span></span></div>
<p>where:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffLR</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span><span>
</span></span></div>
</div>
<div class="section" id="specializing-assumptions">
<h4>Specializing assumptions<a class="headerlink" href="#specializing-assumptions" title="Permalink to this headline">¶</a></h4>
<p>The special case when the <em>head symbol</em> of the view lemma is a
wildcard is used to interpret an assumption by <em>specializing</em> it. The
view mechanism hence offers the possibility to apply a higher-order
assumption to some given arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">z</span><span> : (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span> -&gt; </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">x</span><span>) -&gt; </span><span class="coqdoc-var">z</span><span> = 0.</span><span>
</span></dt><dd><span>1 goal
  
  z : nat
  ============================
  (</span><span class="ansi-bold">forall</span><span> x y : nat, x</span><span> +</span><span> y</span><span> =</span><span> z</span><span> -&gt;</span><span> z</span><span> =</span><span> x)</span><span> -&gt;</span><span> z</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">_</span><span> 0 </span><span class="coqdoc-var">z</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  z : nat
  ============================
  (0</span><span> +</span><span> z</span><span> =</span><span> z</span><span> -&gt;</span><span> z</span><span> =</span><span> 0)</span><span> -&gt;</span><span> z</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="interpreting-goals">
<h3>Interpreting goals<a class="headerlink" href="#interpreting-goals" title="Permalink to this headline">¶</a></h3>
<p>In a similar way, it is also often convenient to
change a goal by turning it into an equivalent proposition. The view
mechanism of <span class="smallcaps">SSReflect</span> has a special syntax <code class="docutils literal notranslate"><span class="pre">apply/</span></code> for combining  in a
single tactic simultaneous goal interpretation operations and
bookkeeping steps.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>The following example use the <code class="docutils literal notranslate"><span class="pre">~~</span></code> prenex notation for boolean negation:</p>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">PQequiv</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) &lt;-&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>PQequiv is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> ((~~ </span><span class="coqdoc-var">a</span><span>) || </span><span class="coqdoc-var">a</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  PQequiv : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> &lt;-&gt;</span><span> Q a
  a : bool
  ============================
  P (</span><span>~~</span><span> a </span><span>|| </span><span>a)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">PQequiv</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : bool</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  PQequiv : </span><span class="ansi-bold">forall</span><span> a b : bool, P (a </span><span>|| </span><span>b)</span><span> &lt;-&gt;</span><span> Q a
  a : bool
  ============================
  Q (</span><span>~~</span><span> a)
</span></dd>
</dl>
</div>
<p>thus in this case, the tactic <code class="docutils literal notranslate"><span class="pre">apply/PQequiv</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(iffRL</span> <span class="pre">(PQequiv</span> <span class="pre">_</span> <span class="pre">_))</span></code>, where <code class="docutils literal notranslate"><span class="pre">iffRL</span></code> is the analogue of
<code class="docutils literal notranslate"><span class="pre">iffLR</span></code> for the converse implication.</p>
</div>
<p>Any <span class="smallcaps">SSReflect</span> term whose type coerces to a double implication can be
used as a view for goal interpretation.</p>
<p>Note that the goal interpretation view mechanism supports both <code class="docutils literal notranslate"><span class="pre">apply</span></code>
and <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactics. As expected, a goal interpretation view command
<code class="docutils literal notranslate"><span class="pre">exact</span></code>/term should solve the current goal or it will fail.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Goal-interpretation view tactics are <em>not</em> compatible with
the bookkeeping tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>, since this would be redundant with the
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">term</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> construction.</p>
</div>
</div>
<div class="section" id="boolean-reflection">
<h3>Boolean reflection<a class="headerlink" href="#boolean-reflection" title="Permalink to this headline">¶</a></h3>
<p>In the Calculus of Inductive Constructions, there is an obvious
distinction between logical propositions and boolean values. On the
one hand, logical propositions are objects of <em>sort</em> <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, which is
the carrier of intuitionistic reasoning. Logical connectives in
<code class="docutils literal notranslate"><span class="pre">Prop</span></code> are <em>types</em>, which give precise information on the structure
of their proofs; this information is automatically exploited by Coq
tactics.  For example, Coq knows that a proof of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> is
either a proof of <code class="docutils literal notranslate"><span class="pre">A</span></code> or a proof of <code class="docutils literal notranslate"><span class="pre">B</span></code>.  The tactics <code class="docutils literal notranslate"><span class="pre">left</span></code> and
<code class="docutils literal notranslate"><span class="pre">right</span></code> change the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, respectively;
dually, the tactic <code class="docutils literal notranslate"><span class="pre">case</span></code> reduces the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> to two
subgoals <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code>.</p>
<p>On the other hand, bool is an inductive <em>datatype</em> with two
constructors: <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>. Logical connectives on bool are
<em>computable functions</em>, defined by their truth tables, using case
analysis:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">orb</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) := </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">b2</span><span>.</span><span>
</span></dt><dd><span>orb is defined
</span></dd>
</dl>
</div>
</div>
<p>Properties of such connectives are also established using case
analysis</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">b</span><span> || ~~ </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">true</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  b : bool
  ============================
  b </span><span>|| </span><span>~~</span><span> b</span><span> =</span><span> true
</span></dd>
<dt><span></span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">case</span><span>: </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>Once <code class="docutils literal notranslate"><span class="pre">b</span></code> is replaced by <code class="docutils literal notranslate"><span class="pre">true</span></code> in the first goal and by <code class="docutils literal notranslate"><span class="pre">false</span></code> in the
second one, the goals reduce by computation to the trivial <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">=</span> <span class="pre">true</span></code>.</p>
</div>
<p>Thus, <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> are truly complementary: the former supports
robust natural deduction; the latter allows brute-force
evaluation. <span class="smallcaps">SSReflect</span> supplies a generic mechanism to have the best of
the two worlds and move freely from a propositional version of a
decidable predicate to its boolean version.</p>
<p>First, booleans are injected into propositions using the coercion
mechanism:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Coercion</span><span> </span><span class="coqdoc-var">is_true</span><span> (</span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) := </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">true</span><span>.</span><span>
</span></span></div>
<p>This allows any boolean formula <code class="docutils literal notranslate"><span class="pre">b</span></code> to be used in a context where Coq
would expect a proposition, e.g., after <code class="docutils literal notranslate"><span class="pre">Lemma</span> <span class="pre">…</span> <span class="pre">:</span></code>. It is then
interpreted as <code class="docutils literal notranslate"><span class="pre">(is_true</span> <span class="pre">b)</span></code>, i.e., the proposition <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">true</span></code>. Coercions
are elided by the pretty-printer; so they are essentially transparent
to the user.</p>
</div>
<div class="section" id="the-reflect-predicate">
<h3>The reflect predicate<a class="headerlink" href="#the-reflect-predicate" title="Permalink to this headline">¶</a></h3>
<p>To get all the benefits of the boolean reflection, it is in fact
convenient to introduce the following inductive predicate <code class="docutils literal notranslate"><span class="pre">reflect</span></code> to
relate propositions and booleans:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">reflect</span><span> (</span><span class="coqdoc-var">P</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>): </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">Reflect_true</span><span> : </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">true</span><span>
| </span><span class="coqdoc-var">Reflect_false</span><span> : ~</span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">false</span><span>.</span><span>
</span></span></div>
<p>The statement <code class="docutils literal notranslate"><span class="pre">(reflect</span> <span class="pre">P</span> <span class="pre">b)</span></code> asserts that <code class="docutils literal notranslate"><span class="pre">(is_true</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> are
logically equivalent propositions.</p>
<p>For instance, the following lemma:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">andP</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>, </span><span class="coqdoc-var">reflect</span><span> (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></span></div>
<p>relates the boolean conjunction to the logical one <code class="docutils literal notranslate"><span class="pre">/\</span></code>. Note that in
<code class="docutils literal notranslate"><span class="pre">andP</span></code>, <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> are two boolean variables and the
proposition <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> hides two coercions. The conjunction of
<code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> can then be viewed as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> or as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">&amp;&amp;</span> <span class="pre">b2</span></code>.</p>
<p>Expressing logical equivalences through this family of inductive types
makes possible to take benefit from <em>rewritable equations</em> associated
to the case analysis of Coq’s inductive types.</p>
<p>Since the equivalence predicate is defined in Coq as:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">iff</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) := (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) /\ (</span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">/\</span></code> is a notation for <code class="docutils literal notranslate"><span class="pre">and</span></code>:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">and</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">conj</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">and</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></span></div>
<p>This makes case analysis very different according to the way an
equivalence property has been defined.</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">andE</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) : (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) &lt;-&gt; (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></span></div>
<p>Let us compare the respective behaviors of <code class="docutils literal notranslate"><span class="pre">andE</span></code> and <code class="docutils literal notranslate"><span class="pre">andP</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">andE</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>), (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) &lt;-&gt; (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>andE is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-keyword">if</span><span> (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">else</span><span> ~~(</span><span class="coqdoc-var">b1</span><span>||</span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  b1, b2 : bool
  ============================
  </span><span class="ansi-bold">if</span><span> b1</span><span> &amp;&amp;</span><span> b2 </span><span class="ansi-bold">then</span><span> b1 </span><span class="ansi-bold">else</span><span> </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: (&#64;</span><span class="coqdoc-var">andE</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  b1, b2 : bool
  ============================
  (b1</span><span> /\</span><span> b2</span><span> -&gt;</span><span> b1</span><span> &amp;&amp;</span><span> b2)</span><span> -&gt;</span><span>
  (b1</span><span> &amp;&amp;</span><span> b2</span><span> -&gt;</span><span> b1</span><span> /\</span><span> b2)</span><span> -&gt;</span><span> </span><span class="ansi-bold">if</span><span> b1</span><span> &amp;&amp;</span><span> b2 </span><span class="ansi-bold">then</span><span> b1 </span><span class="ansi-bold">else</span><span> </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Restart</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  b1, b2 : bool
  ============================
  </span><span class="ansi-bold">if</span><span> b1</span><span> &amp;&amp;</span><span> b2 </span><span class="ansi-bold">then</span><span> b1 </span><span class="ansi-bold">else</span><span> </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">case</span><span>: (&#64;</span><span class="coqdoc-var">andP</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>).</span><span>
</span></dt><dd><span>2 goals
  
  b1, b2 : bool
  ============================
  b1</span><span> /\</span><span> b2</span><span> -&gt;</span><span> b1

goal 2 is:
 </span><span>~</span><span> (b1</span><span> /\</span><span> b2)</span><span> -&gt;</span><span> </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)
</span></dd>
</dl>
</div>
</div>
<p>Expressing reflection relations through the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate is hence
a very convenient way to deal with classical reasoning, by case
analysis. Using the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate allows, moreover, to program rich
specifications inside its two constructors, which will be
automatically taken into account during destruction. This
formalisation style gives far more efficient specifications than
quantified (double) implications.</p>
<p>A naming convention in <span class="smallcaps">SSReflect</span> is to postfix the name of view lemmas
with <code class="docutils literal notranslate"><span class="pre">P</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">orP</span></code> relates <code class="docutils literal notranslate"><span class="pre">||</span></code> and <code class="docutils literal notranslate"><span class="pre">\/</span></code>;
<code class="docutils literal notranslate"><span class="pre">negP</span></code> relates <code class="docutils literal notranslate"><span class="pre">~~</span></code> and <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>The view mechanism is compatible with reflect predicates.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">Ha</span><span> : </span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">Hb</span><span> : </span><span class="coqdoc-var">b</span><span>) : </span><span class="coqdoc-var">a</span><span> /\ </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  Ha : a
  Hb : b
  ============================
  a</span><span> /\</span><span> b
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  Ha : a
  Hb : b
  ============================
  a</span><span> &amp;&amp;</span><span> b
</span></dd>
</dl>
</div>
<p>Conversely</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">a</span><span> /\ </span><span class="coqdoc-var">b</span><span> -&gt; </span><span class="coqdoc-var">a</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  ============================
  a</span><span> /\</span><span> b</span><span> -&gt;</span><span> a
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  ============================
  a</span><span> &amp;&amp;</span><span> b</span><span> -&gt;</span><span> a
</span></dd>
</dl>
</div>
</div>
<p>The same tactics can also be used to perform the converse operation,
changing a boolean conjunction into a logical one. The view mechanism
guesses the direction of the transformation to be used, i.e., the
constructor of the reflect predicate that should be chosen.</p>
</div>
<div class="section" id="general-mechanism-for-interpreting-goals-and-assumptions">
<h3>General mechanism for interpreting goals and assumptions<a class="headerlink" href="#general-mechanism-for-interpreting-goals-and-assumptions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id15">
<h4>Specializing assumptions<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>The <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">term1</span><span> … </span><span class="coqdoc-var">termn</span><span>).</span><span>
</span></span></div>
<p>is equivalent to the tactic:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">generalize</span><span> (</span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-var">term1</span><span> … </span><span class="coqdoc-var">termn</span><span>); </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">top</span><span>.</span><span>
</span></span></div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name for introducing the top assumption of the
current goal.</p>
</div>
<div class="section" id="id16">
<h4>Interpreting assumptions<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>The general form of an assumption view tactic is:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>move</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>case</span></span></span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>The term, called the <em>view lemma</em>, can be:</p>
<ul class="simple">
<li><p>a (term coercible to a) function;</p></li>
<li><p>a (possibly quantified) implication;</p></li>
<li><p>a (possibly quantified) double implication;</p></li>
<li><p>a (possibly quantified) instance of the reflect predicate (see
Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).</p></li>
</ul>
<p>Let <code class="docutils literal notranslate"><span class="pre">top</span></code> be the top assumption in the goal.</p>
<p>There are three steps in the behavior of an assumption view tactic.</p>
<ul class="simple">
<li><p>It first introduces <code class="docutils literal notranslate"><span class="pre">top</span></code>.</p></li>
<li><p>If the type of <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is neither a double implication nor an
instance of the reflect predicate, then the tactic automatically
generalises a term of the form <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code>, where the
terms <code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code> instantiate the possible quantified variables of
<code class="docutils literal notranslate"><span class="pre">term</span></code> , in order for <code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">top)</span></code> to be well typed.</p></li>
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an equivalence, or an instance of the
reflect predicate, it generalises a term of the form
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">))</span></code>, where the term <code class="docutils literal notranslate"><span class="pre">termvh</span></code>
inserted is called an
<em>assumption interpretation view hint</em>.</p></li>
<li><p>It finally clears top.</p></li>
</ul>
<p>For a <code class="docutils literal notranslate"><span class="pre">case/term</span></code> tactic, the generalisation step is replaced by a
case analysis step.</p>
<p><em>View hints</em> are declared by the user (see Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) and
stored in the Hint View database. The proof engine automatically
detects from the shape of the top assumption <code class="docutils literal notranslate"><span class="pre">top</span></code> and of the view lemma
<code class="docutils literal notranslate"><span class="pre">term</span></code> provided to the tactic the appropriate view hint in the
database to be inserted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is a double implication, then the view hint will be one of
the defined view hints for implication. These hints are by default the
ones present in the file <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffLR</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>, (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span><span>
</span></span></div>
<p>which transforms a double implication into the left-to-right one, or:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffRL</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>, (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> -&gt; </span><span class="coqdoc-var">P</span><span>.</span><span>
</span></span></div>
<p>which produces the converse implication. In both cases, the two
first <code class="docutils literal notranslate"><span class="pre">Prop</span></code> arguments are implicit.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate, then <code class="docutils literal notranslate"><span class="pre">A</span></code> will be one
of the defined view hints for the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate, which are by
default the ones present in the file <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>. These hints are not
only used for choosing the appropriate direction of the translation,
but they also allow complex transformation, involving negations.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">introN</span><span>.</span><span>
</span></dt><dd><span>introN
     : </span><span class="ansi-bold">forall</span><span> (P : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (b : bool), reflect P b</span><span> -&gt;</span><span> </span><span>~</span><span> P</span><span> -&gt;</span><span> </span><span>~~</span><span> b
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">Ha</span><span> : </span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">Hb</span><span> : </span><span class="coqdoc-var">b</span><span>) : ~~ (</span><span class="coqdoc-var">a</span><span> &amp;&amp; </span><span class="coqdoc-var">b</span><span>).</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  Ha : a
  Hb : b
  ============================
  </span><span>~~</span><span> (a</span><span> &amp;&amp;</span><span> b)
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  Ha : a
  Hb : b
  ============================
  </span><span>~</span><span> (a</span><span> /\</span><span> b)
</span></dd>
</dl>
</div>
<p>In fact, this last script does not
exactly use the hint <code class="docutils literal notranslate"><span class="pre">introN</span></code>, but the more general hint:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">introNTF</span><span>.</span><span>
</span></dt><dd><span>introNTF
     : </span><span class="ansi-bold">forall</span><span> (P : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (b c : bool),
       reflect P b</span><span> -&gt;</span><span> (</span><span class="ansi-bold">if</span><span> c </span><span class="ansi-bold">then</span><span> </span><span>~</span><span> P </span><span class="ansi-bold">else</span><span> P)</span><span> -&gt;</span><span> </span><span>~~</span><span> b</span><span> =</span><span> c
</span></dd>
</dl>
</div>
<p>The lemma <code class="docutils literal notranslate"><span class="pre">introN</span></code> is an instantiation of <code class="docutils literal notranslate"><span class="pre">introNF</span></code> using <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">:=</span> <span class="pre">true</span></code>.</p>
</div>
<p>Note that views, being part of <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, can be used to interpret
assertions too. For example, the following script asserts <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>, but
actually uses its propositional interpretation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">pab</span><span> : </span><span class="coqdoc-var">b</span><span> &amp;&amp; </span><span class="coqdoc-var">a</span><span>) : </span><span class="coqdoc-var">b</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  pab : b</span><span> &amp;&amp;</span><span> a
  ============================
  b
</span></dd>
<dt><span></span><span class="coqdoc-var">have</span><span> /</span><span class="coqdoc-var">andP</span><span> [</span><span class="coqdoc-var">pa</span><span> -&gt;] : (</span><span class="coqdoc-var">a</span><span> &amp;&amp; </span><span class="coqdoc-var">b</span><span>) </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">andbC</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  a, b : bool
  pab : b</span><span> &amp;&amp;</span><span> a
  pa : a
  ============================
  true
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="id17">
<h4>Interpreting goals<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>A goal interpretation view tactic of the form:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>apply/</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>applied to a goal <code class="docutils literal notranslate"><span class="pre">top</span></code> is interpreted in the following way.</p>
<ul class="simple">
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is not an instance of the reflect predicate,
nor an equivalence, then the term <code class="docutils literal notranslate"><span class="pre">term</span></code> is applied to the current
goal <code class="docutils literal notranslate"><span class="pre">top</span></code>, possibly inserting implicit arguments.</p></li>
<li><p>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the reflect predicate or an
equivalence, then a <em>goal interpretation view hint</em> can possibly be
inserted, which corresponds to the application of a term
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_))</span></code> to the current goal, possibly inserting implicit arguments.</p></li>
</ul>
<p>Like assumption interpretation view hints, goal interpretation ones
are user-defined lemmas stored (see Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) in the <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">View</span></code>
database, bridging the possible gap between the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> and the
type of the goal.</p>
</div>
</div>
<div class="section" id="interpreting-equivalences">
<h3>Interpreting equivalences<a class="headerlink" href="#interpreting-equivalences" title="Permalink to this headline">¶</a></h3>
<p>Equivalent boolean propositions are simply <em>equal</em> boolean terms. A
special construction helps the user to prove boolean equalities by
considering them as logical double implications (between their coerced
versions), while performing at the same time logical operations on
both sides.</p>
<p>The syntax of double views is:</p>
<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>apply/</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a><span><span>/</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>The first term is the view lemma applied to the left-hand side of the
equality, while the second term is the one applied to the right-hand side.</p>
<p>In this context, the identity view can be used when no view has to be applied:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">idP</span><span> : </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b1</span><span>.</span><span>
</span></span></div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> </span><span class="coqdoc-var">b3</span><span> : </span><span class="coqdoc-var">bool</span><span>) : ~~ (</span><span class="coqdoc-var">b1</span><span> || </span><span class="coqdoc-var">b2</span><span>) = </span><span class="coqdoc-var">b3</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  b1, b2, b3 : bool
  ============================
  </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)</span><span> =</span><span> b3
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">idP</span><span>/</span><span class="coqdoc-var">idP</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  b1, b2, b3 : bool
  ============================
  </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)</span><span> -&gt;</span><span> b3

goal 2 is:
 b3</span><span> -&gt;</span><span> </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)
</span></dd>
</dl>
</div>
<p>The same goal can be decomposed in several ways, and the user may
choose the most convenient interpretation.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> </span><span class="coqdoc-var">b3</span><span> : </span><span class="coqdoc-var">bool</span><span>) : ~~ (</span><span class="coqdoc-var">b1</span><span> || </span><span class="coqdoc-var">b2</span><span>) = </span><span class="coqdoc-var">b3</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  b1, b2, b3 : bool
  ============================
  </span><span>~~</span><span> (b1 </span><span>|| </span><span>b2)</span><span> =</span><span> b3
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">norP</span><span>/</span><span class="coqdoc-var">idP</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  b1, b2, b3 : bool
  ============================
  </span><span>~~</span><span> b1</span><span> /\</span><span> </span><span>~~</span><span> b2</span><span> -&gt;</span><span> b3

goal 2 is:
 b3</span><span> -&gt;</span><span> </span><span>~~</span><span> b1</span><span> /\</span><span> </span><span>~~</span><span> b2
</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="declaring-new-hint-views">
<span id="declaring-new-hints-ssr"></span><h3>Declaring new Hint Views<a class="headerlink" href="#declaring-new-hint-views" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.Hint-View-for-move">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Hint</span></span> <span><span>View</span></span> <span><span>for</span></span> <span><span>move</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.Hint-View-for-move" title="Permalink to this definition">¶</a></dt>
<dt id="coq:cmd.Hint-View-for-apply">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Hint</span></span> <span><span>View</span></span> <span><span>for</span></span> <span><span>apply</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.Hint-View-for-apply" title="Permalink to this definition">¶</a></dt>
<dd><p>This command can be used to extend the database of hints for the view
mechanism.</p>
<p>As library <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> already declares a
corpus of hints, this feature is probably useful only for users who
define their own logical connectives.</p>
<p>The <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name of the lemma to be
declared as a hint. If <code class="docutils literal notranslate"><span class="pre">move</span></code> is used as
tactic, the hint is declared for assumption interpretation tactics;
<code class="docutils literal notranslate"><span class="pre">apply</span></code> declares hints for goal interpretations. Goal interpretation
view hints are declared for both simple views and left-hand side
views. The optional natural number is the number of implicit
arguments to be considered for the declared hint view lemma.</p>
<dl class="coq cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>Hint</span></span> <span><span>View</span></span> <span><span>for</span></span> <span><span>apply//</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This variant with a double slash <code class="docutils literal notranslate"><span class="pre">//</span></code> declares hint views for
right-hand sides of double views.</p>
<p>See the files <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> for examples.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multiple-views">
<h3>Multiple views<a class="headerlink" href="#multiple-views" title="Permalink to this headline">¶</a></h3>
<p>The hypotheses and the goal can be interpreted by applying multiple views
in sequence. Both <code class="docutils literal notranslate"><span class="pre">move</span></code> and <code class="docutils literal notranslate"><span class="pre">apply</span></code> can be followed by an arbitrary
number of <code class="docutils literal notranslate"><span class="pre">/term</span></code>. The main difference between the following two
tactics</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v1</span><span>/</span><span class="coqdoc-var">v2</span><span>/</span><span class="coqdoc-var">v3</span><span>.</span><span>
</span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v1</span><span>; </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v2</span><span>; </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v3</span><span>.</span><span>
</span></span></div>
<p>is that the former applies all the views to the principal goal.
Applying a view with hypotheses generates new goals, and the second
line would apply the view <code class="docutils literal notranslate"><span class="pre">v2</span></code> to all the goals generated by <code class="docutils literal notranslate"><span class="pre">apply/v1</span></code>.</p>
<p>Note that the NO-OP intro pattern <code class="docutils literal notranslate"><span class="pre">-</span></code> can be used to separate two views,
making the two following examples equivalent:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v1</span><span>; </span><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v2</span><span>.</span><span>
</span><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v1</span><span> - /</span><span class="coqdoc-var">v2</span><span>.</span><span>
</span></span></div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">move</span></code> can be used together with the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical to
pass a given hypothesis to a lemma.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Overwriting previous delimiting key bool in scope bool_scope
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
Q is declared
R is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span><span>
</span></dt><dd><span>P2Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Q2R</span><span> : </span><span class="coqdoc-var">Q</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>.</span><span>
</span></dt><dd><span>Q2R is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">P</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q, R : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : P</span><span> -&gt;</span><span> Q
  Q2R : Q</span><span> -&gt;</span><span> R
  p : P
  ============================
  True
</span></dd>
<dt><span></span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>/</span><span class="coqdoc-var">Q2R</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q, R : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  P2Q : P</span><span> -&gt;</span><span> Q
  Q2R : Q</span><span> -&gt;</span><span> R
  p : R
  ============================
  True
</span></dd>
</dl>
</div>
</div>
<p>If the list of views is of length two, <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> for interpreting
equivalences are indeed taken into account; otherwise only single
<code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> are used.</p>
</div>
</div>
<div class="section" id="synopsis-and-index">
<h2>Synopsis and Index<a class="headerlink" href="#synopsis-and-index" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h3>
<p><span class="smallcaps">SSReflect</span> tactics</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-d_tactic"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-d_tactic"><span class="hole">d_tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>elim</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>case</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>congr</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>apply</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>exact</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>move</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Notation scope</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-key"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-key"><span class="hole">key</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Module name</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-modname"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-modname"><span class="hole">modname</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/modules.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Natural number</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-nat_or_ident"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-nat_or_ident"><span class="hole">nat_or_ident</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>where <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is an Ltac variable denoting a standard Coq number
(should not be the name of a tactic that can be followed by a
bracket <code class="docutils literal notranslate"><span class="pre">[</span></code>, such as <code class="docutils literal notranslate"><span class="pre">do</span></code>, <code class="docutils literal notranslate"><span class="pre">have</span></code>,…)</p>
</div>
<div class="section" id="items-and-switches">
<h3>Items and switches<a class="headerlink" href="#items-and-switches" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-ssr_binder"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>)</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>binder (see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-clear_switch"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> }</span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>clear switch (see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-c_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>in</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span><span>as</span></span></span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>context pattern (see <a class="reference internal" href="#contextual-patterns-ssr"><span class="std std-ref">Contextual patterns</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-d_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span><span>)</span></span></span></span></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>discharge item (see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-gen_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>)</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>&#64;</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span><span>)</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>generalization item (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>&gt;</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>_</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>*</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>+</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span><span>-&gt;</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>&lt;-</span></span></span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>-</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>intro pattern (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>view (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_view"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_view"><span class="hole">i_view</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>{</span></span><span><span>}</span></span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span><span>/</span></span><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/ltac:(</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>)</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>intro block (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-i_block"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-i_block"><span class="hole">i_block</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>[^</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[^~</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>intro item (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-int_mult"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-int_mult"><span class="hole">int_mult</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>multiplier (see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-occ_switch"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>+</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>-</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">*</span></span> }</span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>occur. switch (see <a class="reference internal" href="#occurrence-selection-ssr"><span class="std std-ref">Occurrence selection</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-mult"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>multiplier (see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-mult_mark"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>?</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>!</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>multiplier mark (see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><span><span>/</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>rewrite item (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_prefix"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>-</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-int_mult"><span class="hole">int_mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>[</span></span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span><span>]</span></span></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>rewrite prefix (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_pattern"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>in</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>rewrite pattern (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-r_step"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-r_step"><span class="hole">r_step</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>rewrite step (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-s_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>/=</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>//</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>//=</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>simplify switch (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
</div>
<div class="section" id="tactics">
<h3>Tactics<a class="headerlink" href="#tactics" title="Permalink to this headline">¶</a></h3>
<p><em>Note</em>: <code class="docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code> and <code class="docutils literal notranslate"><span class="pre">suffices</span></code> are synonyms for <code class="docutils literal notranslate"><span class="pre">wlog</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code>,
respectively.</p>
<dl class="coq tacn">
<dt id="id30">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>move</span></span></span></code><a class="headerlink" href="#id30" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ltac.html#coq:tacn.idtac" title="idtac"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">idtac</span></code></a> or <a class="reference internal" href="../proofs/writing-proofs/equality.html#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> (see  <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id31">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>apply</span></span></span></code><a class="headerlink" href="#id31" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.exact-(ssreflect)">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>exact</span></span></span></code><a class="headerlink" href="#coq:tacn.exact-(ssreflect)" title="Permalink to this definition">¶</a></dt>
<dd><p>application (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>abstract:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>(see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a> and <a class="reference internal" href="#generating-let-ssr"><span class="std std-ref">Generating let in context entries with have</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>elim</span></span></span></code></dt>
<dd><p>induction (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>case</span></span></span></code></dt>
<dd><p>case analysis (see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>rewrite</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_step"><span class="hole">r_step</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>rewrite (see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id32">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>under</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>=&gt;</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>do</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#id32" title="Permalink to this definition">¶</a></dt>
<dd><p>under (see <a class="reference internal" href="#under-ssr"><span class="std std-ref">Rewriting under binders</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id33">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>over</span></span></span></code><a class="headerlink" href="#id33" title="Permalink to this definition">¶</a></dt>
<dd><p>over (see <a class="reference internal" href="#over-ssr"><span class="std std-ref">The over tactic</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id34">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#id34" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span></span></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span><span>suff</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>have</span></span> <span><span>suff</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>gen</span></span> <span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>,</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dt id="coq:tacn.generally-have">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>generally</span></span> <span><span>have</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>,</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.generally-have" title="Permalink to this definition">¶</a></dt>
<dd><p>forward chaining (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id35">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>wlog</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>suff</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">*</span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#id35" title="Permalink to this definition">¶</a></dt>
<dd><p>specializing (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="coq:tacn.suff">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>suff</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.suff" title="Permalink to this definition">¶</a></dt>
<dt id="coq:tacn.suffices">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>suffices</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.suffices" title="Permalink to this definition">¶</a></dt>
<dt id="id36">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>suff</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>have</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#id36" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>suffices</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>have</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>by</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>backchaining (see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>pose</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>local definition (see <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a>)</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>pose</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span><span>:=</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>local function definition</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>pose</span></span> <span><span>fix</span></span> <a class="reference internal" href="../language/core/inductive.html#grammar-token-fix_decl"><span class="hole">fix_decl</span></a></span></code></dt>
<dd><p>local fix definition</p>
</dd></dl>

<dl class="coq tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span><span>pose</span></span> <span><span>cofix</span></span> <a class="reference internal" href="../language/core/inductive.html#grammar-token-fix_decl"><span class="hole">fix_decl</span></a></span></code></dt>
<dd><p>local cofix definition</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id37">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>set</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>(</span></span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span><span>)</span></span></span></span></span></code><a class="headerlink" href="#id37" title="Permalink to this definition">¶</a></dt>
<dd><p>abbreviation (see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id38">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>unlock</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#id38" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock (see <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a>)</p>
</dd></dl>

<dl class="coq tacn">
<dt id="id39">
<em class="property"><span class="sigannot">Tactic</span></em> <code class="sig-name descname"><span class="notation"><span><span>congr</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#id39" title="Permalink to this definition">¶</a></dt>
<dd><p>congruence (see <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a>)</p>
</dd></dl>

</div>
<div class="section" id="tacticals">
<h3>Tacticals<a class="headerlink" href="#tacticals" title="Permalink to this headline">¶</a></h3>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-d_tactic"><span class="hole">d_tactic</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span><span>:</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>discharge (see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>=&gt;</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>introduction (see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>in</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>*</span></span></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>localization (see <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>do</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>iteration (see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>;</span></span> <span class="alternative"><span class="alternative-block"><span><span>first</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>last</span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>selector (see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>;</span></span> <span class="alternative"><span class="alternative-block"><span><span>first</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>last</span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>rotation (see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>)</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">+=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>by</span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>closing (see <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>)</p>
</div>
<div class="section" id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt id="coq:cmd.Hint-View-for">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Hint</span></span> <span><span>View</span></span> <span><span>for</span></span> <span class="alternative"><span class="alternative-block"><span><span>move</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>apply</span></span></span></span> <span><span>/</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat">| <a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.Hint-View-for" title="Permalink to this definition">¶</a></dt>
<dd><p>view hint declaration (see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a>)</p>
</dd></dl>

<dl class="coq cmd">
<dt id="id40">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Hint</span></span> <span><span>View</span></span> <span><span>for</span></span> <span><span>apply</span></span> <span><span>//</span></span> <a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#id40" title="Permalink to this definition">¶</a></dt>
<dd><p>right hand side double , view hint declaration (see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a>)</p>
</dd></dl>

<dl class="coq cmd">
<dt id="id41">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span><span>Prenex</span></span> <span><span>Implicits</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/core/basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#id41" title="Permalink to this definition">¶</a></dt>
<dd><p>prenex implicits declaration (see <a class="reference internal" href="#parametric-polymorphism-ssr"><span class="std std-ref">Parametric polymorphism</span></a>)</p>
</dd></dl>

</div>
<div class="section" id="settings">
<h3>Settings<a class="headerlink" href="#settings" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt id="coq:flag.Debug-Ssreflect">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Debug</span></span> <span><span>Ssreflect</span></span></span></code><a class="headerlink" href="#coq:flag.Debug-Ssreflect" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Developer only.</em> Print debug information on reflect.</p>
</dd></dl>

<dl class="coq flag">
<dt id="coq:flag.Debug-SsrMatching">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span><span>Debug</span></span> <span><span>SsrMatching</span></span></span></code><a class="headerlink" href="#coq:flag.Debug-SsrMatching" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Developer only.</em> Print debug information on SSR matching.</p>
</dd></dl>

<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id42"><span class="brackets"><a class="fn-backref" href="#id1">11</a></span></dt>
<dd><p>Unfortunately, even after a call to the <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command,
some occurrences are still not displayed to the user, essentially the
ones possibly hidden in the predicate of a dependent match structure.</p>
</dd>
<dt class="label" id="id43"><span class="brackets"><a class="fn-backref" href="#id2">12</a></span></dt>
<dd><p>Thus scripts that depend on bound variable names, e.g., via intros
or with, are inherently fragile.</p>
</dd>
<dt class="label" id="id44"><span class="brackets"><a class="fn-backref" href="#id3">13</a></span></dt>
<dd><p>The name <code class="docutils literal notranslate"><span class="pre">subnK</span></code> reads as “right cancellation rule for <code class="docutils literal notranslate"><span class="pre">nat</span></code>
subtraction”.</p>
</dd>
<dt class="label" id="id45"><span class="brackets"><a class="fn-backref" href="#id4">14</a></span></dt>
<dd><p>Also, a slightly different variant may be used for the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
of <code class="docutils literal notranslate"><span class="pre">case</span></code> and <code class="docutils literal notranslate"><span class="pre">elim</span></code>; see Section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.</p>
</dd>
<dt class="label" id="id46"><span class="brackets"><a class="fn-backref" href="#id5">15</a></span></dt>
<dd><p>Except that <code class="docutils literal notranslate"><span class="pre">/=</span></code> does not expand the local definitions created by the
<span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical.</p>
</dd>
<dt class="label" id="id47"><span class="brackets"><a class="fn-backref" href="#id8">16</a></span></dt>
<dd><p><span class="smallcaps">SSReflect</span> reserves all identifiers of the form “_x_”, which is
used for such generated names.</p>
</dd>
<dt class="label" id="id48"><span class="brackets"><a class="fn-backref" href="#id9">17</a></span></dt>
<dd><p>More precisely, it should have a quantified inductive type with a
assumptions and m − a constructors.</p>
</dd>
<dt class="label" id="id49"><span class="brackets"><a class="fn-backref" href="#id14">18</a></span></dt>
<dd><p>This is an implementation feature: there is no such obstruction
in the metatheory.</p>
</dd>
<dt class="label" id="id50"><span class="brackets"><a class="fn-backref" href="#id10">19</a></span></dt>
<dd><p>The current state of the proof shall be displayed by the <code class="docutils literal notranslate"><span class="pre">Show</span>
<span class="pre">Proof</span></code> command of Coq proof mode.</p>
</dd>
<dt class="label" id="id51"><span class="brackets">20</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>,<a href="#id13">3</a>)</span></dt>
<dd><p>A simple proof context entry is a naked identifier (i.e., not between
parentheses) designating a context entry that is not a section variable.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../proofs/automatic-tactics/index.html" class="btn btn-neutral float-right" title="Automatic solvers and programmable tactics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../proofs/writing-proofs/reasoning-inductives.html" class="btn btn-neutral float-left" title="Reasoning with inductive types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2021, Inria, CNRS and contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  




  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Other versions</span>
      v: 8.17.1
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://coq.github.io/doc/master/refman/">dev</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/current/refman/">stable</a></dd>
        
          <dd><a href="https://coq.github.io/doc/v8.17/refman/">8.17</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.16.1/refman/">8.16</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.15.2/refman/">8.15</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.14.1/refman/">8.14</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.13.2/refman/">8.13</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.12.2/refman/">8.12</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.11.2/refman/">8.11</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.10.2/refman/">8.10</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.9.1/refman/">8.9</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.8.2/refman/">8.8</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.7.2/refman/">8.7</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.6.1/refman/">8.6</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.5pl3/refman/">8.5</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.4pl6/refman/">8.4</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.3pl5/refman/">8.3</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.2pl3/refman/">8.2</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.1pl6/refman/">8.1</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.0/doc/">8.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://github.com/coq/coq/releases/download/V8.17.1/coq-8.17.1-reference-manual.pdf">PDF</a></dd>
        
      </dl>
    </div>
  </div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>