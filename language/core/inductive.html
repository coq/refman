<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Inductive types and recursive functions &mdash; Coq 8.18.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/ansi.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/coqdoc.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/notations.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/pre-text.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/notations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Coinductive types and corecursive functions" href="coinductive.html" />
    <link rel="prev" title="Record types" href="records.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Coq
          </a>
              <div class="version">
                8.18.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Specification language</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basic.html">Basic notions and conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="basic.html#syntax-and-lexical-conventions">Syntax and lexical conventions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="basic.html#syntax-conventions">Syntax conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="basic.html#lexical-conventions">Lexical conventions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="basic.html#essential-vocabulary">Essential vocabulary</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic.html#settings">Settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="basic.html#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="basic.html#flags-options-and-tables">Flags, Options and Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sorts.html">Sorts</a></li>
<li class="toctree-l2"><a class="reference internal" href="assumptions.html">Functions and assumptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="assumptions.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="assumptions.html#functions-fun-and-function-types-forall">Functions (fun) and function types (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="assumptions.html#function-application">Function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="assumptions.html#assumptions">Assumptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="definitions.html">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="definitions.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="definitions.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="definitions.html#top-level-definitions">Top-level definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="definitions.html#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#conversion">α-conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#delta-reduction-sect">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#id4">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#id7">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversion.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cic.html">Typing rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../cic.html#the-terms">The terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cic.html#id6">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="variants.html">Variants and the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct</a><ul>
<li class="toctree-l3"><a class="reference internal" href="variants.html#id1">Variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="variants.html#private-matching-inductive-types">Private (matching) inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="variants.html#definition-by-cases-match">Definition by cases: match</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="records.html#defining-record-types">Defining record types</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html#constructing-records">Constructing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html#accessing-fields-projections">Accessing fields (projections)</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html#settings-for-printing-records">Settings for printing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="records.html#compatibility-constants-for-projections">Compatibility Constants for Projections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Inductive types and recursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inductive-types">Inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-indexed-inductive-types">Simple indexed inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-functions-fix">Recursive functions: fix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-level-recursive-functions">Top-level recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#theory-of-inductive-definitions">Theory of inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coinductive.html">Coinductive types and corecursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="coinductive.html#coinductive-types">Coinductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="coinductive.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="coinductive.html#co-recursive-functions-cofix">Co-recursive functions: cofix</a></li>
<li class="toctree-l3"><a class="reference internal" href="coinductive.html#top-level-definitions-of-corecursive-functions">Top-level definitions of corecursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sections.html">Sections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sections.html#typing-rules-used-at-the-end-of-a-section">Typing rules used at the end of a section</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modules.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#using-modules">Using modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="modules.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#typing-modules">Typing Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#controlling-the-scope-of-commands-with-locality-attributes">Controlling the scope of commands with locality attributes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="primitive.html">Primitive objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="primitive.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="primitive.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="primitive.html#primitive-arrays">Primitive Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#specifying-cumulativity">Specifying cumulativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#printing-universes">Printing universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#definitional-uip">Definitional UIP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/sprop.html#non-termination-with-uip">Non Termination with UIP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#lack-of-tactic-support">Lack of tactic support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../extensions/evars.html">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../extensions/evars.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/evars.html#e-tactics-that-can-create-existential-variables">e* tactics that can create existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/evars.html#automatic-resolution-of-existential-variables">Automatic resolution of existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/evars.html#explicit-display-of-existential-instances-for-pretty-printing">Explicit display of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/evars.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments">Maximal and non-maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../extensions/match.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#conventions-about-unused-pattern-matching-variables">Conventions about unused pattern-matching variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../extensions/match.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/match.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user-extensions/syntax-extensions.html">Syntax extensions and notation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#use-of-notations-for-printing">Use of notations for printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#enabling-and-disabling-notations">Enabling and disabling notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#syntax">Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notation-scopes">Notation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-type-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-function-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notation-scopes-used-in-the-standard-library-of-coq">Notation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#numbers-and-strings">Numbers and strings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#number-notations">Number notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../extensions/arguments-command.html">Setting properties of a function's arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#manual-declaration-of-implicit-arguments">Manual declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#binding-arguments-to-scopes">Binding arguments to scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#effects-of-arguments-on-unfolding">Effects of <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code> on unfolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/arguments-command.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercion-classes">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#id1">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#reversible-coercions">Reversible Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#id2">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#typeclass-and-instance-declarations">Typeclass and instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#binding-typeclasses">Binding typeclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#parameterized-instances">Parameterized instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#command-summary">Command summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../extensions/canonical.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../extensions/canonical.html#declaration-of-canonical-structures">Declaration of canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/canonical.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/canonical.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../extensions/canonical.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../extensions/canonical.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/vernacular-commands.html">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#load-paths">Load paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#extra-dependencies">Extra Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Proofs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../proofs/writing-proofs/index.html">Basic proof writing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html">Proof mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proof-state">Proof State</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#entering-and-exiting-proof-mode">Entering and exiting proof mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proof-modes">Proof modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#managing-goals">Managing goals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#focusing-goals">Focusing goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#shelving-goals">Shelving goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#reordering-goals">Reordering goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proving-a-subgoal-as-a-separate-lemma-abstract">Proving a subgoal as a separate lemma: abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#how-diffs-are-calculated">How diffs are calculated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#show-proof-differences">&quot;Show Proof&quot; differences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#controlling-proof-mode">Controlling proof mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#reserved-keywords">Reserved keywords</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#occurrence-clauses">Occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proofs/writing-proofs/equality.html">Reasoning with equalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#tactics-for-simple-equalities">Tactics for simple equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#rewriting-with-leibniz-and-setoid-equality">Rewriting with Leibniz and setoid equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#rewriting-with-definitional-equality">Rewriting with definitional equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#applying-conversion-rules">Applying conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#fast-reduction-tactics-vm-compute-and-native-compute">Fast reduction tactics: vm_compute and native_compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#computing-in-a-term-eval-and-eval">Computing in a term: eval and Eval</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/equality.html#controlling-reduction-strategies-and-the-conversion-algorithm">Controlling reduction strategies and the conversion algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html">Reasoning with inductive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#applying-constructors">Applying constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#case-analysis">Case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#induction">Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#equality-of-inductive-types">Equality of inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#helper-tactics">Helper tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#examples-of-dependent-destruction-dependent-induction">Examples of <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> / <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#a-larger-example">A larger example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#gallina-extensions">Gallina extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../proofs/automatic-tactics/index.html">Automatic solvers and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../proofs/automatic-tactics/logic.html">Solvers for logic and equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/micromega.html">Micromega: solvers for arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/ring.html">ring and field: solvers for polynomial and rational equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/nsatz.html">Nsatz: a solver for equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html">Programmable proof search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#hint-databases">Hint databases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#creating-hint-databases">Creating hint databases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#creating-hints">Creating Hints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#hint-locality">Hint locality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proofs/automatic-tactics/auto.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations">Rewriting and nonreflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-and-nonsymmetric-relations">Rewriting and nonsymmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-with-type-valued-relations">Rewriting with <code class="docutils literal notranslate"><span class="pre">Type</span></code> valued relations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#declaring-rewrite-relations">Declaring rewrite relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#usage">Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../proofs/creating-tactics/index.html">Creating new tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ltac.html">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#values">Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#syntactic-values">Syntactic values</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#substitution">Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#local-definitions-let">Local definitions: let</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#function-construction-and-application">Function construction and application</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#tactics-in-terms">Tactics in terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#processing-multiple-goals">Processing multiple goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#branching-and-backtracking">Branching and backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#sequence">Sequence: ;</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#do-loop">Do loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#catching-errors-try">Catching errors: try</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#conditional-branching-tryif">Conditional branching: tryif</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#branching-with-backtracking">Branching with backtracking: +</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics: [&gt; ... ]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#first-tactic-to-succeed">First tactic to succeed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#first-tactic-to-make-progress">First tactic to make progress: ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#success-and-failure">Success and failure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-success-assert-succeeds">Checking for success: assert_succeeds</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-failure-assert-fails">Checking for failure: assert_fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#soft-cut-once">Soft cut: once</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-a-single-success-exactly-once">Checking for a single success: exactly_once</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#manipulating-values">Manipulating values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#pattern-matching-on-terms-match">Pattern matching on terms: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#pattern-matching-on-goals-and-hypotheses-match-goal">Pattern matching on goals and hypotheses: match goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#computing-in-a-term-eval">Computing in a term: eval</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#getting-the-type-of-a-term">Getting the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#manipulating-untyped-terms-type-term">Manipulating untyped terms: type_term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#counting-goals-numgoals">Counting goals: numgoals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#testing-boolean-expressions-guard">Testing boolean expressions: guard</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-properties-of-terms">Checking properties of terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#timing">Timing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term-time-constr">Timing a tactic that evaluates to a term: time_constr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#print-identity-tactic-idtac">Print/identity tactic: idtac</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#defining-ltac-symbols">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#tracing-execution">Tracing execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac2-definitions">Ltac2 Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#printing-ltac2-tactics">Printing Ltac2 tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#quotations">Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-over-goals">Match over goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-on-values">Match on values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#defining-tactics">Defining tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#syntactic-classes">Syntactic classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../coq-library.html">The Coq library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../coq-library.html#the-prelude">The prelude</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between Coq and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/libraries/writing.html">Writing Coq libraries and plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/writing.html#deprecating-library-objects-or-tactics">Deprecating library objects or tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/utilities.html">Building Coq Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#coq-configuration-basics">Coq configuration basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#installing-coq-and-coq-packages-with-opam">Installing Coq and Coq packages with opam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#setup-for-working-on-your-own-projects">Setup for working on your own projects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-project-with-coqproject-overview">Building a project with _CoqProject (overview)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#logical-paths-and-the-load-path">Logical paths and the load path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#modifying-multiple-interdependent-projects-at-the-same-time">Modifying multiple interdependent projects at the same time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#installed-and-uninstalled-packages">Installed and uninstalled packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#upgrading-to-a-new-version-of-coq">Upgrading to a new version of Coq</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile-details">Building a Coq project with coq_makefile (details)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a Coq project with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#coqdep-computing-module-dependencies">coqdep: Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#split-compilation-of-native-computation-files">Split compilation of native computation files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/coq-commands.html">Coq commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#command-parameters">Command parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#coqrc-start-up-script"><code class="docutils literal notranslate"><span class="pre">coqrc</span></code> start up script</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#environment-variables">Environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/tools/coqdoc.html">Documenting Coq files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#coq-material-inside-documentation">Coq material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/coqide.html">CoqIDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#running-coq-scripts">Running Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#asynchronous-mode">Asynchronous mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#commands-and-templates">Commands and templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#customizations">Customizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#preferences">Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#key-bindings">Key bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#debugger">Debugger</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#breakpoints">Breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#call-stack-and-variables">Call Stack and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#supported-use-cases">Supported use cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#id3">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-18">Version 8.18</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-18-0">Changes in 8.18.0</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-17">Version 8.17</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id141">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-17-0">Changes in 8.17.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-17-1">Changes in 8.17.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-16">Version 8.16</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id295">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-16-0">Changes in 8.16.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-16-1">Changes in 8.16.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-15">Version 8.15</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id458">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-0">Changes in 8.15.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-1">Changes in 8.15.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-2">Changes in 8.15.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-14">Version 8.14</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id686">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-14-0">Changes in 8.14.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-14-1">Changes in 8.14.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-13">Version 8.13</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id882">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-beta1">Changes in 8.13+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-0">Changes in 8.13.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-1">Changes in 8.13.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-2">Changes in 8.13.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-12">Version 8.12</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1046">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-beta1">Changes in 8.12+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-0">Changes in 8.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-1">Changes in 8.12.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-2">Changes in 8.12.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1352">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-2">Changes in 8.11.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1490">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1637">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1639">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1640">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1641">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1642">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1643">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1644">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1646">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1647">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1648">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1649">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1650">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1651">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-attrindex.html">Attribute index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../genindex.html">General index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zebibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Coq</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Core language</a> &raquo;</li>
      <li>Inductive types and recursive functions</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/core/inductive.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<section id="inductive-types-and-recursive-functions">
<h1>Inductive types and recursive functions<a class="headerlink" href="#inductive-types-and-recursive-functions" title="Permalink to this headline">¶</a></h1>
<section id="inductive-types">
<span id="gallina-inductive-definitions"></span><h2>Inductive types<a class="headerlink" href="#inductive-types" title="Permalink to this headline">¶</a></h2>
<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Inductive">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Inductive</span></span></span> <a class="reference internal" href="#grammar-token-inductive_definition"><span class="hole"><span class="pre">inductive_definition</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-inductive_definition"><span class="hole"><span class="pre">inductive_definition</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Inductive" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Inductive</span></span></span> <a class="reference internal" href="records.html#grammar-token-record_definition"><span class="hole"><span class="pre">record_definition</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="records.html#grammar-token-record_definition"><span class="hole"><span class="pre">record_definition</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-inductive_definition"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-inductive_definition"><span class="hole">inductive_definition</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../addendum/universe-polymorphism.html#grammar-token-cumul_univ_decl"><span class="hole">cumul_univ_decl</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>|</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-constructor"><span class="hole">constructor</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#grammar-token-decl_notations"><span class="hole">decl_notations</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-constructor"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-constructor"><span class="hole">constructor</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span>#[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="basic.html#grammar-token-attribute"><span class="hole">attribute</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>]</span></span></span><span class="notation-sup">*</span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="records.html#grammar-token-of_type_inst"><span class="hole">of_type_inst</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Defines one or more
inductive types and its constructors.  Coq generates
<span class="term-defn"><span class="target" id="term-induction-principle"></span>induction principles</span>
depending on the universe that the inductive type belongs to.</p>
<p>The induction principles are named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_rect</span></code>, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_ind</span></code>,
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_sind</span></code>, which
respectively correspond to
on <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">SProp</span></span></code>.  Their types
expresses structural induction/recursion principles over objects of
type <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.  The <a class="reference internal" href="definitions.html#term-constant"><span class="xref std std-term">constant</span></a> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_ind</span></code> is always
generated, whereas <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><code class="docutils literal notranslate"><span class="pre">_rect</span></code>
may be impossible to derive (for example, when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a
proposition).</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">|</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="notation"><span class="pre">|</span></span></code> separates uniform and non uniform parameters.
See <a class="reference internal" href="#coq:flag.Uniform-Inductive-Parameters" title="Uniform Inductive Parameters"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Uniform</span> <span class="pre">Inductive</span> <span class="pre">Parameters</span></code></a>.</p>
</dd>
</dl>
<p>The <a class="reference internal" href="#coq:cmd.Inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> command supports the <a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:attr.universes(polymorphic)" title="universes(polymorphic)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></a>,
<a class="reference internal" href="#coq:attr.universes(template)" title="universes(template)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(template)</span></code></a>, <a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:attr.universes(cumulative)" title="universes(cumulative)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(cumulative)</span></code></a>,
<a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:attr.bypass_check(positivity)" title="bypass_check(positivity)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">bypass_check(positivity)</span></code></a>, <a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:attr.bypass_check(universes)" title="bypass_check(universes)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">bypass_check(universes)</span></code></a> and
<a class="reference internal" href="variants.html#coq:attr.private(matching)" title="private(matching)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">private(matching)</span></code></a> attributes.</p>
<p>When record syntax is used, this command also supports the
<a class="reference internal" href="records.html#coq:attr.projections(primitive)" title="projections(primitive)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">projections(primitive)</span></code></a> <a class="reference internal" href="basic.html#term-attribute"><span class="xref std std-term">attribute</span></a>. Also, in the
record syntax, if given, the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> part specifies the name
to use for inhabitants of the record in the type of projections.</p>
<p>Mutually inductive types can be defined by including multiple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-inductive_definition"><span class="hole"><span class="pre">inductive_definition</span></span></a></span></code>s.
The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s are simultaneously added to the global environment before
the types of constructors are checked.  Each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> can be used
independently thereafter.  However, the induction principles currently generated for
such types are not useful.  Use the <a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#coq:cmd.Scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> command to generate useful
induction principles.  See <a class="reference internal" href="#mutually-inductive-types"><span class="std std-ref">Mutually defined inductive types</span></a>.</p>
<p>If the entire inductive definition is parameterized with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span></code>s, those
<span class="term-defn"><span class="target" id="term-inductive-parameter"></span>inductive parameters</span> correspond
to a local context in which the entire set of inductive declarations is interpreted.
For this reason, the parameters must be strictly the same for each inductive type.
See <a class="reference internal" href="#parametrized-inductive-types"><span class="std std-ref">Parameterized inductive types</span></a>.</p>
<p>Constructor <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s can come with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span></code>s, in which case
the actual type of the constructor is <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Non-strictly-positive-occurrence-of-‘ident’-in-‘type’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Non</span></span></span> <span><span><span class="pre">strictly</span></span></span> <span><span><span class="pre">positive</span></span></span> <span><span><span class="pre">occurrence</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Non-strictly-positive-occurrence-of-‘ident’-in-‘type’" title="Permalink to this definition">¶</a></dt>
<dd><p>The types of the constructors have to satisfy a <em>positivity
condition</em> (see Section <a class="reference internal" href="#positivity"><span class="std std-ref">Positivity Condition</span></a>). This condition
ensures the soundness of the inductive definition.
Positivity checking can be disabled using the <a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:flag.Positivity-Checking" title="Positivity Checking"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Positivity</span>
<span class="pre">Checking</span></code></a> flag or the <a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:attr.bypass_check(positivity)" title="bypass_check(positivity)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">bypass_check(positivity)</span></code></a> attribute (see
<a class="reference internal" href="../../proof-engine/vernacular-commands.html#controlling-typing-flags"><span class="std std-ref">Controlling Typing Flags</span></a>).</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.The-conclusion-of-‘type’-is-not-valid;-it-must-be-built-from-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">The</span></span></span> <span><span><span class="pre">conclusion</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">valid;</span></span></span> <span><span><span class="pre">it</span></span></span> <span><span><span class="pre">must</span></span></span> <span><span><span class="pre">be</span></span></span> <span><span><span class="pre">built</span></span></span> <span><span><span class="pre">from</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.The-conclusion-of-‘type’-is-not-valid;-it-must-be-built-from-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd><p>The conclusion of the type of the constructors must be the inductive type
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> being defined (or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> applied to arguments in
the case of indexed inductive types — cf. next section).</p>
</dd></dl>

</dd></dl>

<p>The following subsections show examples of simple inductive types,
simple indexed inductive types, simple parametric inductive types,
mutually inductive types and private (matching) inductive types.</p>
<section id="simple-inductive-types">
<span id="id1"></span><h3>Simple inductive types<a class="headerlink" href="#simple-inductive-types" title="Permalink to this headline">¶</a></h3>
<p>A simple inductive type belongs to a universe that is a simple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="sorts.html#grammar-token-sort"><span class="hole"><span class="pre">sort</span></span></a></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The set of natural numbers is defined as:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">O</span><span> : </span><span class="coqdoc-var">nat</span><span>
| </span><span class="coqdoc-var">S</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd><span>nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
nat_sind is defined
</span></dd>
</dl>
</div>
<p>The type nat is defined as the least <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code> containing <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and closed by
the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> constructor. The names <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> are added to the
global environment.</p>
<p>This definition generates four <a class="reference internal" href="#term-induction-principle"><span class="xref std std-term">induction principles</span></a>:
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_sind</span></span></code>. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span><span>
</span></dt><dd><span>nat_ind
     : </span><span class="ansi-bold">forall</span><span> P : nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       P O</span><span> -&gt;</span><span> (</span><span class="ansi-bold">forall</span><span> n : nat, P n</span><span> -&gt;</span><span> P (S n))</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : nat, P n
</span></dd>
</dl>
</div>
<p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle. It
allows proving universal properties of natural numbers (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span>
<span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>) by induction on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>.</p>
<p>The types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_sind</span></span></code> are similar, except that they
apply to, respectively, <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">)</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">SProp</span></span><span class="operator"><span class="pre">)</span></span></code>. They correspond to
primitive induction principles (allowing dependent types) respectively
over sorts <code class="docutils literal notranslate"><span class="pre">Type</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">SProp</span></code>.</p>
</div>
<p>In the case where inductive types don't have indices (the next section
gives an example of indices), a constructor can be defined
by giving the type of its arguments alone.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">O</span><span> | </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">nat</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
nat_sind is defined
</span></dd>
</dl>
</div>
</div>
</section>
<section id="simple-indexed-inductive-types">
<h3>Simple indexed inductive types<a class="headerlink" href="#simple-indexed-inductive-types" title="Permalink to this headline">¶</a></h3>
<p>In indexed inductive types, the universe where the inductive type
is defined is no longer a simple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="sorts.html#grammar-token-sort"><span class="hole"><span class="pre">sort</span></span></a></span></code>, but what is called an arity,
which is a type whose conclusion is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="sorts.html#grammar-token-sort"><span class="hole"><span class="pre">sort</span></span></a></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>As an example of indexed inductive types, let us define the
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> predicate:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_0</span><span> : </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">even_SS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span><span>
</span></dt><dd><span>even is defined
even_ind is defined
even_sind is defined
</span></dd>
</dl>
</div>
<p>The type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> means that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> is a unary predicate (inductively
defined) over natural numbers. The type of its two constructors are the
defining clauses of the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">even_ind</span><span>.</span><span>
</span></dt><dd><span>even_ind
     : </span><span class="ansi-bold">forall</span><span> P : nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       P O</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> n : nat, even n</span><span> -&gt;</span><span> P n</span><span> -&gt;</span><span> P (S (S n)))</span><span> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> n : nat, even n</span><span> -&gt;</span><span> P n
</span></dd>
</dl>
</div>
<p>From a mathematical point of view, this asserts that the natural numbers satisfying
the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> are exactly in the smallest set of naturals satisfying the
clauses <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_0</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_SS</span></span></code>. This is why, when we want to prove any
predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> over elements of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>, it is enough to prove it for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>
and to prove that if any natural number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> satisfies <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> its double
successor <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">))</span></span></code> satisfies also <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. This is analogous to the
structural induction principle we got for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
</div>
</section>
<section id="parameterized-inductive-types">
<span id="parametrized-inductive-types"></span><h3>Parameterized inductive types<a class="headerlink" href="#parameterized-inductive-types" title="Permalink to this headline">¶</a></h3>
<p>In the previous example, each constructor introduces a different
instance of the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. In some cases, all the constructors
introduce the same generic instance of the inductive definition, in
which case, instead of an index, we use a context of parameters
which are <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span></code>s shared by all the constructors of the definition.</p>
<p>Parameters differ from inductive type indices in that the
conclusion of each type of constructor invokes the inductive type with
the same parameter values of its specification.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>A typical example is the definition of polymorphic lists:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined
</span></dd>
</dl>
</div>
<p>In the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>, we write &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span></code>&quot; and not
just &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span></code>&quot;. The constructors <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> have these types:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nil</span><span>.</span><span>
</span></dt><dd><span>nil
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, list A
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">cons</span><span>.</span><span>
</span></dt><dd><span>cons
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, A</span><span> -&gt;</span><span> list A</span><span> -&gt;</span><span> list A
</span></dd>
</dl>
</div>
<p>Observe that the induction principles are also quantified with <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code>,
for example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">list_ind</span><span>.</span><span>
</span></dt><dd><span>list_ind
     : </span><span class="ansi-bold">forall</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) (P : list A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>),
       P (nil A)</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> (a : A) (l : list A), P l</span><span> -&gt;</span><span> P (cons A a l))</span><span> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> l : list A, P l
</span></dd>
</dl>
</div>
<p>Once again, the names of the constructor arguments and the type of the conclusion can be omitted:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">list</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>The constructor type can
recursively invoke the inductive definition on an argument which is not
the parameter itself.</p>
<p>One can define :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil2</span><span> : </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons2</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd><span>list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined
list2_sind is defined
</span></dd>
</dl>
</div>
<p>that can also be written by specifying only the type of the arguments:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil2</span><span>
| </span><span class="coqdoc-var">cons2</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)).</span><span>
</span></dt><dd><span>list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined
list2_sind is defined
</span></dd>
</dl>
</div>
<p>But the following definition will give an error:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nilw</span><span> : </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)</span><span>
| </span><span class="coqdoc-var">consw</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd><span>The command has indeed failed with message:
In environment
listw : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
Unable to unify &quot;listw (A</span><span> *</span><span> A)%type&quot; with &quot;listw A&quot;.
</span></dd>
</dl>
</div>
<p>because the conclusion of the type of constructors should be <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listw</span></span> <span class="name"><span class="pre">A</span></span></code>
in both cases.</p>
</li>
<li><p>A parameterized inductive definition can be defined using indices
instead of parameters but it will sometimes give a different (bigger)
sort for the inductive definition and will produce a less convenient
rule for case elimination.</p></li>
</ul>
</div>
<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Uniform-Inductive-Parameters">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Uniform</span></span></span> <span><span><span class="pre">Inductive</span></span></span> <span><span><span class="pre">Parameters</span></span></span></span></span><a class="headerlink" href="#coq:flag.Uniform-Inductive-Parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>When this <a class="reference internal" href="basic.html#term-flag"><span class="xref std std-term">flag</span></a> is set (it is off by default),
inductive definitions are abstracted over their parameters
before type checking constructors, allowing to write:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Uniform</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-keyword">Parameters</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list3</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil3</span><span> : </span><span class="coqdoc-var">list3</span><span>
| </span><span class="coqdoc-var">cons3</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span>.</span><span>
</span></dt><dd><span>list3 is defined
list3_rect is defined
list3_ind is defined
list3_rec is defined
list3_sind is defined
</span></dd>
</dl>
</div>
<p>This behavior is essentially equivalent to starting a new section
and using <a class="reference internal" href="sections.html#coq:cmd.Context" title="Context"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Context</span></code></a> to give the uniform parameters, like so
(cf. <a class="reference internal" href="sections.html#section-mechanism"><span class="std std-ref">Sections</span></a>):</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">list3</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Context</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>).</span><span>
</span></dt><dd><span>A is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list3</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil3</span><span> : </span><span class="coqdoc-var">list3</span><span>
| </span><span class="coqdoc-var">cons3</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span> -&gt; </span><span class="coqdoc-var">list3</span><span>.</span><span>
</span></dt><dd><span>list3 is defined
list3_rect is defined
list3_ind is defined
list3_rec is defined
list3_sind is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">list3</span><span>.</span><span>
</span></dt></dl>
</div>
<p>For finer control, you can use a <code class="docutils literal notranslate"><span class="pre">|</span></code> between the uniform and
the non-uniform parameters:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Acc</span><span> {</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>} (</span><span class="coqdoc-var">R</span><span>:</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) | (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span>
  := </span><span class="coqdoc-var">Acc_in</span><span> : (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span> -&gt; </span><span class="coqdoc-var">Acc</span><span> </span><span class="coqdoc-var">y</span><span>) -&gt; </span><span class="coqdoc-var">Acc</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Acc is defined
Acc_rect is defined
Acc_ind is defined
Acc_rec is defined
Acc_sind is defined
</span></dd>
</dl>
</div>
<p>The flag can then be seen as deciding whether the <code class="docutils literal notranslate"><span class="pre">|</span></code> is at the
beginning (when the flag is unset) or at the end (when it is set)
of the parameters when not explicitly given.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Section <a class="reference internal" href="#inductive-definitions"><span class="std std-ref">Theory of inductive definitions</span></a> and the <a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic.</p>
</div>
</section>
<section id="mutually-defined-inductive-types">
<span id="mutually-inductive-types"></span><h3>Mutually defined inductive types<a class="headerlink" href="#mutually-defined-inductive-types" title="Permalink to this headline">¶</a></h3>
<p>The induction principles currently generated for mutually defined types are not
useful.  Use the <a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#coq:cmd.Scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> command to generate a useful induction principle.</p>
<div class="admonition note">
<p class="admonition-title">Example: Mutually defined inductive types</p>
<p>A typical example of mutually inductive data types is trees and
forests. We assume two types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> that are given as variables. The types can
be declared like this:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameters</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
B is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
tree_sind is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined
forest_sind is defined
</span></dd>
</dl>
</div>
<p>This declaration automatically generates eight induction principles. They are not the most
general principles, but they correspond to each inductive part seen as a single inductive definition.</p>
<p>To illustrate this point on our example, here are the types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_rec</span><span>.</span><span>
</span></dt><dd><span>tree_rec
     : </span><span class="ansi-bold">forall</span><span> P : tree</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
       (</span><span class="ansi-bold">forall</span><span> (a : A) (f : forest), P (node a f))</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> t : tree, P t
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">forest_rec</span><span>.</span><span>
</span></dt><dd><span>forest_rec
     : </span><span class="ansi-bold">forall</span><span> P : forest</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
       (</span><span class="ansi-bold">forall</span><span> b : B, P (leaf b))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> (t : tree) (f : forest), P f</span><span> -&gt;</span><span> P (cons t f))</span><span> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> f : forest, P f
</span></dd>
</dl>
</div>
<p>Assume we want to parameterize our mutual inductive definitions with the
two type variables <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, the declaration should be
done as follows:</p>
<div class="coqdoc literal-block docutils container">
<span><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></span></div>
<p>Assume we define an inductive definition inside a section
(cf. <a class="reference internal" href="sections.html#section-mechanism"><span class="std std-ref">Sections</span></a>). When the section is closed, the variables
declared in the section and occurring free in the declaration are added as
parameters to the inductive definition.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>A generic command <a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#coq:cmd.Scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> is useful to build automatically various
mutual induction principles.</p>
</div>
</section>
</section>
<section id="recursive-functions-fix">
<span id="index-0"></span><h2>Recursive functions: fix<a class="headerlink" href="#recursive-functions-fix" title="Permalink to this headline">¶</a></h2>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_fix"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_fix"><span class="hole">term_fix</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>let</span></span> <span><span>fix</span></span> <a class="reference internal" href="#grammar-token-fix_decl"><span class="hole">fix_decl</span></a> <span><span>in</span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>fix</span></span> <a class="reference internal" href="#grammar-token-fix_decl"><span class="hole">fix_decl</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span><span>with</span></span> <a class="reference internal" href="#grammar-token-fix_decl"><span class="hole">fix_decl</span></a></span><span class="notation-sup">+</span></span> <span><span>for</span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fix_decl"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fix_decl"><span class="hole">fix_decl</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole">fixannot</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span><span>:=</span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole">term</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fixannot"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole">fixannot</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>struct</span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>}</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>wf</span></span> <a class="reference internal" href="basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a> <span><span>}</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span><span>measure</span></span> <a class="reference internal" href="basic.html#grammar-token-one_term"><span class="hole">one_term</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="basic.html#grammar-token-one_term"><span class="hole">one_term</span></a></span><span class="notation-sup">?</span></span> <span><span>}</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>The expression &quot;<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">with</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">n</span></sub></span></a> <a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span></a> <span><span><span class="pre">for</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code>&quot; denotes the
<span class="math notranslate nohighlight">\(i\)</span>-th component of a block of functions defined by mutual structural
recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command. When
<span class="math notranslate nohighlight">\(n=1\)</span>, the &quot;<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">for</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code>&quot; clause is omitted.</p>
<p>The association of a single fixpoint and a local definition have a special
syntax: <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span></span></code> stands for
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span> <span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">in</span></span></span></span></code>. The same applies for cofixpoints.</p>
<p>Some options of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole"><span class="pre">fixannot</span></span></a></span></code> are only supported in specific constructs.  <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fix</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">let</span></span></span> <span><span><span class="pre">fix</span></span></span></span></code>
only support the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">struct</span></span></span></span></code> option, while <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">wf</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">measure</span></span></span></span></code> are only supported in
commands such as <a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> (with the <a class="reference internal" href="../../addendum/program.html#coq:attr.program" title="program"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">program</span></code></a> attribute) and <a class="reference internal" href="../../using/libraries/funind.html#coq:cmd.Function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a>.</p>
</section>
<section id="top-level-recursive-functions">
<span id="fixpoint"></span><h2>Top-level recursive functions<a class="headerlink" href="#top-level-recursive-functions" title="Permalink to this headline">¶</a></h2>
<p>This section describes the primitive form of definition by recursion over
inductive objects. See the <a class="reference internal" href="../../using/libraries/funind.html#coq:cmd.Function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a> command for more advanced
constructions.</p>
<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Fixpoint">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Fixpoint</span></span></span> <a class="reference internal" href="#grammar-token-fix_definition"><span class="hole"><span class="pre">fix_definition</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="#grammar-token-fix_definition"><span class="hole"><span class="pre">fix_definition</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fix_definition"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fix_definition"><span class="hole">fix_definition</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-ident_decl"><span class="hole">ident_decl</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole">fixannot</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:</span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>:=</span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#grammar-token-decl_notations"><span class="hole">decl_notations</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Allows defining functions by pattern matching over inductive
objects using a fixed point construction. The meaning of this declaration is
to define <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> as a recursive function with arguments specified by
the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span></code>s such that <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> applied to arguments
corresponding to these <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span></code>s has type <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>, and is
equivalent to the expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. The type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is
consequently <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and its value is equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">fun</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>This command accepts the <a class="reference internal" href="../../addendum/program.html#coq:attr.program" title="program"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">program</span></code></a>,
<a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:attr.bypass_check(universes)" title="bypass_check(universes)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">bypass_check(universes)</span></code></a>, and <a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:attr.bypass_check(guard)" title="bypass_check(guard)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">bypass_check(guard)</span></code></a> attributes.</p>
<p>To be accepted, a <a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition has to satisfy syntactical
constraints on a special argument called the decreasing argument. They
are needed to ensure that the <a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition always terminates.
The point of the <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation (see <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole"><span class="pre">fixannot</span></span></a></span></code>) is to
let the user tell the system which argument decreases along the recursive calls.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation may be left implicit, in which case the
system successively tries arguments from left to right until it finds one
that satisfies the decreasing condition.</p>
<p><a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> without the <a class="reference internal" href="../../addendum/program.html#coq:attr.program" title="program"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">program</span></code></a> attribute does not support the
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">wf</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">measure</span></span></span></span></code> clauses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-fixannot"><span class="hole"><span class="pre">fixannot</span></span></a></span></code>. See <a class="reference internal" href="../../addendum/program.html#program-fixpoint"><span class="std std-ref">Program Fixpoint</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span></span></code> clause allows simultaneously defining several mutual fixpoints.
It is especially useful when defining functions over mutually defined
inductive types.  Example: <a class="reference internal" href="#example-mutual-fixpoints"><span class="std std-ref">Mutual Fixpoints</span></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is omitted, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> is required and Coq enters proof mode.
This can be used to define a term incrementally, in particular by relying on the <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> tactic.
In this case, the proof should be terminated with <a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#coq:cmd.Defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a> in order to define a <a class="reference internal" href="definitions.html#term-constant"><span class="xref std std-term">constant</span></a>
for which the computational behavior is relevant.  See <a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#proof-editing-mode"><span class="std std-ref">Entering and exiting proof mode</span></a>.</p>
<p>This command accepts the <a class="reference internal" href="../../proofs/writing-proofs/proof-mode.html#coq:attr.using" title="using"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">using</span></code></a> attribute.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the fixpoint.
Hence an explicit annotation must be used if the leftmost decreasing
argument is not the desired one. Writing explicit annotations can also
speed up type checking of large mutual fixpoints.</p></li>
<li><p>In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>One can define the addition function as :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">add</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>add is defined
add is recursively defined (guarded on 1st argument)
</span></dd>
</dl>
</div>
<p>The match operator matches a value (here <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) with the various
constructors of its (inductive) type. The remaining arguments give the
respective values to be returned, as functions of the parameters of the
corresponding constructor. Thus here when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> we return
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>, and when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">)</span></span></code> we return <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code>.</p>
<p>The match operator is formally described in
Section <a class="reference internal" href="#match-construction"><span class="std std-ref">The match ... with ... end construction</span></a>.
The system recognizes that in the inductive call <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> the first
argument actually decreases because it is a <em>pattern variable</em> coming
from <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="name"><span class="pre">n</span></span> <span class="keyword"><span class="pre">with</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The following definition is not correct and generates an error message:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">wrongplus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">wrongplus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Recursive definition of wrongplus is ill-formed.
In environment
wrongplus : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat
n : nat
m : nat
p : nat
Recursive call to wrongplus has principal argument equal to 
&quot;n&quot; instead of a subterm of &quot;n&quot;.
Recursive definition is:
&quot;</span><span class="ansi-bold">fun</span><span> n m : nat =&gt; </span><span class="ansi-bold">match</span><span> m </span><span class="ansi-bold">with</span><span>
                  | 0 =&gt; n
                  | S p =&gt; S (wrongplus n p)
                  </span><span class="ansi-bold">end</span><span>&quot;.
</span></dd>
</dl>
</div>
<p>because the declared decreasing argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> does not actually
decrease in the recursive call. The function computing the addition over
the second argument should rather be written:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>plus is defined
plus is recursively defined (guarded on 2nd argument)
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The recursive call may not only be on direct subterms of the recursive
variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> but also on a deeper subterm and we can directly write
the function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">mod2</span></span></code> which gives the remainder modulo 2 of a natural
number.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">mod2</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">with</span><span>
         | </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>
         | </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">q</span><span> =&gt; </span><span class="coqdoc-var">mod2</span><span> </span><span class="coqdoc-var">q</span><span>
         </span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>mod2 is defined
mod2 is recursively defined (guarded on 1st argument)
</span></dd>
</dl>
</div>
</div>
</dd></dl>

<blockquote id="example-mutual-fixpoints">
<div><div class="admonition note">
<p class="admonition-title">Example: Mutual fixpoints</p>
<p>The size of trees and forests can be defined the following way:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">tree_size</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">node</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_size</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">leaf</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; 1</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f'</span><span> =&gt; (</span><span class="coqdoc-var">tree_size</span><span> </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>tree_size is defined
forest_size is defined
tree_size, forest_size are recursively defined (guarded respectively on 1st,
1st arguments)
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
</section>
<section id="theory-of-inductive-definitions">
<span id="inductive-definitions"></span><h2>Theory of inductive definitions<a class="headerlink" href="#theory-of-inductive-definitions" title="Permalink to this headline">¶</a></h2>
<p>Formally, we can represent any <em>inductive definition</em> as
<span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Γ_I\)</span> determines the names and types of inductive types;</p></li>
<li><p><span class="math notranslate nohighlight">\(Γ_C\)</span> determines the names and types of constructors of these
inductive types;</p></li>
<li><p><span class="math notranslate nohighlight">\(p\)</span> determines the number of parameters of these inductive types.</p></li>
</ul>
<p>These inductive definitions, together with global assumptions and
global definitions, then form the global environment. Additionally,
for any <span class="math notranslate nohighlight">\(p\)</span> there always exists <span class="math notranslate nohighlight">\(Γ_P =[a_1 :A_1 ;~…;~a_p :A_p ]\)</span> such that
each <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\((t:T)∈Γ_I \cup Γ_C\)</span> can be written as: <span class="math notranslate nohighlight">\(∀Γ_P , T'\)</span> where <span class="math notranslate nohighlight">\(Γ_P\)</span> is
called the <em>context of parameters</em>. Furthermore, we must have that
each <span class="math notranslate nohighlight">\(T\)</span> in <span class="math notranslate nohighlight">\((t:T)∈Γ_I\)</span> can be written as: <span class="math notranslate nohighlight">\(∀Γ_P,∀Γ_{\mathit{Arr}(t)}, S\)</span> where
<span class="math notranslate nohighlight">\(Γ_{\mathit{Arr}(t)}\)</span> is called the <em>Arity</em> of the inductive type <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(S\)</span> is called
the sort of the inductive type <span class="math notranslate nohighlight">\(t\)</span> (not to be confused with <span class="math notranslate nohighlight">\(\Sort\)</span> which is the set of sorts).</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The declaration for parameterized lists is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{1}{[\List:\Set→\Set]}{\left[\begin{array}{rcl}
\Nil &amp; : &amp; ∀ A:\Set,~\List~A \\
\cons &amp; : &amp; ∀ A:\Set,~A→ \List~A→ \List~A
\end{array}
\right]}\end{split}\]</div>
<p>which corresponds to the result of the Coq declaration:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of tree and forest
is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\tree&amp;:&amp;\Set\\\forest&amp;:&amp;\Set\end{array}\right]}
 {\left[\begin{array}{rcl}
          \node &amp;:&amp; \forest → \tree\\
          \emptyf &amp;:&amp; \forest\\
          \consf &amp;:&amp; \tree → \forest → \forest\\
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the Coq declaration:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> : </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">consf</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
tree_sind is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined
forest_sind is defined
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of even and odd is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\even&amp;:&amp;\nat → \Prop \\
                                \odd&amp;:&amp;\nat → \Prop \end{array}\right]}
 {\left[\begin{array}{rcl}
          \evenO &amp;:&amp; \even~0\\
          \evenS &amp;:&amp; ∀ n,~\odd~n → \even~(\nS~n)\\
          \oddS &amp;:&amp; ∀ n,~\even~n → \odd~(\nS~n)
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the Coq declaration:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_O</span><span> : </span><span class="coqdoc-var">even</span><span> 0</span><span>
| </span><span class="coqdoc-var">even_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">odd</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">odd_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">odd</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>even, odd are defined
even_ind is defined
even_sind is defined
odd_ind is defined
odd_sind is defined
</span></dd>
</dl>
</div>
</div>
<section id="types-of-inductive-objects">
<span id="id2"></span><h3>Types of inductive objects<a class="headerlink" href="#types-of-inductive-objects" title="Permalink to this headline">¶</a></h3>
<p>We have to give the type of constants in a global environment <span class="math notranslate nohighlight">\(E\)</span> which
contains an inductive definition.</p>
<dl>
<dt id="inference-Ind">Ind</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(a:A)∈Γ_I%
}{%
E[Γ] ⊢ a : A%
}\]</div>
</dd>
</dl>
<dl>
<dt id="inference-Constr">Constr</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(c:C)∈Γ_C%
}{%
E[Γ] ⊢ c : C%
}\]</div>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Provided that our global environment <span class="math notranslate nohighlight">\(E\)</span> contains inductive definitions we showed before,
these two inference rules above enable us to conclude that:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
E[Γ] ⊢ \even : \nat→\Prop\\
E[Γ] ⊢ \odd : \nat→\Prop\\
E[Γ] ⊢ \evenO : \even~\nO\\
E[Γ] ⊢ \evenS : ∀ n:\nat,~\odd~n → \even~(\nS~n)\\
E[Γ] ⊢ \oddS : ∀ n:\nat,~\even~n → \odd~(\nS~n)
\end{array}\end{split}\]</div>
</div>
</section>
<section id="well-formed-inductive-definitions">
<span id="id3"></span><h3>Well-formed inductive definitions<a class="headerlink" href="#well-formed-inductive-definitions" title="Permalink to this headline">¶</a></h3>
<p>We cannot accept any inductive definition because some of them lead
to inconsistent systems. We restrict ourselves to definitions which
satisfy a syntactic criterion of positivity. Before giving the formal
rules, we need a few definitions:</p>
<section id="arity-of-a-given-sort">
<h4>Arity of a given sort<a class="headerlink" href="#arity-of-a-given-sort" title="Permalink to this headline">¶</a></h4>
<p>A type <span class="math notranslate nohighlight">\(T\)</span> is an <em>arity of sort</em> <span class="math notranslate nohighlight">\(s\)</span> if it converts to the sort <span class="math notranslate nohighlight">\(s\)</span> or to a
product <span class="math notranslate nohighlight">\(∀ x:T,~U\)</span> with <span class="math notranslate nohighlight">\(U\)</span> an arity of sort <span class="math notranslate nohighlight">\(s\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><span class="math notranslate nohighlight">\(A→\Set\)</span> is an arity of sort <span class="math notranslate nohighlight">\(\Set\)</span>. <span class="math notranslate nohighlight">\(∀ A:\Prop,~A→ \Prop\)</span> is an arity of sort
<span class="math notranslate nohighlight">\(\Prop\)</span>.</p>
</div>
</section>
<section id="arity">
<h4>Arity<a class="headerlink" href="#arity" title="Permalink to this headline">¶</a></h4>
<p>A type <span class="math notranslate nohighlight">\(T\)</span> is an <em>arity</em> if there is a <span class="math notranslate nohighlight">\(s∈ \Sort\)</span> such that <span class="math notranslate nohighlight">\(T\)</span> is an arity of
sort <span class="math notranslate nohighlight">\(s\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><span class="math notranslate nohighlight">\(A→ \Set\)</span> and <span class="math notranslate nohighlight">\(∀ A:\Prop,~A→ \Prop\)</span> are arities.</p>
</div>
</section>
<section id="type-of-constructor">
<h4>Type of constructor<a class="headerlink" href="#type-of-constructor" title="Permalink to this headline">¶</a></h4>
<p>We say that <span class="math notranslate nohighlight">\(T\)</span> is a <em>type of constructor of</em> <span class="math notranslate nohighlight">\(I\)</span> in one of the following
two cases:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((I~t_1 … t_q )\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\(∀ x:U,~T'\)</span> where <span class="math notranslate nohighlight">\(T'\)</span> is also a type of constructor of <span class="math notranslate nohighlight">\(I\)</span></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p><span class="math notranslate nohighlight">\(\nat\)</span> and <span class="math notranslate nohighlight">\(\nat→\nat\)</span> are types of constructor of <span class="math notranslate nohighlight">\(\nat\)</span>.
<span class="math notranslate nohighlight">\(∀ A:\Type,~\List~A\)</span> and <span class="math notranslate nohighlight">\(∀ A:\Type,~A→\List~A→\List~A\)</span> are types of constructor of <span class="math notranslate nohighlight">\(\List\)</span>.</p>
</div>
</section>
<section id="positivity-condition">
<span id="positivity"></span><h4>Positivity Condition<a class="headerlink" href="#positivity-condition" title="Permalink to this headline">¶</a></h4>
<p>The type of constructor <span class="math notranslate nohighlight">\(T\)</span> will be said to <em>satisfy the positivity
condition</em> for a set of constants <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> in the following cases:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T=(X_j~t_1 … t_q )\)</span> for some <span class="math notranslate nohighlight">\(j\)</span> and no <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur free in any <span class="math notranslate nohighlight">\(t_i\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T=∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur only strictly positively in <span class="math notranslate nohighlight">\(U\)</span> and the type <span class="math notranslate nohighlight">\(V\)</span>
satisfies the positivity condition for <span class="math notranslate nohighlight">\(X_1 … X_k\)</span>.</p></li>
</ul>
</section>
<section id="strict-positivity">
<h4>Strict positivity<a class="headerlink" href="#strict-positivity" title="Permalink to this headline">¶</a></h4>
<p>The constants <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> <em>occur strictly positively</em> in <span class="math notranslate nohighlight">\(T\)</span> in the following
cases:</p>
<ul>
<li><p>no <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur in <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\((X_j~t_1 … t_q )\)</span> for some <span class="math notranslate nohighlight">\(j\)</span> and no <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur in any of <span class="math notranslate nohighlight">\(t_i\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\(∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur
strictly positively in type <span class="math notranslate nohighlight">\(V\)</span> but none of them occur in <span class="math notranslate nohighlight">\(U\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> converts to <span class="math notranslate nohighlight">\((I~a_1 … a_r~t_1 … t_s )\)</span> where <span class="math notranslate nohighlight">\(I\)</span> is the name of an
inductive definition of the form</p>
<div class="math notranslate nohighlight">
\[\ind{r}{I:A}{c_1 :∀ p_1 :P_1 ,… ∀p_r :P_r ,~C_1 ;~…;~c_n :∀ p_1 :P_1 ,… ∀p_r :P_r ,~C_n}\]</div>
<p>(in particular, it is
not mutually defined and it has <span class="math notranslate nohighlight">\(r\)</span> parameters) and no <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur in
any of the <span class="math notranslate nohighlight">\(t_i\)</span> nor in any of the <span class="math notranslate nohighlight">\(a_j\)</span> for <span class="math notranslate nohighlight">\(m &lt; j ≤ r\)</span> where <span class="math notranslate nohighlight">\(m ≤ r\)</span>
is the number of recursively uniform parameters, and the (instantiated) types of constructor
<span class="math notranslate nohighlight">\(\subst{C_i}{p_j}{a_j}_{j=1… m}\)</span> of <span class="math notranslate nohighlight">\(I\)</span> satisfy the nested positivity condition for <span class="math notranslate nohighlight">\(X_1 … X_k\)</span></p>
</li>
</ul>
</section>
<section id="nested-positivity">
<h4>Nested Positivity<a class="headerlink" href="#nested-positivity" title="Permalink to this headline">¶</a></h4>
<p>If <span class="math notranslate nohighlight">\(I\)</span> is a non-mutual inductive type with <span class="math notranslate nohighlight">\(r\)</span>
parameters, then,
the type of constructor <span class="math notranslate nohighlight">\(T\)</span> of <span class="math notranslate nohighlight">\(I\)</span> <em>satisfies the nested
positivity condition</em> for a set of constants <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> in the following
cases:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T=(I~b_1 … b_r~u_1 … u_s)\)</span> and no <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur in
any <span class="math notranslate nohighlight">\(u_i\)</span> nor in
any of the <span class="math notranslate nohighlight">\(b_j\)</span> for <span class="math notranslate nohighlight">\(m &lt; j ≤ r\)</span> where <span class="math notranslate nohighlight">\(m ≤ r\)</span> is
the number of recursively uniform parameters</p></li>
<li><p><span class="math notranslate nohighlight">\(T=∀ x:U,~V\)</span> and <span class="math notranslate nohighlight">\(X_1 … X_k\)</span> occur only strictly positively in <span class="math notranslate nohighlight">\(U\)</span> and the type <span class="math notranslate nohighlight">\(V\)</span>
satisfies the nested positivity condition for <span class="math notranslate nohighlight">\(X_1 … X_k\)</span></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>For instance, if one considers the following variant of a tree type
branching over the natural numbers:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nattree</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">natnode</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; (</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>nattree is defined
nattree_rect is defined
nattree_ind is defined
nattree_rec is defined
nattree_sind is defined
</span></dd>
</dl>
</div>
<p>Then every instantiated constructor of <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> satisfies the nested positivity
condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code>:</p>
<ul class="simple">
<li><p>Type <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">leaf</span></code> satisfies the positivity condition for
<code class="docutils literal notranslate"><span class="pre">nattree</span></code> because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not appear in any (real) arguments of the
type of that constructor (primarily because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not have any (real)
arguments) ... (bullet 1)</p></li>
<li><p>Type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">(nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A)</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">natnode</span></code> satisfies the
positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code> because:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">A</span></code> ... (bullet 1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 3 + 2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nattree</span></code> satisfies the positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 1)</p></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="correctness-rules">
<span id="id4"></span><h4>Correctness rules<a class="headerlink" href="#correctness-rules" title="Permalink to this headline">¶</a></h4>
<p>We shall now describe the rules allowing the introduction of a new
inductive definition.</p>
<p>Let <span class="math notranslate nohighlight">\(E\)</span> be a global environment and <span class="math notranslate nohighlight">\(Γ_P\)</span>, <span class="math notranslate nohighlight">\(Γ_I\)</span>, <span class="math notranslate nohighlight">\(Γ_C\)</span> be contexts
such that <span class="math notranslate nohighlight">\(Γ_I\)</span> is <span class="math notranslate nohighlight">\([I_1 :∀ Γ_P ,A_1 ;~…;~I_k :∀ Γ_P ,A_k]\)</span>, and
<span class="math notranslate nohighlight">\(Γ_C\)</span> is <span class="math notranslate nohighlight">\([c_1:∀ Γ_P ,C_1 ;~…;~c_n :∀ Γ_P ,C_n ]\)</span>. Then</p>
<dl>
<dt id="inference-W-Ind">W-Ind</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
\WFE{Γ_P}%
\hspace{3em}%
(E[Γ_I ;Γ_P ] ⊢ C_i : s_{q_i} )_{i=1… n}%
}{%
\WF{E;~\ind{l}{Γ_I}{Γ_C}}{}%
}\]</div>
</dd>
</dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(k&gt;0\)</span> and all of <span class="math notranslate nohighlight">\(I_j\)</span> and <span class="math notranslate nohighlight">\(c_i\)</span> are distinct names for <span class="math notranslate nohighlight">\(j=1… k\)</span> and <span class="math notranslate nohighlight">\(i=1… n\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(l\)</span> is the size of <span class="math notranslate nohighlight">\(Γ_P\)</span> which is called the context of parameters,</p></li>
<li><p>for <span class="math notranslate nohighlight">\(j=1… k\)</span> we have that <span class="math notranslate nohighlight">\(A_j\)</span> is an arity of sort <span class="math notranslate nohighlight">\(s_j\)</span> and <span class="math notranslate nohighlight">\(I_j ∉ E\)</span>,</p></li>
<li><p>for <span class="math notranslate nohighlight">\(i=1… n\)</span> we have that <span class="math notranslate nohighlight">\(C_i\)</span> is a type of constructor of <span class="math notranslate nohighlight">\(I_{q_i}\)</span> which
satisfies the positivity condition for <span class="math notranslate nohighlight">\(I_1 … I_k\)</span> and <span class="math notranslate nohighlight">\(c_i ∉  E\)</span>.</p></li>
</ul>
</div></blockquote>
<p>One can remark that there is a constraint between the sort of the
arity of the inductive type and the sort of the type of its
constructors which will always be satisfied for the impredicative
sorts <span class="math notranslate nohighlight">\(\SProp\)</span> and <span class="math notranslate nohighlight">\(\Prop\)</span> but may fail to define
inductive type on sort <span class="math notranslate nohighlight">\(\Set\)</span> and generate constraints
between universes for inductive types in the Type hierarchy.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>It is well known that the existential quantifier can be encoded as an
inductive definition. The following declaration introduces the
second-order existential quantifier <span class="math notranslate nohighlight">\(∃ X.P(X)\)</span>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exProp</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">exP_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exProp</span><span> </span><span class="coqdoc-var">P</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>exProp is defined
exProp_ind is defined
exProp_sind is defined
</span></dd>
</dl>
</div>
<p>The same definition on <span class="math notranslate nohighlight">\(\Set\)</span> is not allowed and fails:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exSet</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Set</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
</span><span class="coqdoc-var">exS_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exSet</span><span> </span><span class="coqdoc-var">P</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Large non-propositional inductive types must be in Type.
</span></dd>
</dl>
</div>
<p>It is possible to declare the same inductive definition in the
universe <span class="math notranslate nohighlight">\(\Type\)</span>. The <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exType</span></span></code> inductive definition has type
<span class="math notranslate nohighlight">\((\Type(i)→\Prop)→\Type(j)\)</span> with the constraint that the parameter <span class="math notranslate nohighlight">\(X\)</span> of <span class="math notranslate nohighlight">\(\kw{exT}_{\kw{intro}}\)</span>
has type <span class="math notranslate nohighlight">\(\Type(k)\)</span> with <span class="math notranslate nohighlight">\(k&lt;j\)</span> and <span class="math notranslate nohighlight">\(k≤ i\)</span>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exType</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Type</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
</span><span class="coqdoc-var">exT_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exType</span><span> </span><span class="coqdoc-var">P</span><span>.</span><span>
</span></dt><dd><span>exType is defined
exType_rect is defined
exType_ind is defined
exType_rec is defined
exType_sind is defined
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Negative occurrence (first example)</p>
<p>The following inductive definition is rejected because it does not
satisfy the positivity condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">not_I_I</span><span> (</span><span class="coqdoc-var">not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>) : </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Non strictly positive occurrence of &quot;I&quot; in &quot;(I</span><span> -&gt;</span><span> False)</span><span> -&gt;</span><span> I&quot;.
</span></dd>
</dl>
</div>
<p>If we were to accept such definition, we could derive a
contradiction from it (we can test this by disabling the
<a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:flag.Positivity-Checking" title="Positivity Checking"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Positivity</span> <span class="pre">Checking</span></code></a> flag):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span>#[</span><span class="coqdoc-var">bypass_check</span><span>(</span><span class="coqdoc-var">positivity</span><span>)] </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">not_I_I</span><span> (</span><span class="coqdoc-var">not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">False</span><span>) : </span><span class="coqdoc-var">I</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>I is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">I_not_I</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; ~ </span><span class="coqdoc-var">I</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">i</span><span> =&gt;</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">not_I_I</span><span> </span><span class="coqdoc-var">not_I</span><span> =&gt; </span><span class="coqdoc-var">not_I</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>I_not_I is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">contradiction</span><span> : </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  False
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-var">enough</span><span> (</span><span class="coqdoc-var">I</span><span> /\ ~ </span><span class="coqdoc-var">I</span><span>) </span><span class="coqdoc-keyword">as</span><span> [] </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">contradiction</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  I</span><span> /\</span><span> </span><span>~</span><span> I
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">split</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  ============================
  I

goal 2 is:
 </span><span>~</span><span> I
</span></dd>
<dt><span>  - </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">not_I_I</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  I

1 goal
  
  ============================
  I</span><span> -&gt;</span><span> False
</span></dd>
<dt><span>    </span><span class="coqdoc-tactic">intro</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  H : I
  ============================
  False
</span></dd>
<dt><span>    </span><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">I_not_I</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>This subproof is complete, but there are some unfocused goals.
Focus next goal with bullet -.

1 goal

goal 1 is:
 </span><span>~</span><span> I
</span></dd>
<dt><span>  - </span><span class="coqdoc-tactic">intro</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span>~</span><span> I

1 goal
  
  H : I
  ============================
  False
</span></dd>
<dt><span>    </span><span class="coqdoc-var">now</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">I_not_I</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Negative occurrence (second example)</p>
<p>Here is another example of an inductive definition which is
rejected because it does not satify the positivity condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Lam</span><span> := </span><span class="coqdoc-var">lam</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">Lam</span><span> -&gt; </span><span class="coqdoc-var">Lam</span><span>).</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Non strictly positive occurrence of &quot;Lam&quot; in &quot;(Lam</span><span> -&gt;</span><span> Lam)</span><span> -&gt;</span><span> Lam&quot;.
</span></dd>
</dl>
</div>
<p>Again, if we were to accept it, we could derive a contradiction
(this time through a non-terminating recursive function):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span>#[</span><span class="coqdoc-var">bypass_check</span><span>(</span><span class="coqdoc-var">positivity</span><span>)] </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Lam</span><span> := </span><span class="coqdoc-var">lam</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">Lam</span><span> -&gt; </span><span class="coqdoc-var">Lam</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>Lam is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">infinite_loop</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">False</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">lam</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">infinite_loop</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">l</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>infinite_loop is defined
infinite_loop is recursively defined (guarded on 1st argument)
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">infinite_loop</span><span> (</span><span class="coqdoc-var">lam</span><span> (&#64;</span><span class="coqdoc-var">id</span><span> </span><span class="coqdoc-var">Lam</span><span>)) : </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd><span>infinite_loop (lam (id (A:=Lam))) : False
     : False
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Non strictly positive occurrence</p>
<p>It is less obvious why inductive type definitions with occurences
that are positive but not strictly positive are harmful.
We will see that in presence of an impredicative type they
are unsound:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">introA</span><span>: ((</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>) -&gt; </span><span class="coqdoc-keyword">Prop</span><span>) -&gt; </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Non strictly positive occurrence of &quot;A&quot; in &quot;((A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> A&quot;.
</span></dd>
</dl>
</div>
<p>If we were to accept this definition we could derive a contradiction
by creating an injective function from <span class="math notranslate nohighlight">\(A → \Prop\)</span> to <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>This function is defined by composing the injective constructor of
the type <span class="math notranslate nohighlight">\(A\)</span> with the function <span class="math notranslate nohighlight">\(λx. λz. z = x\)</span> injecting
any type <span class="math notranslate nohighlight">\(T\)</span> into <span class="math notranslate nohighlight">\(T → \Prop\)</span>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span>#[</span><span class="coqdoc-var">bypass_check</span><span>(</span><span class="coqdoc-var">positivity</span><span>)] </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">A</span><span>: </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">introA</span><span>: ((</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>) -&gt; </span><span class="coqdoc-keyword">Prop</span><span>) -&gt; </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">x</span><span>: </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>): </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-var">introA</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">z</span><span> =&gt; </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">x</span><span>).</span><span>
</span></dt><dd><span>f is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">f_inj</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> x y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, f x</span><span> =</span><span> f y</span><span> -&gt;</span><span> x</span><span> =</span><span> y
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-tactic">unfold</span><span> </span><span class="coqdoc-var">f</span><span>; </span><span class="coqdoc-tactic">intros</span><span> ? ? </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">injection</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span>
      introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)
  ============================
  (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span> (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)</span><span> -&gt;</span><span> x</span><span> =</span><span> y
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">set</span><span> (</span><span class="coqdoc-var">F</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">z</span><span> =&gt; </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">y</span><span>); </span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">HF</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span>
      introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)
  F := </span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y : (A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HF : (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span> F
  ============================
  x</span><span> =</span><span> y
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">symmetry</span><span>; </span><span class="coqdoc-tactic">replace</span><span> (</span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span>) </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">y</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  x, y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span>
      introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)
  F := </span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y : (A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HF : (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span> F
  ============================
  F y

goal 2 is:
 F y</span><span> =</span><span> (y</span><span> =</span><span> x)
</span></dd>
<dt><span>  + </span><span class="coqdoc-tactic">unfold</span><span> </span><span class="coqdoc-var">F</span><span>; </span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span>
      introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)
  F := </span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y : (A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HF : (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span> F
  ============================
  F y

This subproof is complete, but there are some unfocused goals.
Focus next goal with bullet +.

1 goal

goal 1 is:
 F y</span><span> =</span><span> (y</span><span> =</span><span> x)
</span></dd>
<dt><span>  + </span><span class="coqdoc-tactic">rewrite</span><span> &lt;- </span><span class="coqdoc-var">HF</span><span>; </span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  x, y : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span>
      introA (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y)
  F := </span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> y : (A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>)</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  HF : (</span><span class="ansi-bold">fun</span><span> z : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; z</span><span> =</span><span> x)</span><span> =</span><span> F
  ============================
  F y</span><span> =</span><span> (y</span><span> =</span><span> x)

No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
<p>The type <span class="math notranslate nohighlight">\(A → \Prop\)</span> can be understood as the powerset
of the type <span class="math notranslate nohighlight">\(A\)</span>. To derive a contradiction from the
injective function <span class="math notranslate nohighlight">\(f\)</span> we use Cantor's classic diagonal
argument.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">d</span><span>: </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">s</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">s</span><span> /\ ~</span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span>.</span><span>
</span></dt><dd><span>d is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">fd</span><span>: </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">d</span><span>.</span><span>
</span></dt><dd><span>fd is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">cantor</span><span>: (</span><span class="coqdoc-var">d</span><span> </span><span class="coqdoc-var">fd</span><span>) &lt;-&gt; ~(</span><span class="coqdoc-var">d</span><span> </span><span class="coqdoc-var">fd</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  d fd</span><span> &lt;-&gt;</span><span> </span><span>~</span><span> d fd
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-tactic">split</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  ============================
  d fd</span><span> -&gt;</span><span> </span><span>~</span><span> d fd

goal 2 is:
 </span><span>~</span><span> d fd</span><span> -&gt;</span><span> d fd
</span></dd>
<dt><span>  + </span><span class="coqdoc-tactic">intros</span><span> [</span><span class="coqdoc-var">s</span><span> [</span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>]]; </span><span class="coqdoc-tactic">unfold</span><span> </span><span class="coqdoc-var">fd</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H1</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  d fd</span><span> -&gt;</span><span> </span><span>~</span><span> d fd

1 goal
  
  s : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : f d</span><span> =</span><span> f s
  H2 : </span><span>~</span><span> s fd
  ============================
  </span><span>~</span><span> d fd
</span></dd>
<dt><span>    </span><span class="coqdoc-tactic">replace</span><span> </span><span class="coqdoc-var">d</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">s</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  s : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : f d</span><span> =</span><span> f s
  H2 : </span><span>~</span><span> s fd
  ============================
  </span><span>~</span><span> s fd

goal 2 is:
 s</span><span> =</span><span> d
</span></dd>
<dt><span>    * </span><span class="coqdoc-tactic">assumption</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  s : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : f d</span><span> =</span><span> f s
  H2 : </span><span>~</span><span> s fd
  ============================
  </span><span>~</span><span> s fd

This subproof is complete, but there are some unfocused goals.
Focus next goal with bullet *.

2 goals

goal 1 is:
 s</span><span> =</span><span> d
goal 2 is:
 </span><span>~</span><span> d fd</span><span> -&gt;</span><span> d fd
</span></dd>
<dt><span>    * </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">f_inj</span><span>; </span><span class="coqdoc-tactic">congruence</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  s : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H1 : f d</span><span> =</span><span> f s
  H2 : </span><span>~</span><span> s fd
  ============================
  s</span><span> =</span><span> d

This subproof is complete, but there are some unfocused goals.
Focus next goal with bullet +.

1 goal

goal 1 is:
 </span><span>~</span><span> d fd</span><span> -&gt;</span><span> d fd
</span></dd>
<dt><span>  + </span><span class="coqdoc-tactic">intro</span><span>; </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">d</span><span>; </span><span class="coqdoc-tactic">tauto</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span>~</span><span> d fd</span><span> -&gt;</span><span> d fd

No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">bad</span><span>: </span><span class="coqdoc-var">False</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  False
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span>  </span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">cantor</span><span>; </span><span class="coqdoc-tactic">tauto</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
<p>This derivation was first presented by Thierry Coquand and Christine
Paulin in <a class="reference internal" href="../../zebibliography.html#cp90" id="id5">[CP90]</a>.</p>
</div>
</section>
<section id="template-polymorphism">
<span id="id6"></span><h4>Template polymorphism<a class="headerlink" href="#template-polymorphism" title="Permalink to this headline">¶</a></h4>
<p>Inductive types can be made polymorphic over the universes introduced by
their parameters in <span class="math notranslate nohighlight">\(\Type\)</span>, if the minimal inferred sort of the
inductive declarations either mention some of those parameter universes
or is computed to be <span class="math notranslate nohighlight">\(\Prop\)</span> or <span class="math notranslate nohighlight">\(\Set\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(A\)</span> is an arity of some sort and <span class="math notranslate nohighlight">\(s\)</span> is a sort, we write <span class="math notranslate nohighlight">\(A_{/s}\)</span>
for the arity obtained from <span class="math notranslate nohighlight">\(A\)</span> by replacing its sort with <span class="math notranslate nohighlight">\(s\)</span>.
Especially, if <span class="math notranslate nohighlight">\(A\)</span> is well-typed in some global environment and local
context, then <span class="math notranslate nohighlight">\(A_{/s}\)</span> is typable by typability of all products in the
Calculus of Inductive Constructions. The following typing rule is
added to the theory.</p>
<p>Let <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> be an inductive definition. Let
<span class="math notranslate nohighlight">\(Γ_P = [p_1 :P_1 ;~…;~p_p :P_p ]\)</span> be its context of parameters,
<span class="math notranslate nohighlight">\(Γ_I = [I_1:∀ Γ_P ,A_1 ;~…;~I_k :∀ Γ_P ,A_k ]\)</span> its context of definitions and
<span class="math notranslate nohighlight">\(Γ_C = [c_1 :∀ Γ_P ,C_1 ;~…;~c_n :∀ Γ_P ,C_n]\)</span> its context of constructors,
with <span class="math notranslate nohighlight">\(c_i\)</span> a constructor of <span class="math notranslate nohighlight">\(I_{q_i}\)</span>. Let <span class="math notranslate nohighlight">\(m ≤ p\)</span> be the length of the
longest prefix of parameters such that the <span class="math notranslate nohighlight">\(m\)</span> first arguments of all
occurrences of all <span class="math notranslate nohighlight">\(I_j\)</span> in all <span class="math notranslate nohighlight">\(C_k\)</span> (even the occurrences in the
hypotheses of <span class="math notranslate nohighlight">\(C_k\)</span>) are exactly applied to <span class="math notranslate nohighlight">\(p_1 … p_m\)</span> (<span class="math notranslate nohighlight">\(m\)</span> is the number
of <em>recursively uniform parameters</em> and the <span class="math notranslate nohighlight">\(p−m\)</span> remaining parameters
are the <em>recursively non-uniform parameters</em>). Let <span class="math notranslate nohighlight">\(q_1 , …, q_r\)</span>, with
<span class="math notranslate nohighlight">\(0≤ r≤ m\)</span>, be a (possibly) partial instantiation of the recursively
uniform parameters of <span class="math notranslate nohighlight">\(Γ_P\)</span>. We have:</p>
<dl>
<dt id="inference-Ind-Family">Ind-Family</dt><dd><div class="math notranslate nohighlight">
\[\begin{split}\frac{%
\left\{\begin{array}{l}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} \in E\\%
\hspace{3em}%
(E[]  ⊢ q_l : P'_l)_{l=1\ldots r}\\%
\hspace{3em}%
(E[]  ⊢ P'_l ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1})_{l=1\ldots r}\\%
\hspace{3em}%
1 \leq j \leq k%
\hspace{3em}%
\end{array}%
\hspace{3em}%
\right.%
}{%
E[] ⊢ I_j~q_1 … q_r :∀ [p_{r+1} :P_{r+1} ;~…;~p_p :P_p], (A_j)_{/s_j}%
}\end{split}\]</div>
</dd>
</dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Γ_{P′}\)</span> is the context obtained from <span class="math notranslate nohighlight">\(Γ_P\)</span> by replacing each <span class="math notranslate nohighlight">\(P_l\)</span> that is
an arity with <span class="math notranslate nohighlight">\(P_l'\)</span> for <span class="math notranslate nohighlight">\(1≤ l ≤ r\)</span> (notice that <span class="math notranslate nohighlight">\(P_l\)</span> arity implies <span class="math notranslate nohighlight">\(P_l'\)</span>
arity since <span class="math notranslate nohighlight">\(E[] ⊢ P_l' ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1}\)</span>);</p></li>
<li><p>there are sorts <span class="math notranslate nohighlight">\(s_i\)</span>, for <span class="math notranslate nohighlight">\(1 ≤ i ≤ k\)</span> such that, for
<span class="math notranslate nohighlight">\(Γ_{I'} = [I_1 :∀ Γ_{P'} ,(A_1)_{/s_1} ;~…;~I_k :∀ Γ_{P'} ,(A_k)_{/s_k}]\)</span>
we have <span class="math notranslate nohighlight">\((E[Γ_{I′} ;Γ_{P′}] ⊢ C_i : s_{q_i})_{i=1… n}\)</span> ;</p></li>
<li><p>the sorts <span class="math notranslate nohighlight">\(s_i\)</span> are all introduced by the inductive
declaration and have no universe constraints beside being greater
than or equal to <span class="math notranslate nohighlight">\(\Prop\)</span>, and such that all
eliminations, to <span class="math notranslate nohighlight">\(\Prop\)</span>, <span class="math notranslate nohighlight">\(\Set\)</span> and <span class="math notranslate nohighlight">\(\Type(j)\)</span>,
are allowed (see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>).</p></li>
</ul>
</div></blockquote>
<p>Notice that if <span class="math notranslate nohighlight">\(I_j~q_1 … q_r\)</span> is typable using the rules <strong>Ind-Const</strong> and
<strong>App</strong>, then it is typable using the rule <strong>Ind-Family</strong>. Conversely, the
extended theory is not stronger than the theory without <strong>Ind-Family</strong>. We
get an equiconsistency result by mapping each <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span>
occurring into a given derivation into as many different inductive
types and constructors as the number of different (partial)
replacements of sorts, needed for this derivation, in the parameters
that are arities (this is possible because <span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span> well-formed
implies that <span class="math notranslate nohighlight">\(\ind{p}{Γ_{I'}}{Γ_{C'}}\)</span> is well-formed and has the
same allowed eliminations, where <span class="math notranslate nohighlight">\(Γ_{I′}\)</span> is defined as above and
<span class="math notranslate nohighlight">\(Γ_{C′} = [c_1 :∀ Γ_{P′} ,C_1 ;~…;~c_n :∀ Γ_{P′} ,C_n ]\)</span>). That is, the changes in the
types of each partial instance <span class="math notranslate nohighlight">\(q_1 … q_r\)</span> can be characterized by the
ordered sets of arity sorts among the types of parameters, and to each
signature is associated a new inductive definition with fresh names.
Conversion is preserved as any (partial) instance <span class="math notranslate nohighlight">\(I_j~q_1 … q_r\)</span> or
<span class="math notranslate nohighlight">\(C_i~q_1 … q_r\)</span> is mapped to the names chosen in the specific instance of
<span class="math notranslate nohighlight">\(\ind{p}{Γ_I}{Γ_C}\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The restriction that sorts are introduced by the inductive
declaration prevents inductive types declared in sections to be
template-polymorphic on universes introduced previously in the
section: they cannot parameterize over the universes introduced with
section variables that become parameters at section closing time, as
these may be shared with other definitions from the same section
which can impose constraints on them.</p>
</div>
<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Auto-Template-Polymorphism">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Auto</span></span></span> <span><span><span class="pre">Template</span></span></span> <span><span><span class="pre">Polymorphism</span></span></span></span></span><a class="headerlink" href="#coq:flag.Auto-Template-Polymorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="basic.html#term-flag"><span class="xref std std-term">flag</span></a>, enabled by default, makes every inductive type declared
at level <span class="math notranslate nohighlight">\(\Type\)</span> (without an explicit universe instance or hiding it behind a
definition) template polymorphic if possible.</p>
<p>This can be prevented using the <a class="reference internal" href="#coq:attr.universes(template)" title="universes(template)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(template=no)</span></code></a>
attribute.</p>
<p>Template polymorphism and full universe polymorphism (see Chapter
<a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) are incompatible, so if the latter is
enabled (through the <a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:flag.Universe-Polymorphism" title="Universe Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Universe</span> <span class="pre">Polymorphism</span></code></a> flag or the
<a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:attr.universes(polymorphic)" title="universes(polymorphic)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></a> attribute) it will prevail over
automatic template polymorphism.</p>
</dd></dl>

<dl class="coq warn">
<dt class="sig sig-object coq" id="coq:warn.Automatically-declaring-‘ident’-as-template-polymorphic">
<em class="property"><span class="sigannot"><span class="pre">Warning</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Automatically</span></span></span> <span><span><span class="pre">declaring</span></span></span> <a class="reference internal" href="basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">as</span></span></span> <span><span><span class="pre">template</span></span></span> <span><span><span class="pre">polymorphic.</span></span></span></span></span><a class="headerlink" href="#coq:warn.Automatically-declaring-‘ident’-as-template-polymorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning <code class="docutils literal notranslate"><span class="pre">auto-template</span></code> can be used (it is off by default) to
find which types are implicitly declared template polymorphic by
<a class="reference internal" href="#coq:flag.Auto-Template-Polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span> <span class="pre">Template</span> <span class="pre">Polymorphism</span></code></a>.</p>
<p>An inductive type can be forced to be template polymorphic using
the <a class="reference internal" href="#coq:attr.universes(template)" title="universes(template)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(template)</span></code></a> attribute: in this case, the
warning is not emitted.</p>
</dd></dl>

<dl class="coq attr">
<dt class="sig sig-object coq" id="coq:attr.universes(template)">
<em class="property"><span class="sigannot"><span class="pre">Attribute</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">universes(template</span></span></span><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">=</span></span></span> <span class="alternative"><span class="alternative-block"><span><span><span class="pre">yes</span></span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">no</span></span></span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span><span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#coq:attr.universes(template)" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="basic.html#term-boolean-attribute"><span class="xref std std-term">boolean attribute</span></a> can be used to explicitly declare an
inductive type as template polymorphic, whether the <a class="reference internal" href="#coq:flag.Auto-Template-Polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span>
<span class="pre">Template</span> <span class="pre">Polymorphism</span></code></a> flag is on or off.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.template-and-polymorphism-not-compatible">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">template</span></span></span> <span><span><span class="pre">and</span></span></span> <span><span><span class="pre">polymorphism</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">compatible</span></span></span></span></span><a class="headerlink" href="#coq:exn.template-and-polymorphism-not-compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute cannot be used in a full universe polymorphic
context, i.e. if the <a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:flag.Universe-Polymorphism" title="Universe Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Universe</span> <span class="pre">Polymorphism</span></code></a> flag is on or
if the <a class="reference internal" href="../../addendum/universe-polymorphism.html#coq:attr.universes(polymorphic)" title="universes(polymorphic)"><code class="xref coq coq-attr docutils literal notranslate"><span class="pre">universes(polymorphic)</span></code></a> attribute is used.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Ill-formed-template-inductive-declaration:-not-polymorphic-on-any-universe">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Ill-formed</span></span></span> <span><span><span class="pre">template</span></span></span> <span><span><span class="pre">inductive</span></span></span> <span><span><span class="pre">declaration:</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">polymorphic</span></span></span> <span><span><span class="pre">on</span></span></span> <span><span><span class="pre">any</span></span></span> <span><span><span class="pre">universe.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Ill-formed-template-inductive-declaration:-not-polymorphic-on-any-universe" title="Permalink to this definition">¶</a></dt>
<dd><p>The attribute was used but the inductive definition does not
satisfy the criterion to be template polymorphic.</p>
</dd></dl>

<p>When <code class="docutils literal notranslate"><span class="pre">universes(template=no)</span></code> is used, it will prevent an
inductive type to be template polymorphic, even if the <a class="reference internal" href="#coq:flag.Auto-Template-Polymorphism" title="Auto Template Polymorphism"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Auto</span>
<span class="pre">Template</span> <span class="pre">Polymorphism</span></code></a> flag is on.</p>
</dd></dl>

<p>In practice, the rule <strong>Ind-Family</strong> is used by Coq only when there is only one
inductive type in the inductive definition and it is declared with an arity
whose sort is in the Type hierarchy. Then, the polymorphism is over
the parameters whose type is an arity of sort in the Type hierarchy.
The sorts <span class="math notranslate nohighlight">\(s_j\)</span> are chosen canonically so that each <span class="math notranslate nohighlight">\(s_j\)</span> is minimal with
respect to the hierarchy <span class="math notranslate nohighlight">\(\Prop ⊂ \Set_p ⊂ \Type\)</span> where <span class="math notranslate nohighlight">\(\Set_p\)</span> is predicative
<span class="math notranslate nohighlight">\(\Set\)</span>. More precisely, an empty or small singleton inductive definition
(i.e. an inductive definition of which all inductive types are
singleton – see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) is set in <span class="math notranslate nohighlight">\(\Prop\)</span>, a small non-singleton
inductive type is set in <span class="math notranslate nohighlight">\(\Set\)</span> (even in case <span class="math notranslate nohighlight">\(\Set\)</span> is impredicative – see
<a class="reference internal" href="../cic.html#the-calculus-of-inductive-construction-with-impredicative-set"><span class="std std-ref">The Calculus of Inductive Constructions with impredicative Set</span></a>),
and otherwise in the Type hierarchy.</p>
<p>Note that the side-condition about allowed elimination sorts in the rule
<strong>Ind-Family</strong> avoids to recompute the allowed elimination sorts at each
instance of a pattern matching (see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>). As an
example, let us consider the following definition:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">option</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">None</span><span> : </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">Some</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>option is defined
option_rect is defined
option_ind is defined
option_rec is defined
option_sind is defined
</span></dd>
</dl>
</div>
</div>
<p>As the definition is set in the Type hierarchy, it is used
polymorphically over its parameters whose types are arities of a sort
in the Type hierarchy. Here, the parameter <span class="math notranslate nohighlight">\(A\)</span> has this property, hence,
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate nohighlight">\(\Set\)</span>, the result is in <span class="math notranslate nohighlight">\(\Set\)</span>. Note that
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate nohighlight">\(\Prop\)</span>, then, the result is not set in
<span class="math notranslate nohighlight">\(\Prop\)</span> but in <span class="math notranslate nohighlight">\(\Set\)</span> still. This is because <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is not a singleton type
(see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) and it would lose the elimination to <span class="math notranslate nohighlight">\(\Set\)</span> and <span class="math notranslate nohighlight">\(\Type\)</span>
if set in <span class="math notranslate nohighlight">\(\Prop\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> =&gt; option A
     : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; option A
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
</span></dd>
</dl>
</div>
</div>
<p>Here is another example.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">prod</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">pair</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>prod is defined
prod_rect is defined
prod_ind is defined
prod_rec is defined
prod_sind is defined
</span></dd>
</dl>
</div>
</div>
<p>As <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">prod</span></span></code> is a singleton type, it will be in <span class="math notranslate nohighlight">\(\Prop\)</span> if applied twice to
propositions, in <span class="math notranslate nohighlight">\(\Set\)</span> if applied twice to at least one type in <span class="math notranslate nohighlight">\(\Set\)</span> and
none in <span class="math notranslate nohighlight">\(\Type\)</span>, and in <span class="math notranslate nohighlight">\(\Type\)</span> otherwise. In all cases, the three kind of
eliminations schemes are allowed.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> =&gt; prod A
     : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">A</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> =&gt; prod A A
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (B : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) =&gt; prod A B
     : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span><span>
</span></dt><dd><span class="ansi-bold">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) =&gt; prod A B
     : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Template polymorphism used to be called “sort-polymorphism of
inductive types” before universe polymorphism
(see Chapter <a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) was introduced.</p>
</div>
</section>
</section>
<section id="destructors">
<span id="id7"></span><h3>Destructors<a class="headerlink" href="#destructors" title="Permalink to this headline">¶</a></h3>
<p>The specification of inductive definitions with arities and
constructors is quite natural. But we still have to say how to use an
object in an inductive type.</p>
<p>This problem is rather delicate. There are actually several different
ways to do that. Some of them are logically equivalent but not always
equivalent from the computational point of view or from the user point
of view.</p>
<p>From the computational point of view, we want to be able to define a
function whose domain is an inductively defined type by using a
combination of case analysis over the possible constructors of the
object and recursion.</p>
<p>Because we need to keep a consistent theory and also we prefer to keep
a strongly normalizing reduction, we cannot accept any sort of
recursion (even terminating). So the basic idea is to restrict
ourselves to primitive recursive functions and functionals.</p>
<p>For instance, assuming a parameter <span class="math notranslate nohighlight">\(A:\Set\)</span> exists in the local context,
we want to build a function <span class="math notranslate nohighlight">\(\length\)</span> of type <span class="math notranslate nohighlight">\(\List~A → \nat\)</span> which computes
the length of the list, such that <span class="math notranslate nohighlight">\((\length~(\Nil~A)) = \nO\)</span> and
<span class="math notranslate nohighlight">\((\length~(\cons~A~a~l)) = (\nS~(\length~l))\)</span>.
We want these equalities to be
recognized implicitly and taken into account in the conversion rule.</p>
<p>From the logical point of view, we have built a type family by giving
a set of constructors. We want to capture the fact that we do not have
any other way to build an object in this type. So when trying to prove
a property about an object <span class="math notranslate nohighlight">\(m\)</span> in an inductive type it is enough
to enumerate all the cases where <span class="math notranslate nohighlight">\(m\)</span> starts with a different
constructor.</p>
<p>In case the inductive definition is effectively a recursive one, we
want to capture the extra property that we have built the smallest
fixed point of this recursive equation. This says that we are only
manipulating finite objects. This analysis provides induction
principles. For instance, in order to prove
<span class="math notranslate nohighlight">\(∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l))\)</span> it is enough to prove:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\Nil~A)~(\length~(\Nil~A)))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(∀ a:A,~∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l)) →\)</span>
<span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\cons~A~a~l)~(\length~(\cons~A~a~l)))\)</span></p></li>
</ul>
<p>which given the conversion equalities satisfied by <span class="math notranslate nohighlight">\(\length\)</span> is the same
as proving:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\Nil~A)~\nO)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(∀ a:A,~∀ l:\List~A,~(\kw{has}\_\kw{length}~A~l~(\length~l)) →\)</span>
<span class="math notranslate nohighlight">\((\kw{has}\_\kw{length}~A~(\cons~A~a~l)~(\nS~(\length~l)))\)</span></p></li>
</ul>
<p>One conceptually simple way to do that, following the basic scheme
proposed by Martin-Löf in his Intuitionistic Type Theory, is to
introduce for each inductive definition an elimination operator. At
the logical level it is a proof of the usual induction principle and
at the computational level it implements a generic operator for doing
primitive recursion over the structure.</p>
<p>But this operator is rather tedious to implement and use. We choose in
this version of Coq to factorize the operator for primitive recursion
into two more primitive operations as was first suggested by Th.
Coquand in <a class="reference internal" href="../../zebibliography.html#coq92" id="id8">[Coq92]</a>. One is the definition by pattern matching. The
second one is a definition by guarded fixpoints.</p>
<section id="the-match-with-end-construction">
<span id="match-construction"></span><h4>The match ... with ... end construction<a class="headerlink" href="#the-match-with-end-construction" title="Permalink to this headline">¶</a></h4>
<p>The basic idea of this operator is that we have an object <span class="math notranslate nohighlight">\(m\)</span> in an
inductive type <span class="math notranslate nohighlight">\(I\)</span> and we want to prove a property which possibly
depends on <span class="math notranslate nohighlight">\(m\)</span>. For this, it is enough to prove the property for
<span class="math notranslate nohighlight">\(m = (c_i~u_1 … u_{p_i} )\)</span> for each constructor of <span class="math notranslate nohighlight">\(I\)</span>.
The Coq term for this proof
will be written:</p>
<div class="math notranslate nohighlight">
\[\Match~m~\with~(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | … | (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n~\kwend\]</div>
<p>In this expression, if <span class="math notranslate nohighlight">\(m\)</span> eventually happens to evaluate to
<span class="math notranslate nohighlight">\((c_i~u_1 … u_{p_i})\)</span> then the expression will behave as specified in its <span class="math notranslate nohighlight">\(i\)</span>-th branch
and it will reduce to <span class="math notranslate nohighlight">\(f_i\)</span> where the <span class="math notranslate nohighlight">\(x_{i1} …x_{ip_i}\)</span> are replaced by the
<span class="math notranslate nohighlight">\(u_1 … u_{p_i}\)</span> according to the ι-reduction.</p>
<p>Actually, for type checking a <span class="math notranslate nohighlight">\(\Match…\with…\kwend\)</span> expression we also need
to know the predicate <span class="math notranslate nohighlight">\(P\)</span> to be proved by case analysis. In the general
case where <span class="math notranslate nohighlight">\(I\)</span> is an inductively defined <span class="math notranslate nohighlight">\(n\)</span>-ary relation, <span class="math notranslate nohighlight">\(P\)</span> is a predicate
over <span class="math notranslate nohighlight">\(n+1\)</span> arguments: the <span class="math notranslate nohighlight">\(n\)</span> first ones correspond to the arguments of <span class="math notranslate nohighlight">\(I\)</span>
(parameters excluded), and the last one corresponds to object <span class="math notranslate nohighlight">\(m\)</span>. Coq
can sometimes infer this predicate but sometimes not. The concrete
syntax for describing this predicate uses the <span class="math notranslate nohighlight">\(\as…\In…\return\)</span>
construction. For instance, let us assume that <span class="math notranslate nohighlight">\(I\)</span> is an unary predicate
with one parameter and one argument. The predicate is made explicit
using the syntax:</p>
<div class="math notranslate nohighlight">
\[\Match~m~\as~x~\In~I~\_~a~\return~P~\with~
(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | …
| (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n~\kwend\]</div>
<p>The <span class="math notranslate nohighlight">\(\as\)</span> part can be omitted if either the result type does not depend
on <span class="math notranslate nohighlight">\(m\)</span> (non-dependent elimination) or <span class="math notranslate nohighlight">\(m\)</span> is a variable (in this case, <span class="math notranslate nohighlight">\(m\)</span>
can occur in <span class="math notranslate nohighlight">\(P\)</span> where it is considered a bound variable). The <span class="math notranslate nohighlight">\(\In\)</span> part
can be omitted if the result type does not depend on the arguments
of <span class="math notranslate nohighlight">\(I\)</span>. Note that the arguments of <span class="math notranslate nohighlight">\(I\)</span> corresponding to parameters <em>must</em>
be <span class="math notranslate nohighlight">\(\_\)</span>, because the result type is not generalized to all possible
values of the parameters. The other arguments of <span class="math notranslate nohighlight">\(I\)</span> (sometimes called
indices in the literature) have to be variables (<span class="math notranslate nohighlight">\(a\)</span> above) and these
variables can occur in <span class="math notranslate nohighlight">\(P\)</span>. The expression after <span class="math notranslate nohighlight">\(\In\)</span> must be seen as an
<em>inductive type pattern</em>. Notice that expansion of implicit arguments
and notations apply to this pattern. For the purpose of presenting the
inference rules, we use a more compact notation:</p>
<div class="math notranslate nohighlight">
\[\case(m,(λ a x . P), λ x_{11} ... x_{1p_1} . f_1~| … |~λ x_{n1} ...x_{np_n} . f_n )\]</div>
<p id="allowed-elimination-sorts"><strong>Allowed elimination sorts.</strong> An important question for building the typing rule for <span class="math notranslate nohighlight">\(\Match\)</span> is what
can be the type of <span class="math notranslate nohighlight">\(λ a x . P\)</span> with respect to the type of <span class="math notranslate nohighlight">\(m\)</span>. If <span class="math notranslate nohighlight">\(m:I\)</span>
and <span class="math notranslate nohighlight">\(I:A\)</span> and <span class="math notranslate nohighlight">\(λ a x . P : B\)</span> then by <span class="math notranslate nohighlight">\([I:A|B]\)</span> we mean that one can use
<span class="math notranslate nohighlight">\(λ a x . P\)</span> with <span class="math notranslate nohighlight">\(m\)</span> in the above match-construct.</p>
<p id="cic-notations"><strong>Notations.</strong> The <span class="math notranslate nohighlight">\([I:A|B]\)</span> is defined as the smallest relation satisfying the
following rules: We write <span class="math notranslate nohighlight">\([I|B]\)</span> for <span class="math notranslate nohighlight">\([I:A|B]\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is the type of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>The case of inductive types in sorts <span class="math notranslate nohighlight">\(\Set\)</span> or <span class="math notranslate nohighlight">\(\Type\)</span> is simple.
There is no restriction on the sort of the predicate to be eliminated.</p>
<dl>
<dt id="inference-Prod">Prod</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
[(I~x):A′|B′]%
}{%
[I:∀ x:A,~A′|∀ x:A,~B′]%
}\]</div>
</dd>
</dl>
<dl>
<dt id="inference-Set-&amp;-Type">Set &amp; Type</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
s_1 ∈ \{\Set,\Type(j)\}%
\hspace{3em}%
s_2 ∈ \Sort%
}{%
[I:s_1 |I→ s_2 ]%
}\]</div>
</dd>
</dl>
<p>The case of Inductive definitions of sort <span class="math notranslate nohighlight">\(\Prop\)</span> is a bit more
complicated, because of our interpretation of this sort. The only
harmless allowed eliminations, are the ones when predicate <span class="math notranslate nohighlight">\(P\)</span>
is also of sort <span class="math notranslate nohighlight">\(\Prop\)</span> or is of the morally smaller sort
<span class="math notranslate nohighlight">\(\SProp\)</span>.</p>
<dl>
<dt id="inference-Prop">Prop</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
s ∈ \{\SProp,\Prop\}%
}{%
[I:\Prop|I→s]%
}\]</div>
</dd>
</dl>
<p><span class="math notranslate nohighlight">\(\Prop\)</span> is the type of logical propositions, the proofs of properties <span class="math notranslate nohighlight">\(P\)</span> in
<span class="math notranslate nohighlight">\(\Prop\)</span> could not be used for computation and are consequently ignored by
the extraction mechanism. Assume <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are two propositions, and the
logical disjunction <span class="math notranslate nohighlight">\(A ∨ B\)</span> is defined inductively by:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
</span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> | </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>or is defined
or_ind is defined
or_sind is defined
</span></dd>
</dl>
</div>
</div>
<p>The following definition which computes a boolean value by case over
the proof of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span></code> is not accepted:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">choice</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">or_introl</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> =&gt; </span><span class="coqdoc-var">true</span><span> | </span><span class="coqdoc-var">or_intror</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Incorrect elimination of &quot;x&quot; in the inductive type &quot;or&quot;:
the return type has sort &quot;</span><span class="ansi-fg-yellow ansi-bold">Set</span><span>&quot; while it should be &quot;SProp&quot; or &quot;Prop&quot;.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort Set
because proofs can be eliminated only to build proofs.
</span></dd>
</dl>
</div>
</div>
<p>From the computational point of view, the structure of the proof of
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span><span class="operator"><span class="pre">)</span></span></code> in this term is needed for computing the boolean value.</p>
<p>In general, if <span class="math notranslate nohighlight">\(I\)</span> has type <span class="math notranslate nohighlight">\(\Prop\)</span> then <span class="math notranslate nohighlight">\(P\)</span> cannot have type <span class="math notranslate nohighlight">\(I→\Set\)</span>, because
it will mean to build an informative proof of type <span class="math notranslate nohighlight">\((P~m)\)</span> doing a case
analysis over a non-computational object that will disappear in the
extracted program. But the other way is safe with respect to our
interpretation we can have <span class="math notranslate nohighlight">\(I\)</span> a computational object and <span class="math notranslate nohighlight">\(P\)</span> a
non-computational one, it just corresponds to proving a logical property
of a computational object.</p>
<p>In the same spirit, elimination on <span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→\Type\)</span> cannot be allowed
because it trivially implies the elimination on <span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→ \Set\)</span> by
cumulativity. It also implies that there are two proofs of the same
property which are provably different, contradicting the
proof-irrelevance property which is sometimes a useful axiom:</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">proof_irrelevance</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">P</span><span>), </span><span class="coqdoc-var">x</span><span>=</span><span class="coqdoc-var">y</span><span>.</span><span>
</span></dt><dd><span>proof_irrelevance is declared
</span></dd>
</dl>
</div>
</div>
<p>The elimination of an inductive type of sort <span class="math notranslate nohighlight">\(\Prop\)</span> on a predicate
<span class="math notranslate nohighlight">\(P\)</span> of type <span class="math notranslate nohighlight">\(I→ \Type\)</span> leads to a paradox when applied to impredicative
inductive definition like the second-order existential quantifier
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exProp</span></span></code> defined above, because it gives access to the two projections on
this type.</p>
<p id="empty-and-singleton-elimination"><strong>Empty and singleton elimination.</strong> There are special inductive definitions in
<span class="math notranslate nohighlight">\(\Prop\)</span> for which more eliminations are allowed.</p>
<dl>
<dt id="inference-Prop-extended">Prop-extended</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
I~\kw{is an empty or singleton definition}%
\hspace{3em}%
s ∈ \Sort%
}{%
[I:\Prop|I→ s]%
}\]</div>
</dd>
</dl>
<p>A <em>singleton definition</em> has only one constructor and all the
arguments of this constructor have type <span class="math notranslate nohighlight">\(\Prop\)</span>. In that case, there is a
canonical way to interpret the informative extraction on an object in
that type, such that the elimination on any sort <span class="math notranslate nohighlight">\(s\)</span> is legal. Typical
examples are the conjunction of non-informative propositions and the
equality. If there is a hypothesis <span class="math notranslate nohighlight">\(h:a=b\)</span> in the local context, it can
be used for rewriting not only in logical propositions but also in any
type.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span><span>
</span></dt><dd><span>eq_rec =
</span><span class="ansi-bold">fun</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : A) (P : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) =&gt; eq_rect x P
     : </span><span class="ansi-bold">forall</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (x : A) (P : A</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>),
       P x</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> a : A, x</span><span> =</span><span> a</span><span> -&gt;</span><span> P a

Arguments </span><span class="ansi-fg-light-green">eq_rec</span><span> [A]%type_scope x P%function_scope f y e
  (where some original arguments have been renamed)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Extraction</span><span>.</span><span>
</span></dt><dd><span>[Loading ML file extraction_plugin.cmxs (using legacy method) ... done]
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Extraction</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span><span>
</span></dt><dd><span>(** val eq_rec : 'a1 -&gt; 'a2 -&gt; 'a1 -&gt; 'a2 **)

let eq_rec _ f _ =
  f
</span></dd>
</dl>
</div>
</div>
<p>An empty definition has no constructors, in that case also,
elimination on any sort is allowed.</p>
<p id="eliminaton-for-sprop">Inductive types in <span class="math notranslate nohighlight">\(\SProp\)</span> must have no constructors (i.e. be
empty) to be eliminated to produce relevant values.</p>
<p>Note that thanks to proof irrelevance elimination functions can be
produced for other types, for instance the elimination for a unit type
is the identity.</p>
<p id="type-of-branches"><strong>Type of branches.</strong>
Let <span class="math notranslate nohighlight">\(c\)</span> be a term of type <span class="math notranslate nohighlight">\(C\)</span>, we assume <span class="math notranslate nohighlight">\(C\)</span> is a type of constructor for an
inductive type <span class="math notranslate nohighlight">\(I\)</span>. Let <span class="math notranslate nohighlight">\(P\)</span> be a term that represents the property to be
proved. We assume <span class="math notranslate nohighlight">\(r\)</span> is the number of parameters and <span class="math notranslate nohighlight">\(s\)</span> is the number of
arguments.</p>
<p>We define a new type <span class="math notranslate nohighlight">\(\{c:C\}^P\)</span> which represents the type of the branch
corresponding to the <span class="math notranslate nohighlight">\(c:C\)</span> constructor.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
\{c:(I~q_1\ldots q_r\ t_1 \ldots t_s)\}^P &amp;\equiv (P~t_1\ldots ~t_s~c) \\
\{c:∀ x:T,~C\}^P &amp;\equiv ∀ x:T,~\{(c~x):C\}^P
\end{array}\end{split}\]</div>
<p>We write <span class="math notranslate nohighlight">\(\{c\}^P\)</span> for <span class="math notranslate nohighlight">\(\{c:C\}^P\)</span> with <span class="math notranslate nohighlight">\(C\)</span> the type of <span class="math notranslate nohighlight">\(c\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The following term in concrete syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>match t as l return P&#39; with
| nil _ =&gt; t1
| cons _ hd tl =&gt; t2
end
</pre></div>
</div>
<p>can be represented in abstract syntax as</p>
<div class="math notranslate nohighlight">
\[\case(t,P,f_1 | f_2 )\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
  P &amp; = &amp; λ l.~P^\prime\\
  f_1 &amp; = &amp; t_1\\
  f_2 &amp; = &amp; λ (hd:\nat).~λ (tl:\List~\nat).~t_2
\end{eqnarray*}</div><p>According to the definition:</p>
<div class="math notranslate nohighlight">
\[\{(\Nil~\nat)\}^P ≡ \{(\Nil~\nat) : (\List~\nat)\}^P ≡ (P~(\Nil~\nat))\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{rl}
\{(\cons~\nat)\}^P &amp; ≡\{(\cons~\nat) : (\nat→\List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~\{(\cons~\nat~n) : (\List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~∀ l:\List~\nat,~\{(\cons~\nat~n~l) : (\List~\nat)\}^P \\
&amp; ≡∀ n:\nat,~∀ l:\List~\nat,~(P~(\cons~\nat~n~l)).
\end{array}\end{split}\]</div>
<p>Given some <span class="math notranslate nohighlight">\(P\)</span> then <span class="math notranslate nohighlight">\(\{(\Nil~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate nohighlight">\(f_1\)</span>,
and <span class="math notranslate nohighlight">\(\{(\cons~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate nohighlight">\(f_2\)</span>.</p>
</div>
<p id="typing-rule"><strong>Typing rule.</strong>
Our very general destructor for inductive definitions has the
following typing rule</p>
<dl>
<dt id="inference-match">match</dt><dd><div class="math notranslate nohighlight">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
E[Γ] ⊢ c : (I~q_1 … q_r~t_1 … t_s ) \\%
\hspace{3em}%
E[Γ] ⊢ P : B \\%
\hspace{3em}%
[(I~q_1 … q_r)|B] \\%
\hspace{3em}%
(E[Γ] ⊢ f_i : \{(c_{p_i}~q_1 … q_r)\}^P)_{i=1… l}%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(c,P,f_1  |… |f_l ) : (P~t_1 … t_s~c)%
}\end{split}\]</div>
</dd>
</dl>
<p>provided <span class="math notranslate nohighlight">\(I\)</span> is an inductive type in a
definition <span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span> with <span class="math notranslate nohighlight">\(Γ_C = [c_1 :C_1 ;~…;~c_n :C_n ]\)</span> and
<span class="math notranslate nohighlight">\(c_{p_1} … c_{p_l}\)</span> are the only constructors of <span class="math notranslate nohighlight">\(I\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Below is a typing rule for the term shown in the previous example:</p>
<dl>
<dt id="inference-list-example">list example</dt><dd><div class="math notranslate nohighlight">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
  E[Γ] ⊢ t : (\List ~\nat) \\%
\hspace{3em}%
  E[Γ] ⊢ P : B \\%
\hspace{3em}%
  [(\List ~\nat)|B] \\%
\hspace{3em}%
  E[Γ] ⊢ f_1 : \{(\Nil ~\nat)\}^P \\%
\hspace{3em}%
  E[Γ] ⊢ f_2 : \{(\cons ~\nat)\}^P%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(t,P,f_1 |f_2 ) : (P~t)%
}\end{split}\]</div>
</dd>
</dl>
</div>
<p id="definition-of-reduction"><strong>Definition of ι-reduction.</strong>
We still have to define the ι-reduction in the general case.</p>
<p>An ι-redex is a term of the following form:</p>
<div class="math notranslate nohighlight">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_l )\]</div>
<p>with <span class="math notranslate nohighlight">\(c_{p_i}\)</span> the <span class="math notranslate nohighlight">\(i\)</span>-th constructor of the inductive type <span class="math notranslate nohighlight">\(I\)</span> with <span class="math notranslate nohighlight">\(r\)</span>
parameters.</p>
<p>The ι-contraction of this term is <span class="math notranslate nohighlight">\((f_i~a_1 … a_m )\)</span> leading to the
general reduction rule:</p>
<div class="math notranslate nohighlight">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_l ) \triangleright_ι (f_i~a_1 … a_m )\]</div>
</section>
</section>
<section id="fixpoint-definitions">
<span id="id9"></span><h3>Fixpoint definitions<a class="headerlink" href="#fixpoint-definitions" title="Permalink to this headline">¶</a></h3>
<p>The second operator for elimination is fixpoint definition. This
fixpoint may involve several mutually recursive definitions. The basic
concrete syntax for a recursive set of mutually recursive declarations
is (with <span class="math notranslate nohighlight">\(Γ_i\)</span> contexts):</p>
<div class="math notranslate nohighlight">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1~\with … \with~f_n (Γ_n ) :A_n :=t_n\]</div>
<p>The terms are obtained by projections from this set of declarations
and are written</p>
<div class="math notranslate nohighlight">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1~\with … \with~f_n (Γ_n ) :A_n :=t_n~\for~f_i\]</div>
<p>In the inference rules, we represent such a term by</p>
<div class="math notranslate nohighlight">
\[\Fix~f_i\{f_1 :A_1':=t_1' … f_n :A_n':=t_n'\}\]</div>
<p>with <span class="math notranslate nohighlight">\(t_i'\)</span> (resp. <span class="math notranslate nohighlight">\(A_i'\)</span>) representing the term <span class="math notranslate nohighlight">\(t_i\)</span> abstracted (resp.
generalized) with respect to the bindings in the context <span class="math notranslate nohighlight">\(Γ_i\)</span>, namely
<span class="math notranslate nohighlight">\(t_i'=λ Γ_i . t_i\)</span> and <span class="math notranslate nohighlight">\(A_i'=∀ Γ_i , A_i\)</span>.</p>
<section id="id10">
<h4>Typing rule<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>The typing rule is the expected one for a fixpoint.</p>
<dl>
<dt id="inference-Fix">Fix</dt><dd><div class="math notranslate nohighlight">
\[\frac{%
(E[Γ] ⊢ A_i : s_i )_{i=1… n}%
\hspace{3em}%
(E[Γ;~f_1 :A_1 ;~…;~f_n :A_n ] ⊢ t_i : A_i )_{i=1… n}%
}{%
E[Γ] ⊢ \Fix~f_i\{f_1 :A_1 :=t_1 … f_n :A_n :=t_n \} : A_i%
}\]</div>
</dd>
</dl>
<p>Any fixpoint definition cannot be accepted because non-normalizing
terms allow proofs of absurdity. The basic scheme of recursion that
should be allowed is the one needed for defining primitive recursive
functionals. In that case the fixpoint enjoys a special syntactic
restriction, namely one of the arguments belongs to an inductive type,
the function starts with a case analysis and recursive calls are done
on variables coming from patterns and representing subterms. For
instance in the case of natural numbers, a proof of the induction
principle of type</p>
<div class="math notranslate nohighlight">
\[∀ P:\nat→\Prop,~(P~\nO)→(∀ n:\nat,~(P~n)→(P~(\nS~n)))→ ∀ n:\nat,~(P~n)\]</div>
<p>can be represented by the term:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
λ P:\nat→\Prop.~λ f:(P~\nO).~λ g:(∀ n:\nat,~(P~n)→(P~(\nS~n))).\\
\Fix~h\{h:∀ n:\nat,~(P~n):=λ n:\nat.~\case(n,P,f | λp:\nat.~(g~p~(h~p)))\}
\end{array}\end{split}\]</div>
<p>Before accepting a fixpoint definition as being correctly typed, we
check that the definition is “guarded”. A precise analysis of this
notion can be found in <a class="reference internal" href="../../zebibliography.html#gim94" id="id11">[Gimenez94]</a>. The first stage is to precise on which
argument the fixpoint will be decreasing. The type of this argument
should be an inductive type. For doing this, the syntax of
fixpoints is extended and becomes</p>
<div class="math notranslate nohighlight">
\[\Fix~f_i\{f_1/k_1 :A_1:=t_1 … f_n/k_n :A_n:=t_n\}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_i\)</span> are positive integers. Each <span class="math notranslate nohighlight">\(k_i\)</span> represents the index of
parameter of <span class="math notranslate nohighlight">\(f_i\)</span>, on which <span class="math notranslate nohighlight">\(f_i\)</span> is decreasing. Each <span class="math notranslate nohighlight">\(A_i\)</span> should be a
type (reducible to a term) starting with at least <span class="math notranslate nohighlight">\(k_i\)</span> products
<span class="math notranslate nohighlight">\(∀ y_1 :B_1 ,~… ∀ y_{k_i} :B_{k_i} ,~A_i'\)</span> and <span class="math notranslate nohighlight">\(B_{k_i}\)</span> an inductive type.</p>
<p>Now in the definition <span class="math notranslate nohighlight">\(t_i\)</span>, if <span class="math notranslate nohighlight">\(f_j\)</span> occurs then it should be applied to
at least <span class="math notranslate nohighlight">\(k_j\)</span> arguments and the <span class="math notranslate nohighlight">\(k_j\)</span>-th argument should be
syntactically recognized as structurally smaller than <span class="math notranslate nohighlight">\(y_{k_i}\)</span>.</p>
<p>The definition of being structurally smaller is a bit technical. One
needs first to define the notion of <em>recursive arguments of a
constructor</em>. For an inductive definition <span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span>, if the
type of a constructor <span class="math notranslate nohighlight">\(c\)</span> has the form
<span class="math notranslate nohighlight">\(∀ p_1 :P_1 ,~… ∀ p_r :P_r,~∀ x_1:T_1,~… ∀ x_m :T_m,~(I_j~p_1 … p_r~t_1 … t_s )\)</span>,
then the recursive
arguments will correspond to <span class="math notranslate nohighlight">\(T_i\)</span> in which one of the <span class="math notranslate nohighlight">\(I_l\)</span> occurs.</p>
<p>The main rules for being structurally smaller are the following.
Given a variable <span class="math notranslate nohighlight">\(y\)</span> of an inductively defined type in a declaration
<span class="math notranslate nohighlight">\(\ind{r}{Γ_I}{Γ_C}\)</span> where <span class="math notranslate nohighlight">\(Γ_I\)</span> is <span class="math notranslate nohighlight">\([I_1 :A_1 ;~…;~I_k :A_k]\)</span>, and <span class="math notranslate nohighlight">\(Γ_C\)</span> is
<span class="math notranslate nohighlight">\([c_1 :C_1 ;~…;~c_n :C_n ]\)</span>, the terms structurally smaller than <span class="math notranslate nohighlight">\(y\)</span> are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((t~u)\)</span> and <span class="math notranslate nohighlight">\(λ x:U .~t\)</span> when <span class="math notranslate nohighlight">\(t\)</span> is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\case(c,P,f_1 … f_n)\)</span> when each <span class="math notranslate nohighlight">\(f_i\)</span> is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.
If <span class="math notranslate nohighlight">\(c\)</span> is <span class="math notranslate nohighlight">\(y\)</span> or is structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>, its type is an inductive
type <span class="math notranslate nohighlight">\(I_p\)</span> part of the inductive definition corresponding to <span class="math notranslate nohighlight">\(y\)</span>.
Each <span class="math notranslate nohighlight">\(f_i\)</span> corresponds to a type of constructor
<span class="math notranslate nohighlight">\(C_q ≡ ∀ p_1 :P_1 ,~…,∀ p_r :P_r ,~∀ y_1 :B_1 ,~… ∀ y_m :B_m ,~(I_p~p_1 … p_r~t_1 … t_s )\)</span>
and can consequently be written <span class="math notranslate nohighlight">\(λ y_1 :B_1' .~… λ y_m :B_m'.~g_i\)</span>. (<span class="math notranslate nohighlight">\(B_i'\)</span> is
obtained from <span class="math notranslate nohighlight">\(B_i\)</span> by substituting parameters for variables) the variables
<span class="math notranslate nohighlight">\(y_j\)</span> occurring in <span class="math notranslate nohighlight">\(g_i\)</span> corresponding to recursive arguments <span class="math notranslate nohighlight">\(B_i\)</span> (the
ones in which one of the <span class="math notranslate nohighlight">\(I_l\)</span> occurs) are structurally smaller than <span class="math notranslate nohighlight">\(y\)</span>.</p></li>
</ul>
<p>The following definitions are correct, we enter them using the <a class="reference internal" href="#coq:cmd.Fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>
command and show the internal representation.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>plus is defined
plus is recursively defined (guarded on 1st argument)
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">plus</span><span>.</span><span>
</span></dt><dd><span>plus =
fix plus (n m : nat) {</span><span class="ansi-bold">struct</span><span> n} : nat :=
  </span><span class="ansi-bold">match</span><span> n </span><span class="ansi-bold">with</span><span>
  | 0 =&gt; m
  | S p =&gt; S (plus p m)
  </span><span class="ansi-bold">end</span><span>
     : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> nat

Arguments </span><span class="ansi-fg-light-green">plus</span><span> (n m)%nat_scope
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">lgth</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">lgth</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">l'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>lgth is defined
lgth is recursively defined (guarded on 2nd argument)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">lgth</span><span>.</span><span>
</span></dt><dd><span>lgth =
fix lgth (A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) (l : list A) {</span><span class="ansi-bold">struct</span><span> l} : nat :=
  </span><span class="ansi-bold">match</span><span> l </span><span class="ansi-bold">with</span><span>
  | nil _ =&gt; 0
  | cons _ _ l' =&gt; S (lgth A l')
  </span><span class="ansi-bold">end</span><span>
     : </span><span class="ansi-bold">forall</span><span> A : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, list A</span><span> -&gt;</span><span> nat

Arguments </span><span class="ansi-fg-light-green">lgth</span><span> A%type_scope l
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">sizet</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">f</span><span>) := </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">sizef</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">consf</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">sizet</span><span> </span><span class="coqdoc-var">t</span><span>) (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd><span>sizet is defined
sizef is defined
sizet, sizef are recursively defined (guarded respectively on 1st,
1st arguments)
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">sizet</span><span>.</span><span>
</span></dt><dd><span>sizet =
fix sizet (t : tree) : nat :=
  </span><span class="ansi-bold">let</span><span> (f) := t</span><span class="ansi-bold"> in</span><span> S (sizef f)
with sizef (f : forest) : nat :=
  </span><span class="ansi-bold">match</span><span> f </span><span class="ansi-bold">with</span><span>
  | emptyf =&gt; 0
  | consf t f0 =&gt; plus (sizet t) (sizef f0)
  </span><span class="ansi-bold">end</span><span>
</span><span class="ansi-bold">for</span><span>
sizet
     : tree</span><span> -&gt;</span><span> nat

Arguments </span><span class="ansi-fg-light-green">sizet</span><span> t
</span></dd>
</dl>
</div>
</div>
</section>
<section id="reduction-rule">
<span id="id12"></span><h4>Reduction rule<a class="headerlink" href="#reduction-rule" title="Permalink to this headline">¶</a></h4>
<p>Let <span class="math notranslate nohighlight">\(F\)</span> be the set of declarations:
<span class="math notranslate nohighlight">\(f_1 /k_1 :A_1 :=t_1 …f_n /k_n :A_n:=t_n\)</span>.
The reduction for fixpoints is:</p>
<div class="math notranslate nohighlight">
\[(\Fix~f_i \{F\}~a_1 …a_{k_i}) ~\triangleright_ι~ \subst{t_i}{f_k}{\Fix~f_k \{F\}}_{k=1… n} ~a_1 … a_{k_i}\]</div>
<p>when <span class="math notranslate nohighlight">\(a_{k_i}\)</span> starts with a constructor. This last restriction is needed
in order to keep strong normalization and corresponds to the reduction
for primitive recursive operators. The following reductions are now
possible:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
\plus~(\nS~(\nS~\nO))~(\nS~\nO)~&amp; \trii &amp; \nS~(\plus~(\nS~\nO)~(\nS~\nO))\\
                                &amp; \trii &amp; \nS~(\nS~(\plus~\nO~(\nS~\nO)))\\
                                &amp; \trii &amp; \nS~(\nS~(\nS~\nO))\\
\end{eqnarray*}</div><p id="mutual-induction"><strong>Mutual induction</strong></p>
<p>The principles of mutual induction can be automatically generated
using the Scheme command described in Section <a class="reference internal" href="../../proofs/writing-proofs/reasoning-inductives.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a>.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="records.html" class="btn btn-neutral float-left" title="Record types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="coinductive.html" class="btn btn-neutral float-right" title="Coinductive types and corecursive functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2021, Inria, CNRS and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  




  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Other versions</span>
      v: 8.18.0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://coq.github.io/doc/master/refman/">dev</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/current/refman/">stable</a></dd>
        
          <dd><a href="https://coq.github.io/doc/v8.18/refman/">8.18</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.17.1/refman/">8.17</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.16.1/refman/">8.16</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.15.2/refman/">8.15</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.14.1/refman/">8.14</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.13.2/refman/">8.13</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.12.2/refman/">8.12</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.11.2/refman/">8.11</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.10.2/refman/">8.10</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.9.1/refman/">8.9</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.8.2/refman/">8.8</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.7.2/refman/">8.7</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.6.1/refman/">8.6</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.5pl3/refman/">8.5</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.4pl6/refman/">8.4</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.3pl5/refman/">8.3</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.2pl3/refman/">8.2</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.1pl6/refman/">8.1</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.0/doc/">8.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://github.com/coq/coq/releases/download/V8.18.0/coq-8.18.0-reference-manual.pdf">PDF</a></dd>
        
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>