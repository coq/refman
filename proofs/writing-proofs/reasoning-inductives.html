<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reasoning with inductive types &mdash; Coq 8.18.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/ansi.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/coqdoc.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/notations.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/pre-text.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/notations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The SSReflect proof language" href="../../proof-engine/ssreflect-proof-language.html" />
    <link rel="prev" title="Reasoning with equalities" href="equality.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Coq
          </a>
              <div class="version">
                8.18.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction and Contents</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Specification language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../language/core/index.html">Core language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/basic.html">Basic notions and conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/basic.html#syntax-and-lexical-conventions">Syntax and lexical conventions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/basic.html#syntax-conventions">Syntax conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/basic.html#lexical-conventions">Lexical conventions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/basic.html#essential-vocabulary">Essential vocabulary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/basic.html#settings">Settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/basic.html#attributes">Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/basic.html#flags-options-and-tables">Flags, Options and Tables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/sorts.html">Sorts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/assumptions.html">Functions and assumptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/assumptions.html#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/assumptions.html#functions-fun-and-function-types-forall">Functions (fun) and function types (forall)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/assumptions.html#function-application">Function application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/assumptions.html#assumptions">Assumptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/definitions.html">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/definitions.html#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/definitions.html#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/definitions.html#top-level-definitions">Top-level definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/definitions.html#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/conversion.html">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#conversion">α-conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#delta-reduction-sect">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#id4">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#id7">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#proof-irrelevance">Proof Irrelevance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/conversion.html#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/cic.html">Typing rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/cic.html#the-terms">The terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/cic.html#id6">Typing rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/cic.html#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/variants.html">Variants and the <code class="docutils literal notranslate"><span class="pre">match</span></code> construct</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/variants.html#id1">Variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/variants.html#private-matching-inductive-types">Private (matching) inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/variants.html#definition-by-cases-match">Definition by cases: match</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/records.html">Record types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/records.html#defining-record-types">Defining record types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/records.html#constructing-records">Constructing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/records.html#accessing-fields-projections">Accessing fields (projections)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/records.html#settings-for-printing-records">Settings for printing records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/records.html#primitive-projections">Primitive Projections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/records.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/records.html#compatibility-constants-for-projections">Compatibility Constants for Projections</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/inductive.html">Inductive types and recursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/inductive.html#inductive-types">Inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#simple-indexed-inductive-types">Simple indexed inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#parameterized-inductive-types">Parameterized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/inductive.html#recursive-functions-fix">Recursive functions: fix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/inductive.html#top-level-recursive-functions">Top-level recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/inductive.html#theory-of-inductive-definitions">Theory of inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#well-formed-inductive-definitions">Well-formed inductive definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#destructors">Destructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/inductive.html#fixpoint-definitions">Fixpoint definitions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/coinductive.html">Coinductive types and corecursive functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/coinductive.html#coinductive-types">Coinductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/coinductive.html#caveat">Caveat</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/coinductive.html#co-recursive-functions-cofix">Co-recursive functions: cofix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/coinductive.html#top-level-definitions-of-corecursive-functions">Top-level definitions of corecursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/sections.html">Sections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/sections.html#typing-rules-used-at-the-end-of-a-section">Typing rules used at the end of a section</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/modules.html">The Module System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/modules.html#modules-and-module-types">Modules and module types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/modules.html#using-modules">Using modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/core/modules.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/modules.html#typing-modules">Typing Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/modules.html#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/modules.html#controlling-the-scope-of-commands-with-locality-attributes">Controlling the scope of commands with locality attributes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/core/primitive.html">Primitive objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/primitive.html#primitive-integers">Primitive Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/primitive.html#primitive-floats">Primitive Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/core/primitive.html#primitive-arrays">Primitive Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/universe-polymorphism.html">Polymorphic Universes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphic-monomorphic">Polymorphic, Monomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#cumulative-noncumulative">Cumulative, NonCumulative</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#specifying-cumulativity">Specifying cumulativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#cumulativity-weak-constraints">Cumulativity Weak Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#global-and-local-universes">Global and local universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#conversion-and-unification">Conversion and unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#minimization">Minimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#explicit-universes">Explicit Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#printing-universes">Printing universes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/universe-polymorphism.html#polymorphic-definitions">Polymorphic definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/universe-polymorphism.html#universe-polymorphism-and-sections">Universe polymorphism and sections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/sprop.html">SProp (proof irrelevant propositions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#basic-constructs">Basic constructs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#encodings-for-strict-propositions">Encodings for strict propositions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#definitional-uip">Definitional UIP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/sprop.html#non-termination-with-uip">Non Termination with UIP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/sprop.html#lack-of-tactic-support">Lack of tactic support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../language/extensions/index.html">Language extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../language/extensions/evars.html">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/evars.html#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/evars.html#e-tactics-that-can-create-existential-variables">e* tactics that can create existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/evars.html#automatic-resolution-of-existential-variables">Automatic resolution of existential variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/evars.html#explicit-display-of-existential-instances-for-pretty-printing">Explicit display of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/evars.html#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/extensions/implicit-arguments.html">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments">Maximal and non-maximal insertion of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#trailing-implicit-arguments">Trailing Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#combining-manual-declaration-and-automatic-declaration">Combining manual declaration and automatic declaration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#displaying-implicit-arguments">Displaying implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#displaying-implicit-arguments-when-pretty-printing">Displaying implicit arguments when pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#implicit-types-of-variables">Implicit types of variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/implicit-arguments.html#implicit-generalization">Implicit generalization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/extensions/match.html">Extended pattern matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#conventions-about-unused-pattern-matching-variables">Conventions about unused pattern-matching variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#nested-patterns">Nested patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/match.html#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/match.html#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user-extensions/syntax-extensions.html">Syntax extensions and notation scopes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#basic-notations">Basic notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#precedences-and-associativity">Precedences and associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#complex-notations">Complex notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#simple-factorization-rules">Simple factorization rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#use-of-notations-for-printing">Use of notations for printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-infix-command">The Infix command</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#reserving-notations">Reserving notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#simultaneous-definition-of-terms-and-notations">Simultaneous definition of terms and notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#enabling-and-disabling-notations">Enabling and disabling notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#displaying-information-about-notations">Displaying information about notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#locating-notations">Locating notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#inheritance-of-the-properties-of-arguments-of-constants-bound-to-a-notation">Inheritance of the properties of arguments of constants bound to a notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-and-binders">Notations and binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-with-recursive-patterns">Notations with recursive patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notations-with-recursive-patterns-involving-binders">Notations with recursive patterns involving binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#predefined-entries">Predefined entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#custom-entries">Custom entries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#syntax">Syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notation-scopes">Notation scopes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#global-interpretation-rules-for-notations">Global interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#local-interpretation-rules-for-notations">Local interpretation rules for notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-type-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">type_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#the-function-scope-notation-scope">The <code class="docutils literal notranslate"><span class="pre">function_scope</span></code> notation scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#notation-scopes-used-in-the-standard-library-of-coq">Notation scopes used in the standard library of Coq</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#displaying-information-about-scopes">Displaying information about scopes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#numbers-and-strings">Numbers and strings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#number-notations">Number notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#string-notations">String notations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../user-extensions/syntax-extensions.html#tactic-notations">Tactic Notations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/extensions/arguments-command.html">Setting properties of a function's arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#manual-declaration-of-implicit-arguments">Manual declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#binding-arguments-to-scopes">Binding arguments to scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#effects-of-arguments-on-unfolding">Effects of <code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code> on unfolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/arguments-command.html#bidirectionality-hints">Bidirectionality hints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/implicit-coercions.html">Implicit Coercions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#general-presentation">General Presentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercion-classes">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#id1">Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#reversible-coercions">Reversible Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#identity-coercions">Identity Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#inheritance-graph">Inheritance Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#id2">Coercion Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#displaying-available-coercions">Displaying Available Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#activating-the-printing-of-coercions">Activating the Printing of Coercions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#classes-as-records">Classes as Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercions-and-sections">Coercions and Sections</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#coercions-and-modules">Coercions and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/implicit-coercions.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/type-classes.html">Typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#typeclass-and-instance-declarations">Typeclass and instance declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#binding-typeclasses">Binding typeclasses</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#parameterized-instances">Parameterized instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#sections-and-contexts">Sections and contexts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#building-hierarchies">Building hierarchies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#superclasses">Superclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#substructures">Substructures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/type-classes.html#command-summary">Command summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#typeclasses-transparent-typeclasses-opaque">Typeclasses Transparent, Typeclasses Opaque</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#settings">Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/type-classes.html#typeclasses-eauto">Typeclasses eauto</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../language/extensions/canonical.html">Canonical Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/canonical.html#declaration-of-canonical-structures">Declaration of canonical structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/canonical.html#notation-overloading">Notation overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/canonical.html#derived-canonical-structures">Derived Canonical Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/extensions/canonical.html#hierarchy-of-structures">Hierarchy of structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/extensions/canonical.html#compact-declaration-of-canonical-structures">Compact declaration of Canonical Structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/program.html">Program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#elaborating-programs">Elaborating programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#syntactic-control-over-equalities">Syntactic control over equalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-definition">Program Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-fixpoint">Program Fixpoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/program.html#program-lemma">Program Lemma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#solving-obligations">Solving obligations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/program.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/vernacular-commands.html">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#displaying">Displaying</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#query-commands">Query commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#requests-to-the-environment">Requests to the environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#printing-flags">Printing flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#loading-files">Loading files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#compiled-files">Compiled files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#load-paths">Load paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#extra-dependencies">Extra Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#backtracking">Backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#quitting-and-debugging">Quitting and debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#controlling-display">Controlling display</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#printing-constructions-in-full">Printing constructions in full</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#controlling-typing-flags">Controlling Typing Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#internal-registration-commands">Internal registration commands</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#exposing-constants-to-ocaml-libraries">Exposing constants to OCaml libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#inlining-hints-for-the-fast-reduction-machines">Inlining hints for the fast reduction machines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#registering-primitive-operations">Registering primitive operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Proofs</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Basic proof writing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="proof-mode.html">Proof mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#proof-state">Proof State</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#entering-and-exiting-proof-mode">Entering and exiting proof mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#proof-using-options">Proof using options</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#name-a-set-of-section-hypotheses-for-proof-using">Name a set of section hypotheses for <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#proof-modes">Proof modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#managing-goals">Managing goals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#focusing-goals">Focusing goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#shelving-goals">Shelving goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#reordering-goals">Reordering goals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#proving-a-subgoal-as-a-separate-lemma-abstract">Proving a subgoal as a separate lemma: abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#requesting-information">Requesting information</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#showing-differences-between-proof-steps">Showing differences between proof steps</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#how-to-enable-diffs">How to enable diffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#how-diffs-are-calculated">How diffs are calculated</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof-mode.html#show-proof-differences">&quot;Show Proof&quot; differences</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#delaying-solving-unification-constraints">Delaying solving unification constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#proof-maintenance">Proof maintenance</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#controlling-proof-mode">Controlling proof mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="proof-mode.html#controlling-memory-usage">Controlling memory usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/tactics.html">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#common-elements-of-tactics">Common elements of tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#reserved-keywords">Reserved keywords</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#invocation-of-tactics">Invocation of tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#intro-patterns">Intro patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/tactics.html#occurrence-clauses">Occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#applying-theorems">Applying theorems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#classical-tactics">Classical tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/tactics.html#performance-oriented-tactic-variants">Performance-oriented tactic variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="equality.html">Reasoning with equalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="equality.html#tactics-for-simple-equalities">Tactics for simple equalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="equality.html#rewriting-with-leibniz-and-setoid-equality">Rewriting with Leibniz and setoid equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="equality.html#rewriting-with-definitional-equality">Rewriting with definitional equality</a></li>
<li class="toctree-l3"><a class="reference internal" href="equality.html#applying-conversion-rules">Applying conversion rules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="equality.html#fast-reduction-tactics-vm-compute-and-native-compute">Fast reduction tactics: vm_compute and native_compute</a></li>
<li class="toctree-l4"><a class="reference internal" href="equality.html#computing-in-a-term-eval-and-eval">Computing in a term: eval and Eval</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="equality.html#controlling-reduction-strategies-and-the-conversion-algorithm">Controlling reduction strategies and the conversion algorithm</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Reasoning with inductive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#applying-constructors">Applying constructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#case-analysis">Case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#induction">Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality-of-inductive-types">Equality of inductive types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#helper-tactics">Helper tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#generation-of-induction-principles-with-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#automatic-declaration-of-schemes">Automatic declaration of schemes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#combined-scheme">Combined Scheme</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#generation-of-inversion-principles-with-derive-inversion">Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-of-dependent-destruction-dependent-induction">Examples of <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code> / <code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-larger-example">A larger example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#getting-started">Getting started</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#gallina-extensions">Gallina extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#wildcards">Wildcards</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#definitions">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#the-defective-tactics">The defective tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#discharge">Discharge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#selectors">Selectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#localization">Localization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#structure">Structure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#rewriting">Rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#remarks-and-examples">Remarks and examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#examples">Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-assumptions">Interpreting assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#items-and-switches">Items and switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#tactics">Tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#tacticals">Tacticals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#commands">Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ssreflect-proof-language.html#settings">Settings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../automatic-tactics/index.html">Automatic solvers and programmable tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../automatic-tactics/logic.html">Solvers for logic and equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/micromega.html">Micromega: solvers for arithmetic goals over ordered rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><code class="docutils literal notranslate"><span class="pre">lra</span></code>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#lia-a-tactic-for-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">lia</span></code>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#high-level-view-of-lia">High level view of <code class="docutils literal notranslate"><span class="pre">lia</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/micromega.html#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#nra-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">nra</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><code class="docutils literal notranslate"><span class="pre">nia</span></code>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#psatz-a-proof-procedure-for-non-linear-arithmetic"><code class="docutils literal notranslate"><span class="pre">psatz</span></code>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/micromega.html#zify-pre-processing-of-arithmetic-goals"><code class="docutils literal notranslate"><span class="pre">zify</span></code>: pre-processing of arithmetic goals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/ring.html">ring and field: solvers for polynomial and rational equations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#the-variables-map">The variables map</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#how-does-it-work">How does it work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#history-of-ring">History of ring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/ring.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/nsatz.html">Nsatz: a solver for equalities in integral domains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/nsatz.html#more-about-nsatz">More about <code class="docutils literal notranslate"><span class="pre">nsatz</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../automatic-tactics/auto.html">Programmable proof search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../automatic-tactics/auto.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../automatic-tactics/auto.html#hint-databases">Hint databases</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../automatic-tactics/auto.html#creating-hint-databases">Creating hint databases</a></li>
<li class="toctree-l4"><a class="reference internal" href="../automatic-tactics/auto.html#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../automatic-tactics/auto.html#creating-hints">Creating Hints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../automatic-tactics/auto.html#hint-locality">Hint locality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../automatic-tactics/auto.html#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/generalized-rewriting.html">Generalized rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#introduction-to-generalized-rewriting">Introduction to generalized rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#relations-and-morphisms">Relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#adding-new-relations-and-morphisms">Adding new relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations">Rewriting and nonreflexive relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-and-nonsymmetric-relations">Rewriting and nonsymmetric relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-in-ambiguous-setoid-contexts">Rewriting in ambiguous setoid contexts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-with-type-valued-relations">Rewriting with <code class="docutils literal notranslate"><span class="pre">Type</span></code> valued relations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#declaring-rewrite-relations">Declaring rewrite relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#commands-and-tactics">Commands and tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#first-class-setoids-and-morphisms">First class setoids and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#tactics-enabled-on-user-provided-relations">Tactics enabled on user provided relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#printing-relations-and-morphisms">Printing relations and morphisms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#deprecated-syntax-and-backward-incompatibilities">Deprecated syntax and backward incompatibilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#extensions">Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#rewriting-under-binders">Rewriting under binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#subrelations">Subrelations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#constant-unfolding">Constant unfolding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/generalized-rewriting.html#strategies-for-rewriting">Strategies for rewriting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#usage">Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/generalized-rewriting.html#definitions">Definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../creating-tactics/index.html">Creating new tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ltac.html">Ltac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#values">Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#syntactic-values">Syntactic values</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#substitution">Substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#local-definitions-let">Local definitions: let</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#function-construction-and-application">Function construction and application</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#tactics-in-terms">Tactics in terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#goal-selectors">Goal selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#processing-multiple-goals">Processing multiple goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#branching-and-backtracking">Branching and backtracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#control-flow">Control flow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#sequence">Sequence: ;</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#do-loop">Do loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#repeat-loop">Repeat loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#catching-errors-try">Catching errors: try</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#conditional-branching-tryif">Conditional branching: tryif</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#alternatives">Alternatives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#branching-with-backtracking">Branching with backtracking: +</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#local-application-of-tactics">Local application of tactics: [&gt; ... ]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#first-tactic-to-succeed">First tactic to succeed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#solving">Solving</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#first-tactic-to-make-progress">First tactic to make progress: ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#detecting-progress">Detecting progress</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#success-and-failure">Success and failure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-success-assert-succeeds">Checking for success: assert_succeeds</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-failure-assert-fails">Checking for failure: assert_fails</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#failing">Failing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#soft-cut-once">Soft cut: once</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-for-a-single-success-exactly-once">Checking for a single success: exactly_once</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#manipulating-values">Manipulating values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#pattern-matching-on-terms-match">Pattern matching on terms: match</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#pattern-matching-on-goals-and-hypotheses-match-goal">Pattern matching on goals and hypotheses: match goal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#filling-a-term-context">Filling a term context</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#generating-fresh-hypothesis-names">Generating fresh hypothesis names</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#computing-in-a-term-eval">Computing in a term: eval</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#getting-the-type-of-a-term">Getting the type of a term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#manipulating-untyped-terms-type-term">Manipulating untyped terms: type_term</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#counting-goals-numgoals">Counting goals: numgoals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#testing-boolean-expressions-guard">Testing boolean expressions: guard</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#checking-properties-of-terms">Checking properties of terms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#timing">Timing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timeout">Timeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timing-a-tactic">Timing a tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#timing-a-tactic-that-evaluates-to-a-term-time-constr">Timing a tactic that evaluates to a term: time_constr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#print-identity-tactic-idtac">Print/identity tactic: idtac</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#tactic-toplevel-definitions">Tactic toplevel definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#defining-ltac-symbols">Defining <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#printing-ltac-tactics">Printing <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#examples-of-using-ltac">Examples of using <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#proof-that-the-natural-numbers-have-at-least-two-elements">Proof that the natural numbers have at least two elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#proving-that-a-list-is-a-permutation-of-a-second-list">Proving that a list is a permutation of a second list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#deciding-intuitionistic-propositional-logic">Deciding intuitionistic propositional logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#deciding-type-isomorphisms">Deciding type isomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac.html#debugging-ltac-tactics">Debugging <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#backtraces">Backtraces</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#tracing-execution">Tracing execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#interactive-debugger">Interactive debugger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#profiling-ltac-tactics">Profiling <code class="docutils literal notranslate"><span class="pre">L</span></code><sub>tac</sub> tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac.html#run-time-optimization-tactic">Run-time optimization tactic</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../proof-engine/ltac2.html">Ltac2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#general-design">General design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#ml-component">ML component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#type-syntax">Type Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#type-declarations">Type declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#term-syntax">Term Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac2-definitions">Ltac2 Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#printing-ltac2-tactics">Printing Ltac2 tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#reduction">Reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#typing">Typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#effects">Effects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#meta-programming">Meta-programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#id3">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#quotations">Quotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#term-antiquotations">Term Antiquotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-over-terms">Match over terms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-over-goals">Match over goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#match-on-values">Match on values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#notations">Notations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#abbreviations">Abbreviations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#defining-tactics">Defining tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#syntactic-classes">Syntactic classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#evaluation">Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#debug">Debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#compatibility-layer-with-ltac1">Compatibility layer with Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac1-from-ltac2">Ltac1 from Ltac2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#ltac2-from-ltac1">Ltac2 from Ltac1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#switching-between-ltac-languages">Switching between Ltac languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../proof-engine/ltac2.html#transition-from-ltac1">Transition from Ltac1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#syntax-changes">Syntax changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#tactic-delay">Tactic delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#variable-binding">Variable binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../proof-engine/ltac2.html#exception-catching">Exception catching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using Coq</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../using/libraries/index.html">Libraries and plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../language/coq-library.html">The Coq library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../language/coq-library.html#the-prelude">The prelude</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#notations">Notations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#logic">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#datatypes">Datatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#specification">Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#basic-arithmetic">Basic Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#well-founded-recursion">Well-founded recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#accessing-the-type-level">Accessing the Type level</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#tactics">Tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/coq-library.html#the-standard-library">The standard library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#survey">Survey</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#peanos-arithmetic-nat">Peano’s arithmetic (nat)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#notations-for-integer-arithmetic">Notations for integer arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#real-numbers-library">Real numbers library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#list-library">List library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../language/coq-library.html#floats-library">Floats library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../language/coq-library.html#users-contributions">Users’ contributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/extraction.html">Program extraction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#extraction-options">Extraction Options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#additional-settings">Additional settings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#differences-between-coq-and-ml-type-systems">Differences between Coq and ML type systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/extraction.html#some-examples">Some examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/extraction.html#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/miscellaneous-extensions.html">Program derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/libraries/funind.html">Functional induction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#advanced-recursive-functions">Advanced recursive functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/funind.html#generation-of-induction-principles-with-functional-scheme">Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Functional</span></code> <code class="docutils literal notranslate"><span class="pre">Scheme</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/libraries/writing.html">Writing Coq libraries and plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/libraries/writing.html#deprecating-library-objects-or-tactics">Deprecating library objects or tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/tools/index.html">Command-line and graphical tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/utilities.html">Building Coq Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#coq-configuration-basics">Coq configuration basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#installing-coq-and-coq-packages-with-opam">Installing Coq and Coq packages with opam</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#setup-for-working-on-your-own-projects">Setup for working on your own projects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-project-with-coqproject-overview">Building a project with _CoqProject (overview)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#logical-paths-and-the-load-path">Logical paths and the load path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#modifying-multiple-interdependent-projects-at-the-same-time">Modifying multiple interdependent projects at the same time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#installed-and-uninstalled-packages">Installed and uninstalled packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#upgrading-to-a-new-version-of-coq">Upgrading to a new version of Coq</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-coq-project-with-coq-makefile-details">Building a Coq project with coq_makefile (details)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/utilities.html#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#building-a-coq-project-with-dune">Building a Coq project with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#coqdep-computing-module-dependencies">coqdep: Computing Module dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#split-compilation-of-native-computation-files">Split compilation of native computation files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#using-coq-as-a-library">Using Coq as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#embedded-coq-phrases-inside-latex-documents">Embedded Coq phrases inside <span class="smallcaps">LaTeX</span> documents</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/utilities.html#man-pages">Man pages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/coq-commands.html">Coq commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#interactive-use-coqtop">Interactive use (coqtop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#batch-compilation-coqc">Batch compilation (coqc)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#customization-at-launch-time">Customization at launch time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#command-parameters">Command parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#coqrc-start-up-script"><code class="docutils literal notranslate"><span class="pre">coqrc</span></code> start up script</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#environment-variables">Environment variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coq-commands.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#compiled-interfaces-produced-using-vos">Compiled interfaces (produced using <code class="docutils literal notranslate"><span class="pre">-vos</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coq-commands.html#compiled-libraries-checker-coqchk">Compiled libraries checker (coqchk)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/tools/coqdoc.html">Documenting Coq files with coqdoc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#principles">Principles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#coq-material-inside-documentation">Coq material inside documentation.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#pretty-printing">Pretty-printing.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#lists">Lists.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#rules">Rules.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#emphasis">Emphasis.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#escaping-to-latex-and-html">Escaping to <span class="smallcaps">LaTeX</span> and HTML.</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#verbatim">Verbatim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#hyperlinks">Hyperlinks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#hiding-showing-parts-of-the-source">Hiding / Showing parts of the source</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../using/tools/coqdoc.html#command-line-options">Command line options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../using/tools/coqdoc.html#the-coqdoc-latex-style-file">The coqdoc <span class="smallcaps">LaTeX</span> style file</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../practical-tools/coqide.html">CoqIDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#managing-files-and-buffers-basic-editing">Managing files and buffers, basic editing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#running-coq-scripts">Running Coq scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#asynchronous-mode">Asynchronous mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#commands-and-templates">Commands and templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#queries">Queries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#customizations">Customizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#preferences">Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#key-bindings">Key bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#using-unicode-symbols">Using Unicode symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#displaying-unicode-symbols">Displaying Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#bindings-for-input-of-unicode-symbols">Bindings for input of Unicode symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#adding-custom-bindings">Adding custom bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#character-encoding-for-saved-files">Character encoding for saved files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../practical-tools/coqide.html#debugger">Debugger</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#breakpoints">Breakpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#call-stack-and-variables">Call Stack and Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../practical-tools/coqide.html#supported-use-cases">Supported use cases</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#proof-annotations">Proof annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#automatic-suggestion-of-proof-annotations">Automatic suggestion of proof annotations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#proof-blocks-and-error-resilience">Proof blocks and error resilience</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#caveats">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#interactive-mode">Interactive mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#id3">Caveats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#batch-mode">Batch mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../addendum/parallel-proof-processing.html#limiting-the-number-of-parallel-workers">Limiting the number of parallel workers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/history-and-changes/index.html">History and recent changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../history.html">Early history of Coq</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#historical-roots">Historical roots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-1-to-5">Versions 1 to 5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-1">Version 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-2">Version 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-3">Version 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-4">Version 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-5">Version 5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-6">Versions 6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-1">Version 6.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-2">Version 6.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#version-6-3">Version 6.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../history.html#versions-7">Versions 7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-0-and-7-1">Details of changes in 7.0 and 7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-2">Details of changes in 7.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-3">Details of changes in 7.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../history.html#details-of-changes-in-7-4">Details of changes in 7.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changes.html">Recent changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-18">Version 8.18</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#summary-of-changes">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-18-0">Changes in 8.18.0</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-17">Version 8.17</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id141">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-17-0">Changes in 8.17.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-17-1">Changes in 8.17.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-16">Version 8.16</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id295">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-16-0">Changes in 8.16.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-16-1">Changes in 8.16.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-15">Version 8.15</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id458">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-0">Changes in 8.15.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-1">Changes in 8.15.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-15-2">Changes in 8.15.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-14">Version 8.14</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id686">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-14-0">Changes in 8.14.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-14-1">Changes in 8.14.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-13">Version 8.13</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id882">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-beta1">Changes in 8.13+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-0">Changes in 8.13.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-1">Changes in 8.13.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-13-2">Changes in 8.13.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-12">Version 8.12</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1046">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-beta1">Changes in 8.12+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-0">Changes in 8.12.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-1">Changes in 8.12.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-12-2">Changes in 8.12.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-11">Version 8.11</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1352">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-beta1">Changes in 8.11+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-0">Changes in 8.11.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-1">Changes in 8.11.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-11-2">Changes in 8.11.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-10">Version 8.10</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1490">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#other-changes-in-8-10-beta1">Other changes in 8.10+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-beta2">Changes in 8.10+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-beta3">Changes in 8.10+beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-0">Changes in 8.10.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-1">Changes in 8.10.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-10-2">Changes in 8.10.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-9">Version 8.9</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1637">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-9-beta1">Details of changes in 8.9+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-8-0">Changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#changes-in-8-8-1">Changes in 8.8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-8">Version 8.8</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1639">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-beta1">Details of changes in 8.8+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-0">Details of changes in 8.8.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-1">Details of changes in 8.8.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-8-2">Details of changes in 8.8.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-7">Version 8.7</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1640">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#potential-compatibility-issues">Potential compatibility issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-beta1">Details of changes in 8.7+beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-beta2">Details of changes in 8.7+beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-0">Details of changes in 8.7.0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-1">Details of changes in 8.7.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-7-2">Details of changes in 8.7.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-6">Version 8.6</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1641">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#potential-sources-of-incompatibilities">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6beta1">Details of changes in 8.6beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6">Details of changes in 8.6</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-6-1">Details of changes in 8.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-5">Version 8.5</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1642">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1643">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta1">Details of changes in 8.5beta1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta2">Details of changes in 8.5beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5beta3">Details of changes in 8.5beta3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5">Details of changes in 8.5</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl1">Details of changes in 8.5pl1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl2">Details of changes in 8.5pl2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-5pl3">Details of changes in 8.5pl3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-4">Version 8.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1644">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1646">Potential sources of incompatibilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4beta">Details of changes in 8.4beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4beta2">Details of changes in 8.4beta2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-4">Details of changes in 8.4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-3">Version 8.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1647">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-2">Version 8.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1648">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1649">Details of changes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-1">Version 8.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1650">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1beta">Details of changes in 8.1beta</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1gamma">Details of changes in 8.1gamma</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-1">Details of changes in 8.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../changes.html#version-8-0">Version 8.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#id1651">Summary of changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0beta-old-syntax">Details of changes in 8.0beta old syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0beta-new-syntax">Details of changes in 8.0beta new syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../changes.html#details-of-changes-in-8-0">Details of changes in 8.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-attrindex.html">Attribute index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coq-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../genindex.html">General index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zebibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Coq</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Basic proof writing</a> &raquo;</li>
      <li>Reasoning with inductive types</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proofs/writing-proofs/reasoning-inductives.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<section id="reasoning-with-inductive-types">
<h1>Reasoning with inductive types<a class="headerlink" href="#reasoning-with-inductive-types" title="Permalink to this headline">¶</a></h1>
<section id="applying-constructors">
<h2>Applying constructors<a class="headerlink" href="#applying-constructors" title="Permalink to this headline">¶</a></h2>
<p>The tactics presented here specialize <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and
<a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> to constructors of inductive types.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.constructor">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>First does <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">repeat</span></span></span> <span><span><span class="pre">intro;</span></span></span> <span><span><span class="pre">hnf</span></span></span></span></code> on the goal.  If the result is an inductive
type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>, then apply the appropriate constructor(s), and otherwise fail.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a></span></code> is specified and has the
value <code class="docutils literal notranslate"><span class="pre">i</span></code>, it uses <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">apply</span></span></span> <span><span><span class="pre">c</span></span><sub><span class="pre">i</span></sub></span></span></code>, where <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">c</span></span><sub><span class="pre">i</span></sub></span></span></code> is the i-th constructor
of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>.  If not specified, the tactic tries all the constructors,
which can result in more than one success (e.g. for <code class="docutils literal notranslate"><span class="pre">\/</span></code>) when using
backtracking tactics such as <code class="docutils literal notranslate"><span class="pre">constructor;</span> <span class="pre">...</span></code>.  See <a class="reference internal" href="../../proof-engine/ltac.html#coq:tacn.ltac-seq" title="ltac-seq"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ltac-seq</span></code></a>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>If specified, the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">apply</span></span></span></span></code> is done as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">apply</span></span></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The terms in <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><code class="xref std std-token docutils literal notranslate"><span class="pre">bindings</span></code></a> are checked in the context
where constructor is executed and not in the context where <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
is executed (the introductions are not taken into account).</p>
</div>
</dd>
</dl>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-an-inductive-product">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">inductive</span></span></span> <span><span><span class="pre">product.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-an-inductive-product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-enough-constructors">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">enough</span></span></span> <span><span><span class="pre">constructors.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-enough-constructors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.The-type-has-no-constructors">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">The</span></span></span> <span><span><span class="pre">type</span></span></span> <span><span><span class="pre">has</span></span></span> <span><span><span class="pre">no</span></span></span> <span><span><span class="pre">constructors.</span></span></span></span></span><a class="headerlink" href="#coq:exn.The-type-has-no-constructors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.split">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">split</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span><span><span class="pre">1</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> when the
conclusion is an inductive type with a single constructor.  The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>
specify any parameters required for the constructor. It is
typically used to split conjunctions in the conclusion such as <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code> into
two new goals <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.exists">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">exists</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#coq:tacn.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span><span><span class="pre">1</span></span></span> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span><sub><span class="pre">i</span></sub></span></a></span></code> for each set of bindings
(or just <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span><span><span class="pre">1</span></span></span></span></code> if there are no <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>)
when the conclusion is an
inductive type with a single constructor.  It is typically used on
existential quantifications in the form <code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x.</span></code></p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-an-inductive-goal-with-1-constructor">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">inductive</span></span></span> <span><span><span class="pre">goal</span></span></span> <span><span><span class="pre">with</span></span></span> <span><span><span class="pre">1</span></span></span> <span><span><span class="pre">constructor.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-an-inductive-goal-with-1-constructor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.left">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">left</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.left" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.right">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">right</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.right" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics apply only if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has two constructors, for
instance in the case of a disjunction <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code>.
Then they are respectively equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span><span><span class="pre">1</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">constructor</span></span></span> <span><span><span class="pre">2</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-an-inductive-goal-with-2-constructors">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">inductive</span></span></span> <span><span><span class="pre">goal</span></span></span> <span><span><span class="pre">with</span></span></span> <span><span><span class="pre">2</span></span></span> <span><span><span class="pre">constructors.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-an-inductive-goal-with-2-constructors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.econstructor">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">econstructor</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-nat_or_var"><span class="hole"><span class="pre">nat_or_var</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.econstructor" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.eexists">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eexists</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eexists" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.esplit">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">esplit</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.esplit" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.eleft">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eleft</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eleft" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:tacn.eright">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eright</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eright" title="Permalink to this definition">¶</a></dt>
<dd><p>These tactics behave like <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a>,
<a class="reference internal" href="#coq:tacn.exists" title="exists"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exists</span></code></a>, <a class="reference internal" href="#coq:tacn.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a>, <a class="reference internal" href="#coq:tacn.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> and <a class="reference internal" href="#coq:tacn.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a>,
but they introduce existential variables instead of failing
when a variable can't be instantiated
(cf. <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>).</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a>, <a class="reference internal" href="#coq:tacn.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a> and <a class="reference internal" href="#coq:tacn.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">or</span><span>. </span><span class="coqdoc-comment">(* or, represented by \/, has two constructors, or_introl and or_intror *)</span></dt><dd><span class="ansi-fg-light-red ansi-bold">Inductive</span><span> or (A B : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span> :=
    or_introl : A</span><span> -&gt;</span><span> A</span><span> \/</span><span> B | or_intror : B</span><span> -&gt;</span><span> A</span><span> \/</span><span> B.

Arguments </span><span class="ansi-fg-light-green">or</span><span> (A B)%type_scope
Arguments </span><span class="ansi-fg-light-green">or_introl</span><span> [A B]%type_scope _, [_] _ _
Arguments </span><span class="ansi-fg-light-green">or_intror</span><span> [A B]%type_scope _, _ [_] _
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">P2</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P1</span><span> -&gt; </span><span class="coqdoc-var">P1</span><span> \/ </span><span class="coqdoc-var">P2</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> P1 P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, P1</span><span> -&gt;</span><span> P1</span><span> \/</span><span> P2
</span></dd>
<dt><span></span><span class="coqdoc-tactic">constructor</span><span> 1. </span><span class="coqdoc-comment">(* equivalent to &quot;left&quot; *)</span></dt><dd><span>1 goal
  
  P1, P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : P1
  ============================
  P1
</span></dd>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>. </span><span class="coqdoc-comment">(* success *)</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>In contrast, we won't be able to complete the proof if we select constructor 2:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">P2</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P1</span><span> -&gt; </span><span class="coqdoc-var">P1</span><span> \/ </span><span class="coqdoc-var">P2</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> P1 P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, P1</span><span> -&gt;</span><span> P1</span><span> \/</span><span> P2
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">constructor</span><span> 2. </span><span class="coqdoc-comment">(* equivalent to &quot;right&quot; *)</span></dt><dd><span>1 goal
  
  P1, P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : P1
  ============================
  P2
</span></dd>
</dl>
</div>
<p>You can also apply a constructor by name:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P1</span><span> </span><span class="coqdoc-var">P2</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P1</span><span> -&gt; </span><span class="coqdoc-var">P1</span><span> \/ </span><span class="coqdoc-var">P2</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> P1 P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, P1</span><span> -&gt;</span><span> P1</span><span> \/</span><span> P2
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">or_introl</span><span>. </span><span class="coqdoc-comment">(* equivalent to &quot;left&quot; *)</span></dt><dd><span>1 goal
  
  P1, P2 : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : P1
  ============================
  P1
</span></dd>
</dl>
</div>
</div>
</section>
<section id="case-analysis">
<span id="caseanalysisandinduction"></span><h2>Case analysis<a class="headerlink" href="#case-analysis" title="Permalink to this headline">¶</a></h2>
<p>The tactics in this section implement case
analysis on inductive or coinductive objects (see <a class="reference internal" href="../../language/core/variants.html#variants"><span class="std std-ref">Variants and the match construct</span></a>).</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.destruct">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.destruct" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-induction_clause"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole">induction_clause</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole">induction_arg</span></a> <span class="repeat-wrapper"><span class="repeat"><span><span>as</span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole">or_and_intropattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>eqn</span></span> <span><span>:</span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-naming_intropattern"><span class="hole">naming_intropattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-occurrences"><span class="hole">occurrences</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-induction_arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole">induction_arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole">one_term_with_bindings</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole">natural</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Performs case analysis by generating a subgoal for each constructor of the
inductive or coinductive type selected by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>.  The selected
subterm, after possibly doing an <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>, must have
an inductive or coinductive type.  Unlike <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>,
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span></span></code> generates no induction hypothesis.</p>
<p>In each new subgoal, the tactic replaces the selected subterm with the associated
constructor applied to its arguments, if any.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code></dt><dd><p>Giving multiple <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span></code>s is equivalent to applying <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span></span></code>
serially on each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code></dt><dd><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)
is an identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> denotes a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span></span></code> variable in the
goal, then <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> behaves like
<a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">destruct</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is no longer dependent in the
goal after application of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span></span></code>, it is erased. To avoid erasure,
use parentheses, as in <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <span><span><span class="pre">(</span></span></span><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">)</span></span></span></span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> may contain holes that are denoted by “_”. In this case,
the tactic selects the first subterm that matches the pattern and performs
case analysis using that subterm.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code>, then <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> behaves like
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> followed by <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span></span></code> applied to the last
introduced hypothesis.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span></code></dt><dd><p>Provides names for (or applies further transformations to)
the variables and hypotheses introduced in each new subgoal.  The
<a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">or_and_intropattern</span></code></a> must have one <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>
for each constructor, given in the order in which the constructors are
defined.  If there are not enough names, Coq picks fresh names.
Inner <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intropattern</span></span></span></span></code>s can also split introduced hypotheses into
multiple hypotheses or subgoals.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">eqn</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span></code></dt><dd><p>Generates a new hypothesis in each new subgoal that is an equality between
the term being case-analyzed and the associated constructor (applied to
its arguments).  The name of the new item may be specified in the
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-naming_intropattern"><span class="hole"><span class="pre">naming_intropattern</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>  (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)</dt><dd><p>Provides explicit instances for
the <a class="reference internal" href="../../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a> of the type of
<a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code></dt><dd><p>Selects specific subterms of the goal and/or hypotheses to apply
the tactic to.  See <a class="reference internal" href="../../proof-engine/tactics.html#occurrenceclauses"><span class="std std-ref">Occurrence clauses</span></a>.
If it occurs in the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span></code>, then
there can only be one <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span></code>, which can't have its
own <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code> clause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span></code></dt><dd><p>Makes the tactic equivalent to
<a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span></code>.</p>
</dd>
</dl>
<div class="admonition note" id="example-destruct-ind-concl">
<p class="admonition-title">Example: Using <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> on an argument with premises</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">D</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
B is declared
C is declared
D is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> \/ </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">D</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  (A</span><span> -&gt;</span><span> B</span><span> \/</span><span> C)</span><span> -&gt;</span><span> D
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-tactic">until</span><span> 1.</span><span>
</span></dt><dd><span>1 goal
  
  H : A</span><span> -&gt;</span><span> B</span><span> \/</span><span> C
  ============================
  D
</span></dd>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>3 goals
  
  ============================
  A

goal 2 is:
 D
goal 3 is:
 D
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> 2.</span><span>
</span></dt><dd><span>goal 2 is:
  
  H : B
  ============================
  D
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> 3.</span><span>
</span></dt><dd><span>goal 3 is:
  
  H : C
  ============================
  D
</span></dd>
</dl>
</div>
<p>The single tactic <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <span><span><span class="pre">1</span></span></span></span></code> is equivalent to the
<a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> and <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> used here.</p>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.edestruct">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">edestruct</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.edestruct" title="Permalink to this definition">¶</a></dt>
<dd><p>If the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>) has
<a class="reference internal" href="../../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a>
whose values can't be inferred from the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> clause,
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">edestruct</span></span></span></span></code> turns them into existential variables to be resolved later on.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.case">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">case</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.case" title="Permalink to this definition">¶</a></dt>
<dd><p>An older, more basic tactic to perform case analysis without
recursion.  We recommend using <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> instead where possible.
<code class="docutils literal notranslate"><span class="pre">case</span></code> only modifies the goal; it does not modify the <a class="reference internal" href="proof-mode.html#term-local-context"><span class="xref std std-term">local context</span></a>.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.ecase">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">ecase</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.ecase" title="Permalink to this definition">¶</a></dt>
<dd><p>If the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>) has
<a class="reference internal" href="../../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premises</span></a>
whose values can't be inferred from the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> clause,
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">ecase</span></span></span></span></code> turns them into existential variables to be resolved later on.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.case_eq">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">case</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eq</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.case_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>A variant of the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">case</span></span></span></span></code> tactic that allows
performing case analysis on a term without completely forgetting its original
form. This is done by generating equalities between the original form of the
term and the outcomes of the case analysis.  We recommend using the
<a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> tactic with an <code class="docutils literal notranslate"><span class="pre">eqn:</span></code> clause instead.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.casetype">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">casetype</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></span><a class="headerlink" href="#coq:tacn.casetype" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.18.</span></p>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-destruct">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">destruct</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-destruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">until</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">case</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span></span></code> variable in the goal and otherwise fails.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-destruction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">destruction</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">generalizing</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-destruction" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a long example of <a class="reference internal" href="#coq:tacn.dependent-destruction" title="dependent destruction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code></a> and an explanation
of the underlying technique <a class="reference internal" href="#dependent-induction-examples"><span class="std std-ref">here</span></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.decompose">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">decompose</span></span></span> <span><span><span class="pre">[</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">]</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively decomposes a complex proposition in order to obtain atomic ones.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> \/ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> \/ </span><span class="coqdoc-var">C</span><span> /\ </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> A B C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>, A</span><span> /\</span><span> B</span><span> /\</span><span> C</span><span> \/</span><span> B</span><span> /\</span><span> C</span><span> \/</span><span> C</span><span> /\</span><span> A</span><span> -&gt;</span><span> C
</span></dd>
<dt><span>  </span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-var">decompose</span><span> [</span><span class="coqdoc-var">and</span><span> </span><span class="coqdoc-var">or</span><span>] </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>3 goals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  H : A</span><span> /\</span><span> B</span><span> /\</span><span> C</span><span> \/</span><span> B</span><span> /\</span><span> C</span><span> \/</span><span> C</span><span> /\</span><span> A
  H1 : A
  H0 : B
  H3 : C
  ============================
  C

goal 2 is:
 C
goal 3 is:
 C
</span></dd>
<dt><span>  </span><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-tactic">assumption</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#coq:tacn.decompose" title="decompose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">decompose</span></code></a> does not work on right-hand sides of implications or
products.</p>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.decompose-sum">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">decompose</span></span></span> <span><span><span class="pre">sum</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.decompose-sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This decomposes sum types (like <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span></code>).</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.decompose-record">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">decompose</span></span></span> <span><span><span class="pre">record</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></span><a class="headerlink" href="#coq:tacn.decompose-record" title="Permalink to this definition">¶</a></dt>
<dd><p>This decomposes record types (inductive types with one constructor,
like <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">and</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">exists</span></span></code> and those defined with the <a class="reference internal" href="../../language/core/records.html#coq:cmd.Record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a>
command.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.destauto">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">destauto</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.destauto" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces one <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">match</span></span></span> <span><span><span class="pre">t</span></span></span> <span><span><span class="pre">with</span></span></span> <span><span><span class="pre">...</span></span></span></span></code> by doing <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <span><span><span class="pre">t</span></span></span></span></code>.  If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">t</span></span></span></span></code> is
not a variable, the tactic does
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">case</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eq</span></span></span> <span><span><span class="pre">t;intros</span></span></span> <span><span><span class="pre">...</span></span></span> <span><span><span class="pre">heq;rewrite</span></span></span> <span><span><span class="pre">heq</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">*</span></span></span><span class="pre">|</span><span><span><span class="pre">-</span></span></span></span></code>.
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">heq</span></span></span></span></code> is preserved.</p>
</dd></dl>

</section>
<section id="induction">
<h2>Induction<a class="headerlink" href="#induction" title="Permalink to this headline">¶</a></h2>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.induction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">induction</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.induction" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-induction_principle"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole">induction_principle</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>using</span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole">one_term_with_bindings</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-occurrences"><span class="hole">occurrences</span></a></span><span class="notation-sup">?</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Applies an <a class="reference internal" href="../../language/core/inductive.html#term-induction-principle"><span class="xref std std-term">induction principle</span></a> to generate a subgoal for
each constructor of an inductive type.</p>
<p>If the argument is <a class="reference internal" href="../../language/core/assumptions.html#term-dependent-product"><span class="xref std std-term">dependent</span></a> in the conclusion or some
hypotheses of the goal, the argument is replaced by the appropriate
constructor in each of the resulting subgoals and induction
hypotheses are added to the local context using names whose prefix
is <strong>IH</strong>.  The tactic is similar to <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, except that
<code class="docutils literal notranslate"><span class="pre">destruct</span></code> doesn't generate induction hypotheses.</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span></span></code> and <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> are very similar.  Aside from the following
differences, please refer to the description of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> while mentally substituting
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span></span></code> for <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code></dt><dd><p>If no <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span></code> clause is provided, this is equivalent to doing
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span></span></code> on the first <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span></code> followed by <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">destruct</span></span></span></span></code>
on any subsequent clauses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span></code></dt><dd><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> specifies which <a class="reference internal" href="../../language/core/inductive.html#term-induction-principle"><span class="xref std std-term">induction principle</span></a> to use.  The
optional <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> gives any values that must be substituted
into the induction principle.  The number of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>
must be the same as the number of parameters of the induction principle.</p>
<p>If unspecified, the tactic applies the appropriate <a class="reference internal" href="../../language/core/inductive.html#term-induction-principle"><span class="xref std std-term">induction principle</span></a>
that was automatically generated when the inductive type was declared based
on the sort of the goal.</p>
</dd>
</dl>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Cannot-recognize-a-statement-based-on-‘reference’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Cannot</span></span></span> <span><span><span class="pre">recognize</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">statement</span></span></span> <span><span><span class="pre">based</span></span></span> <span><span><span class="pre">on</span></span></span> <a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole"><span class="pre">reference</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Cannot-recognize-a-statement-based-on-‘reference’" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> (in an <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span></code>) must reduce to the
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole"><span class="pre">reference</span></span></a></span></code> which was inferred as the type the induction
principle operates on. Note that it is not enough to be convertible, but you can
work around that with <a class="reference internal" href="equality.html#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a>:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">N</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span><span>
</span></dt><dd><span>N is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">strong</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span>, (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">N</span><span>, (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">N</span><span>, </span><span class="coqdoc-var">m</span><span> &lt; </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">m</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
  -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>strong is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">N</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, P n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  ============================
  P n
</span></dd>
<dt><span></span><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">strong</span><span>.</span><span>
</span></dt><dd><span>The command has indeed failed with message:
Cannot recognize a statement based on N.
</span></dd>
<dt><span></span><span class="coqdoc-tactic">change</span><span> </span><span class="coqdoc-var">N</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : N
  ============================
  P n
</span></dd>
<dt><span></span><span class="coqdoc-comment">(* n is now of type N, matching the inferred type that strong operates on *)</span></dt><dt><span></span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">strong</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : N
  H : </span><span class="ansi-bold">forall</span><span> m : N, m</span><span> &lt;</span><span> n</span><span> -&gt;</span><span> P m
  ============================
  P n
</span></dd>
</dl>
</div>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Unable-to-find-an-instance-for-the-variables-‘ident’-…-‘ident’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Unable</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">find</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">instance</span></span></span> <span><span><span class="pre">for</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">variables</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">…</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Unable-to-find-an-instance-for-the-variables-‘ident’-…-‘ident’" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> clause or the <a class="reference internal" href="#coq:tacn.einduction" title="einduction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einduction</span></code></a> tactic instead.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">induction_test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> =</span><span> n</span><span> -&gt;</span><span> n</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  H : n</span><span> =</span><span> n
  ============================
  n</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  H : 0</span><span> =</span><span> 0
  ============================
  0</span><span> &lt;=</span><span> 0

goal 2 is:
 S n</span><span> &lt;=</span><span> S n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">exact</span><span> (</span><span class="coqdoc-var">le_n</span><span> 0).</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  H : S n</span><span> =</span><span> S n
  IHn : n</span><span> =</span><span> n</span><span> -&gt;</span><span> n</span><span> &lt;=</span><span> n
  ============================
  S n</span><span> &lt;=</span><span> S n
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-occurrences"><span class="hole"><span class="pre">occurrences</span></span></a></span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">induction_test2</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> =</span><span> n</span><span> -&gt;</span><span> n</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  H : n</span><span> =</span><span> n
  ============================
  n</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H</span><span> |-.</span><span>
</span></dt><dd><span>2 goals
  
  n : nat
  H : 0</span><span> =</span><span> 0
  ============================
  n</span><span> &lt;=</span><span> n

goal 2 is:
 n</span><span> &lt;=</span><span> n
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Show</span><span> 2.</span><span>
</span></dt><dd><span>goal 2 is:
  
  n, n0 : nat
  H : S n0</span><span> =</span><span> S n0
  IHn0 : n0</span><span> =</span><span> n0</span><span> -&gt;</span><span> n</span><span> &lt;=</span><span> n
  ============================
  n</span><span> &lt;=</span><span> n
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.einduction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">einduction</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_clause"><span class="hole"><span class="pre">induction_clause</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_principle"><span class="hole"><span class="pre">induction_principle</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.einduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> except that it does not fail if
some <a class="reference internal" href="../../language/core/assumptions.html#term-dependent-premise"><span class="xref std std-term">dependent premise</span></a> of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> can't be inferred. Instead,
the unresolved premises are posed as existential variables to be inferred
later, in the same way as <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> does.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.elim">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">elim</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.elim" title="Permalink to this definition">¶</a></dt>
<dd><p>An older, more basic induction tactic.  Unlike <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <code class="docutils literal notranslate"><span class="pre">elim</span></code> only
modifies the goal; it does not modify the <a class="reference internal" href="proof-mode.html#term-local-context"><span class="xref std std-term">local context</span></a>.  We recommend
using <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> instead where possible.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>   (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span></code>)</dt><dd><p>Explicitly gives instances to the premises of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>
(see <a class="reference internal" href="../../proof-engine/tactics.html#bindings"><span class="std std-ref">Bindings</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>Allows explicitly giving an induction principle <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> that
is not the standard one for the underlying inductive type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>. The
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code> clause allows instantiating premises of the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.</p>
</dd>
</dl>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.eelim">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eelim</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-one_term_with_bindings"><span class="hole"><span class="pre">one_term_with_bindings</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.eelim" title="Permalink to this definition">¶</a></dt>
<dd><p>If the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> has dependent premises, this turns them into
existential variables to be resolved later on.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.elimtype">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">elimtype</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_type"><span class="hole"><span class="pre">one_type</span></span></a></span></span><a class="headerlink" href="#coq:tacn.elimtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The argument <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_type</span></code></a> must be inductively defined. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">elimtype</span></span></span> <span><span><span class="pre">I</span></span></span></span></code> is
equivalent to <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.cut" title="cut"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cut</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">I.</span></span></span> <span><span><span class="pre">intro</span></span></span> <span><span><span class="pre">Hn;</span></span></span> <span><span><span class="pre">elim</span></span></span> <span><span><span class="pre">Hn;</span></span></span></span></code> <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.clear" title="clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">clear</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Hn.</span></span></span></span></code> Therefore the
hypothesis <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Hn</span></span></code> will not appear in the context(s) of the subgoal(s).
Conversely, if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> of (inductive) type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> that does
not occur in the goal, then <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">elim</span></span></span> <span><span><span class="pre">t</span></span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">elimtype</span></span></span> <span><span><span class="pre">I;</span></span></span> <span><span><span class="pre">only</span></span></span> <span><span><span class="pre">2:</span></span></span></span></code> <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> <code class="docutils literal notranslate"><span class="pre">t.</span></code></p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 8.18.</span></p>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-induction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">induction</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>Behaves like <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">elim</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> when
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span></span></code> variable in the goal.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-induction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">induction</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span class="alternative"><span class="alternative-block"><span><span><span class="pre">generalizing</span></span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">in</span></span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-induction" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>experimental</em> tactic <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> performs
induction-inversion on an instantiated inductive predicate. One needs to first
<a class="reference internal" href="../../proof-engine/vernacular-commands.html#coq:cmd.Require" title="Require"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Require</span></code></a> the <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code> module to use this tactic. The tactic
is based on the BasicElim tactic by Conor McBride
<a class="reference internal" href="../../zebibliography.html#dblp-conf-types-mcbride00" id="id1">[McB00]</a> and the work of Cristina Cornes around
inversion <a class="reference internal" href="../../zebibliography.html#dblp-conf-types-cornest95" id="id2">[CT95]</a>. From an instantiated
inductive predicate and a goal, it generates an equivalent goal where
the hypothesis has been generalized over its indexes which are then
constrained by equalities to be the right instances. This permits to
state lemmas without resorting to manually adding these equalities and
still get enough information in the proofs.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span><span class="pre">generalizing</span></span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">in</span></span></span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>First generalizes the goal by the given variables so that they are universally
quantified in the goal.  This is generally what one wants to do with
variables that are inside constructors in the induction hypothesis.  The other
ones need not be further generalized.</p>
</dd>
</dl>
<p>There is a long example of <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> and an explanation
of the underlying technique <a class="reference internal" href="#dependent-induction-examples"><span class="std std-ref">here</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">lt_1_r</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> &lt; 1 -&gt; </span><span class="coqdoc-var">n</span><span> = 0.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> &lt;</span><span> 1</span><span> -&gt;</span><span> n</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span> ; </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  n : nat
  ============================
  n</span><span> =</span><span> 0

goal 2 is:
 n</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>Here we did not get any information on the indexes to help fulfill
this proof. The problem is that, when we use the <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic, we
lose information on the hypothesis instance, notably that the second
argument is 1 here. Dependent induction solves this problem by adding
the corresponding equality to the context.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Program.Equality</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">lt_1_r</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> &lt; 1 -&gt; </span><span class="coqdoc-var">n</span><span> = 0.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n : nat, n</span><span> &lt;</span><span> 1</span><span> -&gt;</span><span> n</span><span> =</span><span> 0
</span></dd>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span> ; </span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  ============================
  0</span><span> =</span><span> 0

goal 2 is:
 n</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>The subgoal is cleaned up as the tactic tries to automatically
simplify the subgoals with respect to the generated equalities. In
this enriched context, it becomes possible to solve this subgoal.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  H : S n</span><span> &lt;=</span><span> 0
  IHle : 0</span><span> =</span><span> 1</span><span> -&gt;</span><span> n</span><span> =</span><span> 0
  ============================
  n</span><span> =</span><span> 0
</span></dd>
</dl>
</div>
<p>Now we are in a contradictory context and the proof can be solved.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
</dl>
</div>
<p>This technique works with any inductive predicate. In fact, the
<a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> tactic is just a wrapper around the <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>
tactic. One can make its own variant by just writing a new tactic
based on the definition found in <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../using/libraries/funind.html#coq:tacn.functional-induction" title="functional induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">functional</span> <span class="pre">induction</span></code></a></p>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.fix">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">fix</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">{</span></span></span> <span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="../../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">}</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>A primitive tactic that starts a proof by induction. Generally,
higher-level tactics such as <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> or <a class="reference internal" href="#coq:tacn.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>
are easier to use.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s (including the first one before the <code class="docutils literal notranslate"><span class="pre">with</span></code>
clause) are the names of
the induction hypotheses. <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> tells on which
premise of the current goal the induction acts, starting from 1,
counting both dependent and non-dependent products, but skipping local
definitions. The current lemma must be composed of at
least <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> products.</p>
<p>As in a fix expression, induction hypotheses must be used on
structurally smaller arguments. The verification that inductive proof
arguments are correct is done only when registering the
lemma in the global environment. To know if the use of induction hypotheses
is correct during the interactive development of a proof, use
the command <a class="reference internal" href="proof-mode.html#coq:cmd.Guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">{</span></span></span> <span><span><span class="pre">struct</span></span></span> <a class="reference internal" href="../../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a> <span><span><span class="pre">}</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>Starts a proof by mutual induction. The statements to be proven
are <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span><sub><span class="pre">i</span></sub></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span><sub><span class="pre">i</span></sub></span></a></span></code>.
The identifiers <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (including the first one before the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause)
are the names of the induction hypotheses. The identifiers
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/assumptions.html#grammar-token-name"><span class="hole"><span class="pre">name</span></span></a></span></code> (in the <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">struct</span> <span class="pre">...</span> <span class="pre">}</span></code> clauses) are the respective names of
the premises on which the induction
is performed in the statements to be proved (if not given, Coq
guesses what they are).</p>
</dd>
</dl>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.cofix">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cofix</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.cofix" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a proof by coinduction. The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>s (including the first one
before the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause) are the
names of the coinduction hypotheses. As in a cofix expression,
the use of induction hypotheses must be guarded by a constructor. The
verification that the use of coinductive hypotheses is correct is
done only at the time of registering the lemma in the global environment. To
know if the use of coinduction hypotheses is correct at some time of
the interactive development of a proof, use the command <a class="reference internal" href="proof-mode.html#coq:cmd.Guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></dt><dd><p>Starts a proof by mutual coinduction. The statements to be
proven are <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_binder"><span class="hole"><span class="pre">simple_binder</span><sub><span class="pre">i</span></sub></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-type"><span class="hole"><span class="pre">type</span><sub><span class="pre">i</span></sub></span></a></span></code>.
The identifiers <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (including the first one before the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause)
are the names of the coinduction hypotheses.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="equality-of-inductive-types">
<span id="equality-inductive-types"></span><h2>Equality of inductive types<a class="headerlink" href="#equality-of-inductive-types" title="Permalink to this headline">¶</a></h2>
<p>This section describes some special purpose tactics to work with
<a class="reference internal" href="equality.html#term-Leibniz-equality"><span class="xref std std-term">Leibniz equality</span></a> of inductive sets or types.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.discriminate">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">discriminate</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.discriminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Proves any goal for which a hypothesis in the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>
states an impossible structural equality for an inductive type.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> is not given, it checks all the hypotheses
for impossible equalities.
For example, <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">))</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> is impossible.
If provided, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> is a proof of an equality, typically
specified as the name of a hypothesis.</p>
<p>If no <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> is provided and the goal is in the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">&lt;&gt;</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>, then the tactic behaves like
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intro</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">discriminate</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
<p>The tactic traverses the normal forms of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>,
looking for subterms <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">w</span></span></code> placed in the same positions and whose
head symbols are different constructors. If such subterms are present, the
equality is impossible and the current goal is completed.
Otherwise the tactic fails.  Note that opaque constants are not expanded by
δ reductions while computing the normal form.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>  (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Checks the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> for impossible equalities.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is not already in the context, this is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">discriminate</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Equivalent to <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">discriminate</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>,
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last introduced hypothesis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>  (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">discriminate</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> but uses the given
bindings to instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> must be a proof of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>.</p>
</dd>
</dl>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-primitive-equality-found">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">primitive</span></span></span> <span><span><span class="pre">equality</span></span></span> <span><span><span class="pre">found.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-primitive-equality-found" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-a-discriminable-equality">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">discriminable</span></span></span> <span><span><span class="pre">equality.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-a-discriminable-equality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.ediscriminate">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">ediscriminate</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.ediscriminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Works the same as <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a> but if the type of <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a>, or the
type of the hypothesis referred to by <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><code class="xref std std-token docutils literal notranslate"><span class="pre">natural</span></code></a>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.injection">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">injection</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.injection" title="Permalink to this definition">¶</a></dt>
<dd><p>Exploits the property that constructors of
inductive types are injective, i.e. that if <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">c</span></span></span></span></code> is a constructor of an
inductive type and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">c</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">c</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">2</span></sub></span></span></code> then
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">2</span></sub></span></span></code> are equal too.</p>
<p>If there is a hypothesis <code class="docutils literal notranslate"><span class="pre">H</span></code> in the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span> <span><span><span class="pre">H</span></span></span></span></code> applies the injectivity of constructors as deep as
possible to derive the equality of subterms of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a></span></code> and
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code> wherever the subterms start to differ. For example, from
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">q</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code> we may derive <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span></code>. The terms must have inductive types and the same head
constructor, but must not be convertible. If so, the tactic derives the
equalities and adds them to the current goal as <a class="reference internal" href="../../language/core/assumptions.html#term-premise"><span class="xref std std-term">premises</span></a>
(except if the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span></span></code> clause is used).</p>
<p>If no <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">arg</span></span></span></span></code> is provided and the current goal is of the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">&lt;&gt;</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intro</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>  (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Derives equalities based on constructor injectivity for the hypothesis
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is not already in the context, this is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Equivalent to <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-bindings"><span class="hole"><span class="pre">bindings</span></span></a></span></code>  (in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code>)</dt><dd><p>Like <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> but uses the given bindings to
instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <span><span><span class="pre">[=</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">]</span></span></span></span></code></dt><dd><p>Specifies names to apply after the injection so
that all generated equalities become hypotheses, which (unlike <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>)
may replace existing hypotheses with same name.  The number of
provided names must not exceed
the number of newly generated equalities. If it is smaller, fresh
names are generated for the unspecified items. The original equality is
erased if it corresponds to a provided name or if the list of provided
names is incomplete.</p>
<p>Note that, as a convenience for users, specifying
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> is treated as if
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[=</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> was specified.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Consider the following goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> -&gt; </span><span class="coqdoc-var">list</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined
list_sind is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">list</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">nil</span><span> -&gt; </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">cons</span><span> 0 </span><span class="coqdoc-var">nil</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">l</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (l : list) (n : nat), P nil</span><span> -&gt;</span><span> cons n l</span><span> =</span><span> cons 0 nil</span><span> -&gt;</span><span> P l
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list
  n : nat
  H : P nil
  H0 : cons n l</span><span> =</span><span> cons 0 nil
  ============================
  P l
</span></dd>
<dt><span></span><span class="coqdoc-tactic">injection</span><span> </span><span class="coqdoc-var">H0</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list
  n : nat
  H : P nil
  H0 : cons n l</span><span> =</span><span> cons 0 nil
  ============================
  l</span><span> =</span><span> nil</span><span> -&gt;</span><span> n</span><span> =</span><span> 0</span><span> -&gt;</span><span> P l
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Beware that injection yields an equality in a sigma type whenever the
injected object has a dependent type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> with its two instances in
different types <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(P</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">t</span></span><sub><span class="pre">n</span></sub></span><span><span><span class="pre">)</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(P</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">1</span></sub></span> <span><span><span class="pre">…</span></span></span> <span><span><span class="pre">u</span></span><sub><span class="pre">n</span></sub></span><span><span><span class="pre">)</span></span></span></span></code>. If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">t</span></span><sub><span class="pre">1</span></sub></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">u</span></span><sub><span class="pre">1</span></sub></span></span></code> are the same and have for type an inductive type for which a decidable
equality has been declared using <a class="reference internal" href="#coq:cmd.Scheme-Equality" title="Scheme Equality"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span> <span class="pre">Equality</span></code></a>,
the use of a sigma type is avoided.</p>
</div>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.No-information-can-be-deduced-from-this-equality-and-the-injectivity-of-constructors.-This-may-be-because-the-terms-are-convertible,-or-due-to-pattern-matching-restrictions-in-the-sort-Prop.-You-can-try-to-use-option-Set-Keep-Proof-Equalities">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">No</span></span></span> <span><span><span class="pre">information</span></span></span> <span><span><span class="pre">can</span></span></span> <span><span><span class="pre">be</span></span></span> <span><span><span class="pre">deduced</span></span></span> <span><span><span class="pre">from</span></span></span> <span><span><span class="pre">this</span></span></span> <span><span><span class="pre">equality</span></span></span> <span><span><span class="pre">and</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">injectivity</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">constructors.</span></span></span> <span><span><span class="pre">This</span></span></span> <span><span><span class="pre">may</span></span></span> <span><span><span class="pre">be</span></span></span> <span><span><span class="pre">because</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">terms</span></span></span> <span><span><span class="pre">are</span></span></span> <span><span><span class="pre">convertible,</span></span></span> <span><span><span class="pre">or</span></span></span> <span><span><span class="pre">due</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">pattern</span></span></span> <span><span><span class="pre">matching</span></span></span> <span><span><span class="pre">restrictions</span></span></span> <span><span><span class="pre">in</span></span></span> <span><span><span class="pre">the</span></span></span> <span><span><span class="pre">sort</span></span></span> <span><span><span class="pre">Prop.</span></span></span> <span><span><span class="pre">You</span></span></span> <span><span><span class="pre">can</span></span></span> <span><span><span class="pre">try</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">use</span></span></span> <span><span><span class="pre">option</span></span></span> <span><span><span class="pre">Set</span></span></span> <span><span><span class="pre">Keep</span></span></span> <span><span><span class="pre">Proof</span></span></span> <span><span><span class="pre">Equalities.</span></span></span></span></span><a class="headerlink" href="#coq:exn.No-information-can-be-deduced-from-this-equality-and-the-injectivity-of-constructors.-This-may-be-because-the-terms-are-convertible,-or-due-to-pattern-matching-restrictions-in-the-sort-Prop.-You-can-try-to-use-option-Set-Keep-Proof-Equalities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Not-a-negated-primitive-equality">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">negated</span></span></span> <span><span><span class="pre">primitive</span></span></span> <span><span><span class="pre">equality</span></span></span></span></span><a class="headerlink" href="#coq:exn.Not-a-negated-primitive-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>When <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span></code> is not provided, the goal must be in the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">&lt;&gt;</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Nothing-to-inject">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Nothing</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">inject.</span></span></span></span></span><a class="headerlink" href="#coq:exn.Nothing-to-inject" title="Permalink to this definition">¶</a></dt>
<dd><p>Generated when one side of the equality is not a constructor.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.einjection">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">einjection</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.einjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Works the same as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span></span></code> but if the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-injection">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">injection</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-injection" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a>, but always adds the derived equalities
as new <a class="reference internal" href="../../language/core/assumptions.html#term-premise"><span class="xref std std-term">premises</span></a> in the current goal (instead of as
new hypotheses) even if the <a class="reference internal" href="#coq:flag.Structural-Injection" title="Structural Injection"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Structural</span> <span class="pre">Injection</span></code></a> flag is set.</p>
</dd></dl>

<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Structural-Injection">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Structural</span></span></span> <span><span><span class="pre">Injection</span></span></span></span></span><a class="headerlink" href="#coq:flag.Structural-Injection" title="Permalink to this definition">¶</a></dt>
<dd><p>When this <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> is set, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> erases the original hypothesis
and adds the generated equalities as new hypotheses rather than adding them
to the current goal as <a class="reference internal" href="../../language/core/assumptions.html#term-premise"><span class="xref std std-term">premises</span></a>, as if giving <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">injection</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span><span class="pre">as</span></span></span></span></code>
(with an empty list of names). This flag is off by default.</p>
</dd></dl>

<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Keep-Proof-Equalities">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Keep</span></span></span> <span><span><span class="pre">Proof</span></span></span> <span><span><span class="pre">Equalities</span></span></span></span></span><a class="headerlink" href="#coq:flag.Keep-Proof-Equalities" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> only creates new equalities between <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s
whose type is in sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Set</span></span></code>, thus implementing a special
behavior for objects that are proofs of a statement in <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a>
controls this behavior.</p>
</dd></dl>

<dl class="coq table">
<dt class="sig sig-object coq" id="coq:table.Keep-Equalities">
<em class="property"><span class="sigannot"><span class="pre">Table</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Keep</span></span></span> <span><span><span class="pre">Equalities</span></span></span> <a class="reference internal" href="../../language/core/modules.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></span><a class="headerlink" href="#coq:table.Keep-Equalities" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../../language/core/basic.html#term-table"><span class="xref std std-term">table</span></a> specifies a set of inductive types for which proof
equalities are always kept by <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a>. This overrides the
<a class="reference internal" href="#coq:flag.Keep-Proof-Equalities" title="Keep Proof Equalities"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Keep</span> <span class="pre">Proof</span> <span class="pre">Equalities</span></code></a> flag for those inductive types.
Use the <a class="reference internal" href="../../language/core/basic.html#coq:cmd.Add" title="Add"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span></code></a> and <a class="reference internal" href="../../language/core/basic.html#coq:cmd.Remove" title="Remove"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span></code></a> commands to update this set manually.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simplify_eq">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simplify</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eq</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.simplify_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Examines a hypothesis that has the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>.  If the terms are
structurally different, the tactic does a <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>.  Otherwise, it does
an <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> to simplify the equality, if possible.  If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">induction</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">arg</span></span></span></span></code>
is not provided, the tactic examines the goal, which must be in the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">&lt;&gt;</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">2</span></sub></span></a></span></code>.</p>
<p>See the description of <a class="reference internal" href="#grammar-token-induction_arg"><code class="xref std std-token docutils literal notranslate"><span class="pre">induction_arg</span></code></a> in <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> for an
explanation of the parameters.</p>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.esimplify_eq">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">esimplify</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">eq</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-induction_arg"><span class="hole"><span class="pre">induction_arg</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.esimplify_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Works the same as <a class="reference internal" href="#coq:tacn.simplify_eq" title="simplify_eq"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simplify_eq</span></code></a> but if the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code> or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.inversion">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">inversion</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.inversion" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="id3">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">inversion</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span><span><span class="pre">using</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>For a hypothesis whose type is a (co)inductively defined
proposition, the tactic introduces a goal for each constructor
of the proposition that isn't self-contradictory.  Each such goal
includes the hypotheses needed to deduce the proposition.
<span class="term-defn"><span class="target" id="term-inductively-defined-proposition"></span>(Co)inductively defined propositions</span>
are those defined with the <a class="reference internal" href="../../language/core/inductive.html#coq:cmd.Inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> or <a class="reference internal" href="../../language/core/coinductive.html#coq:cmd.CoInductive" title="CoInductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoInductive</span></code></a> commands whose
contructors yield a <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, as in this <a class="reference internal" href="#inversion-intropattern-ex"><span class="std std-ref">example</span></a>.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></dt><dd><p>The name of the hypothesis to invert.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> does not denote a hypothesis in the local context but
refers to a hypothesis quantified in the goal, then the latter is
first introduced in the local context using <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code></dt><dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">intros</span></span></span> <span><span><span class="pre">until</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">inversion</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last introduced hypothesis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> are identifiers in the local context, this does
a <a class="reference internal" href="../../proof-engine/tactics.html#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a> <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> as the initial step of <code class="docutils literal notranslate"><span class="pre">inversion</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span></code></dt><dd><p>Provides names for the variables introduced in each new subgoal.  The
<a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">or_and_intropattern</span></code></a> must have one <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>
for each constructor of the (co)inductive predicate, given in the order
in which the constructors are defined.
If there are not enough names, Coq picks fresh names.</p>
<p>If an equation splits into several
equations (because <code class="docutils literal notranslate"><span class="pre">inversion</span></code> applies <code class="docutils literal notranslate"><span class="pre">injection</span></code> on the equalities it
generates), the corresponding <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span></code> should be in the form
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-intropattern"><span class="hole"><span class="pre">intropattern</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span><span><span class="pre">]</span></span></span></span></code> (or the equivalent <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><span><span><span class="pre">(</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a> <span><span><span class="pre">)</span></span></span></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code>),
with the number of entries equal to the number
of subequalities obtained from splitting the original equation.
Example <a class="reference internal" href="#inversion-intropattern-ex"><span class="std std-ref">here</span></a>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">…</span> <span class="pre">as</span></code> variant of
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> generally behaves in a slightly more expected way than
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> (no artificial duplication of some hypotheses referring to
other hypotheses). To take advantage of these improvements, it is enough to use
<code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">…</span> <span class="pre">as</span> <span class="pre">[]</span></code>, letting Coq choose fresh names.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As <code class="docutils literal notranslate"><span class="pre">inversion</span></code> proofs may be large, we recommend
creating and using lemmas whenever the same instance needs to be
inverted several times. See <a class="reference internal" href="#derive-inversion"><span class="std std-ref">Generation of inversion principles with Derive Inversion</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Part of the behavior of the <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactic is to generate
equalities between expressions that appeared in the hypothesis that is
being processed. By default, no equalities are generated if they
relate two proofs (i.e. equalities between <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>s whose type is in sort
<code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>). This behavior can be turned off by using the
<a class="reference internal" href="#coq:flag.Keep-Proof-Equalities" title="Keep Proof Equalities"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Keep</span> <span class="pre">Proof</span> <span class="pre">Equalities</span></code></a> setting.</p>
</div>
</dd></dl>

<blockquote id="inversion-intropattern-ex">
<div><div class="admonition note">
<p class="admonition-title">Example: <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> with <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span></code></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">contains0</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">in_hd</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">contains0</span><span> (0 :: </span><span class="coqdoc-var">l</span><span>)</span><span>
| </span><span class="coqdoc-var">in_tl</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">contains0</span><span> </span><span class="coqdoc-var">l</span><span> -&gt; </span><span class="coqdoc-var">contains0</span><span> (</span><span class="coqdoc-var">b</span><span> :: </span><span class="coqdoc-var">l</span><span>).</span><span>
</span></dt><dd><span>contains0 is defined
contains0_ind is defined
contains0_sind is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">contains0</span><span> (1 :: </span><span class="coqdoc-var">l</span><span>) -&gt; </span><span class="coqdoc-var">contains0</span><span> </span><span class="coqdoc-var">l</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> l : list nat, contains0 (1 </span><span>:: </span><span>l)</span><span> -&gt;</span><span> contains0 l
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  H : contains0 (1 </span><span>:: </span><span>l)
  ============================
  contains0 l
</span></dd>
<dt><span></span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">as</span><span> [ | </span><span class="coqdoc-var">l'</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">Hl'</span><span> [</span><span class="coqdoc-var">Heqp</span><span> </span><span class="coqdoc-var">Heql'</span><span>] ].</span><span>
</span></dt><dd><span>1 goal
  
  l : list nat
  H : contains0 (1 </span><span>:: </span><span>l)
  l' : list nat
  p : nat
  Hl' : contains0 l
  Heqp : p</span><span> =</span><span> 1
  Heql' : l'</span><span> =</span><span> l
  ============================
  contains0 l
</span></dd>
</dl>
</div>
</div>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.inversion_clear">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">inversion</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">clear</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.inversion_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Does an <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> and then erases the hypothesis that was used for
the inversion.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.simple-inversion">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">inversion</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.simple-inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>A very simple inversion tactic that derives all the necessary
equalities but does not simplify the constraints as <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> does.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-inversion">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">inversion</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>For use when the inverted hypothesis appears in the current goal.
Does an <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> and then substitutes the name of the hypothesis
where the corresponding term appears in the goal.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-inversion_clear">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">inversion</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">clear</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-inversion_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a <a class="reference internal" href="#coq:tacn.dependent-inversion" title="dependent inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code></a> and then erases the hypothesis that was used for
the dependent inversion.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-simple-inversion">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">simple</span></span></span> <span><span><span class="pre">inversion</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="../../language/core/basic.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-or_and_intropattern"><span class="hole"><span class="pre">or_and_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-simple-inversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div></blockquote>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.inversion_sigma">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">inversion</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">sigma</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="../../proof-engine/tactics.html#grammar-token-simple_intropattern"><span class="hole"><span class="pre">simple_intropattern</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.inversion_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns equalities of dependent pairs (e.g.,
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">q</span></span></code>, frequently left over by <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> on
a dependent type family) into pairs of equalities (e.g., a hypothesis
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span></code> and a hypothesis of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">rew</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code>); these
hypotheses can subsequently be simplified using <a class="reference internal" href="equality.html#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>, without ever
invoking any kind of axiom asserting uniqueness of identity proofs. If you
want to explicitly specify the hypothesis to be inverted, you can pass it as
an argument to <a class="reference internal" href="#coq:tacn.inversion_sigma" title="inversion_sigma"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_sigma</span></code></a>. This tactic also works for
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sig</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sigT2</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sig2</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">ex</span></span></code>, and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">ex2</span></span></code> and there are similar <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq_sig</span></span></code>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">***_</span></span><span class="name"><span class="pre">rect</span></span></code> induction lemmas.</p>
<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.Type-of-‘ident’-is-not-an-equality-of-recognized-Σ-types:-expected-one-of-sig-sig2-sigT-sigT2-sigT2-ex-or-ex2-but-got-‘term’">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Type</span></span></span> <span><span><span class="pre">of</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">equality</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">recognized</span></span></span> <span><span><span class="pre">Σ</span></span></span> <span><span><span class="pre">types:</span></span></span> <span><span><span class="pre">expected</span></span></span> <span><span><span class="pre">one</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">sig</span></span></span> <span><span><span class="pre">sig2</span></span></span> <span><span><span class="pre">sigT</span></span></span> <span><span><span class="pre">sigT2</span></span></span> <span><span><span class="pre">sigT2</span></span></span> <span><span><span class="pre">ex</span></span></span> <span><span><span class="pre">or</span></span></span> <span><span><span class="pre">ex2</span></span></span> <span><span><span class="pre">but</span></span></span> <span><span><span class="pre">got</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#coq:exn.Type-of-‘ident’-is-not-an-equality-of-recognized-Σ-types:-expected-one-of-sig-sig2-sigT-sigT2-sigT2-ex-or-ex2-but-got-‘term’" title="Permalink to this definition">¶</a></dt>
<dd><p>When applied to a hypothesis, <a class="reference internal" href="#coq:tacn.inversion_sigma" title="inversion_sigma"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_sigma</span></code></a> can only handle equalities of the
listed sigma types.</p>
</dd></dl>

<dl class="coq exn">
<dt class="sig sig-object coq" id="coq:exn.‘ident’-is-not-an-equality-of-Σ-types">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">is</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">an</span></span></span> <span><span><span class="pre">equality</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">Σ</span></span></span> <span><span><span class="pre">types</span></span></span></span></span><a class="headerlink" href="#coq:exn.‘ident’-is-not-an-equality-of-Σ-types" title="Permalink to this definition">¶</a></dt>
<dd><p>When applied to a hypothesis, <a class="reference internal" href="#coq:tacn.inversion_sigma" title="inversion_sigma"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_sigma</span></code></a> can only be called on hypotheses that
are equalities using <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Coq.Logic.Init.eq</span></span></code>.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: Non-dependent inversion</p>
<p>Let us consider the relation <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Le</span></span></code> over natural numbers:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Le</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">LeO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> 0 </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">LeS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>Le is defined
Le_rect is defined
Le_ind is defined
Le_rec is defined
Le_sind is defined
</span></dd>
</dl>
</div>
<p>Let us consider the following goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-keyword">Section</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Q is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  ============================
  </span><span class="ansi-bold">forall</span><span> n m : nat, Le (S n) m</span><span> -&gt;</span><span> P n m
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
</dl>
</div>
<p>To prove the goal, we may need to reason by cases on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> and to derive
that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> is necessarily of the form <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> for certain <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m0</span></span></code> and that
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code>. Deriving these conditions corresponds to proving that the only
possible constructor of <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code> and that we can invert
the arrow in the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code>. This inversion is possible because <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Le</span></span></code>
is the smallest set closed by the constructors <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">LeO</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">LeS</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">inversion_clear</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m, m0 : nat
  H0 : Le n m0
  ============================
  P n (S m0)
</span></dd>
</dl>
</div>
<p>Note that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> has been substituted in the goal for <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> and that the
hypothesis <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> has been added to the context.</p>
<p>Sometimes it is interesting to have the equality <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code> in the
context to use it after. In that case we can use <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> that does
not clear the equalities:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m : nat
  H : Le (S n) m
  n0, m0 : nat
  H1 : Le n m0
  H0 : n0</span><span> =</span><span> n
  H2 : S m0</span><span> =</span><span> m
  ============================
  P n (S m0)
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Dependent inversion</p>
<p>Let us consider the following goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Abort</span><span>.</span><span>
</span></dt><dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span>), </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  ============================
  </span><span class="ansi-bold">forall</span><span> (n m : nat) (H : Le (S n) m), Q (S n) m H
</span></dd>
</dl>
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m : nat
  H : Le (S n) m
  ============================
  Q (S n) m H
</span></dd>
</dl>
</div>
<p>As <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> occurs in the goal, we may want to reason by cases on its
structure and so, we would like inversion tactics to substitute <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> by
the corresponding &#64;term in constructor form. Neither <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> nor
<a class="reference internal" href="#coq:tacn.inversion_clear" title="inversion_clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_clear</span></code></a> do such a substitution. To have such a behavior we
use the dependent inversion tactics:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">inversion_clear</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Q : </span><span class="ansi-bold">forall</span><span> n m : nat, Le n m</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  n, m, m0 : nat
  l : Le n m0
  ============================
  Q (S n) (S m0) (LeS n m0 l)
</span></dd>
</dl>
</div>
<p>Note that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> has been substituted by <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">LeS</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m0</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> by <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m0</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Using <a class="reference internal" href="#coq:tacn.inversion_sigma" title="inversion_sigma"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion_sigma</span></code></a></p>
<p>Let us consider the following inductive type of
length-indexed lists, and a lemma about inverting equality of cons:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Logic.Eqdep_dec</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">cons</span><span> {</span><span class="coqdoc-var">n</span><span>} (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">xs</span><span> : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></dt><dd><span>vec is defined
vec_rect is defined
vec_ind is defined
vec_rec is defined
vec_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">invert_cons</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span>,</span><span>
         &#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> = &#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span>
         -&gt; </span><span class="coqdoc-var">xs</span><span> = </span><span class="coqdoc-var">ys</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (n : nat) (x : A) (xs : vec A n) (y : A) (ys : vec A n),
  cons A x xs</span><span> =</span><span> cons A y ys</span><span> -&gt;</span><span> xs</span><span> =</span><span> ys
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Proof</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  n : nat
  x : A
  xs : vec A n
  y : A
  ys : vec A n
  H : cons A x xs</span><span> =</span><span> cons A y ys
  ============================
  xs</span><span> =</span><span> ys
</span></dd>
</dl>
</div>
<p>After performing inversion, we are left with an equality of existTs:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  n : nat
  x : A
  xs : vec A n
  y : A
  ys : vec A n
  H : cons A x xs</span><span> =</span><span> cons A y ys
  H1 : x</span><span> =</span><span> y
  H2 : existT (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; vec A n) n xs</span><span> =</span><span>
       existT (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; vec A n) n ys
  ============================
  xs</span><span> =</span><span> ys
</span></dd>
</dl>
</div>
<p>We can turn this equality into a usable form with inversion_sigma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-var">inversion_sigma</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  n : nat
  x : A
  xs : vec A n
  y : A
  ys : vec A n
  H : cons A x xs</span><span> =</span><span> cons A y ys
  H1 : x</span><span> =</span><span> y
  H2_ : n</span><span> =</span><span> n
  H2_0 : eq_rect n (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; vec A n) xs n H2_</span><span> =</span><span> ys
  ============================
  xs</span><span> =</span><span> ys
</span></dd>
</dl>
</div>
<p>To finish cleaning up the proof, we will need to use the fact that
that all proofs of n = n for n a nat are eq_refl:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">end</span><span> </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">proof</span><span> (</span><span class="coqdoc-var">Eqdep_dec.UIP_refl_nat</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">H</span><span>); </span><span class="coqdoc-tactic">subst</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  n : nat
  x : A
  xs : vec A n
  y : A
  ys : vec A n
  H : cons A x xs</span><span> =</span><span> cons A y ys
  H1 : x</span><span> =</span><span> y
  H2_0 : eq_rect n (</span><span class="ansi-bold">fun</span><span> n : nat =&gt; vec A n) xs n eq_refl</span><span> =</span><span> ys
  ============================
  xs</span><span> =</span><span> ys
</span></dd>
<dt><span></span><span class="coqdoc-tactic">simpl</span><span> </span><span class="coqdoc-tactic">in</span><span> *.</span><span>
</span></dt><dd><span>1 goal
  
  A : </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>
  n : nat
  x : A
  xs : vec A n
  y : A
  ys : vec A n
  H : cons A x xs</span><span> =</span><span> cons A y ys
  H1 : x</span><span> =</span><span> y
  H2_0 : xs</span><span> =</span><span> ys
  ============================
  xs</span><span> =</span><span> ys
</span></dd>
</dl>
</div>
<p>Finally, we can finish the proof:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">assumption</span><span>.</span><span>
</span></dt><dd><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../using/libraries/funind.html#coq:tacn.functional-inversion" title="functional inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">functional</span> <span class="pre">inversion</span></code></a></p>
</div>
<section id="helper-tactics">
<h3>Helper tactics<a class="headerlink" href="#helper-tactics" title="Permalink to this headline">¶</a></h3>
<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.decide">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">decide</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a></span></span><a class="headerlink" href="#coq:tacn.decide" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a></span></code> in the form <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">}+{~</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">}</span></span></code> in the goal
with <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">left</span></span> <span class="operator"><span class="pre">_)</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">right</span></span> <span class="operator"><span class="pre">_)</span></span></code>, depending on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a></span></code>.
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a></span></code> must be of type either <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">~</span></span><span class="name"><span class="pre">P</span></span></code>,
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> must be of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Using <a class="reference internal" href="#coq:tacn.decide" title="decide"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">decide</span></code></a> to rewrite the goal</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">Hp</span><span> : {</span><span class="coqdoc-var">P</span><span>} + {~</span><span class="coqdoc-var">P</span><span>}) (</span><span class="coqdoc-var">Hq</span><span> : {</span><span class="coqdoc-var">Q</span><span>} + {~</span><span class="coqdoc-var">Q</span><span>}),</span><span>
    </span><span class="coqdoc-var">P</span><span> -&gt; ~</span><span class="coqdoc-var">Q</span><span> -&gt; (</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">Hp</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">false</span><span>) = (</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">Hq</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">true</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (P Q : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (Hp : </span><span>{</span><span>P</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> P</span><span>}</span><span>) (Hq : </span><span>{</span><span>Q</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> Q</span><span>}</span><span>),
  P</span><span> -&gt;</span><span> </span><span>~</span><span> Q</span><span> -&gt;</span><span> (</span><span class="ansi-bold">if</span><span> Hp </span><span class="ansi-bold">then</span><span> true </span><span class="ansi-bold">else</span><span> false)</span><span> =</span><span> (</span><span class="ansi-bold">if</span><span> Hq </span><span class="ansi-bold">then</span><span> false </span><span class="ansi-bold">else</span><span> true)
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">Hp</span><span> </span><span class="coqdoc-var">Hq</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">nq</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Hp : </span><span>{</span><span>P</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> P</span><span>}</span><span>
  Hq : </span><span>{</span><span>Q</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> Q</span><span>}</span><span>
  p : P
  nq : </span><span>~</span><span> Q
  ============================
  (</span><span class="ansi-bold">if</span><span> Hp </span><span class="ansi-bold">then</span><span> true </span><span class="ansi-bold">else</span><span> false)</span><span> =</span><span> (</span><span class="ansi-bold">if</span><span> Hq </span><span class="ansi-bold">then</span><span> false </span><span class="ansi-bold">else</span><span> true)
</span></dd>
<dt><span></span><span class="coqdoc-var">decide</span><span> </span><span class="coqdoc-var">Hp</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Hp : </span><span>{</span><span>P</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> P</span><span>}</span><span>
  Hq : </span><span>{</span><span>Q</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> Q</span><span>}</span><span>
  nq : </span><span>~</span><span> Q
  p : P
  ============================
  true</span><span> =</span><span> (</span><span class="ansi-bold">if</span><span> Hq </span><span class="ansi-bold">then</span><span> false </span><span class="ansi-bold">else</span><span> true)
</span></dd>
<dt><span></span><span class="coqdoc-var">decide</span><span> </span><span class="coqdoc-var">Hq</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">nq</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  P, Q : </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>
  Hp : </span><span>{</span><span>P</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> P</span><span>}</span><span>
  Hq : </span><span>{</span><span>Q</span><span>}</span><span> </span><span>+</span><span> </span><span>{</span><span>~</span><span> Q</span><span>}</span><span>
  p : P
  nq : </span><span>~</span><span> Q
  ============================
  true</span><span> =</span><span> true
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>No more goals.
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Qed</span><span>.</span><span>
</span></dt></dl>
</div>
</div>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.decide-equality">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">decide</span></span></span> <span><span><span class="pre">equality</span></span></span></span></span><a class="headerlink" href="#coq:tacn.decide-equality" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a goal of the form <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">y</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">R,</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="curlies"><span class="pre">{</span><span><span><span class="pre">x</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">y</span></span></span><span class="pre">}</span></span> <span><span><span class="pre">+</span></span></span> <span class="curlies"><span class="pre">{</span><span><span><span class="pre">~</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">y</span></span></span><span class="pre">}</span></span></span></code> or
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">y</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">R,</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">(x</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">y)</span></span></span> <span><span><span class="pre">\/</span></span></span> <span><span><span class="pre">(~</span></span></span> <span><span><span class="pre">x</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">y)</span></span></span></span></code>, where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">R</span></span></code> is an
inductive type whose constructors do not take proofs or functions as
arguments, nor objects in dependent types.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.compare">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">compare</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a></span></span><a class="headerlink" href="#coq:tacn.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>s of an
inductive datatype. If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> is the current goal, it leaves the
sub-goals <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">G</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">~</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span><sub><span class="pre">2</span></sub></span></a> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">G</span></span></span></span></code>.
The type of the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a></span></code>s must satisfy the same restrictions as in the
tactic <a class="reference internal" href="#coq:tacn.decide-equality" title="decide equality"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">decide</span> <span class="pre">equality</span></code></a>.</p>
</dd></dl>

<dl class="coq tacn">
<dt class="sig sig-object coq" id="coq:tacn.dependent-rewrite">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">rewrite</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span><span class="pre">-&gt;</span></span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">&lt;-</span></span></span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:tacn.dependent-rewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> has type
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">b</span></span><span class="operator"><span class="pre">)=(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a'</span></span> <span class="name"><span class="pre">b'</span></span><span class="operator"><span class="pre">)</span></span></code> in the local context (i.e. each
term of the equality has a sigma type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">)}</span></span></code>) this tactic
rewrites <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code> into <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a'</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> into <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b'</span></span></code> in the current goal.
This tactic works even if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> is also a sigma type. This kind of
equalities between dependent pairs may be derived by the
<a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span><span class="pre">-&gt;</span></span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">&lt;-</span></span></span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code></dt><dd><p>By default, the equality is applied from left to right.  Specify <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> to
apply the equality from right to left.</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="generation-of-induction-principles-with-scheme">
<span id="proofschemes-induction-principles"></span><h2>Generation of induction principles with <code class="docutils literal notranslate"><span class="pre">Scheme</span></code><a class="headerlink" href="#generation-of-induction-principles-with-scheme" title="Permalink to this headline">¶</a></h2>
<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Scheme">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Scheme</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <a class="reference internal" href="#grammar-token-scheme_kind"><span class="hole"><span class="pre">scheme_kind</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">:=</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <a class="reference internal" href="#grammar-token-scheme_kind"><span class="hole"><span class="pre">scheme_kind</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Scheme" title="Permalink to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-scheme_kind"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-scheme_kind"><span class="hole">scheme_kind</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole">scheme_type</span></a> <span><span>for</span></span> <a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole">reference</span></a> <span><span>Sort</span></span> <a class="reference internal" href="#grammar-token-sort_family"><span class="hole">sort_family</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-scheme_type"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole">scheme_type</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Induction</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Minimality</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Elimination</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Case</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-sort_family"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-sort_family"><span class="hole">sort_family</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Prop</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>SProp</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Set</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>Type</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Generates <a class="reference internal" href="../../language/core/inductive.html#term-induction-principle"><span class="xref std std-term">induction principles</span></a> with given
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">scheme</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">type</span></span></span></span></code>s and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">scheme</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">sort</span></span></span></span></code>s for an inductive type. In the case
where the inductive definition is a mutual inductive definition, the
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">with</span></span></span></span></code> clause is used to generate a mutually recursive inductive scheme
for each clause of the mutual inductive type.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code></dt><dd><p>The name of the scheme. If not provided, the name will be determined
automatically from the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole"><span class="pre">scheme_type</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-sort_family"><span class="hole"><span class="pre">sort_family</span></span></a></span></code>.</p>
</dd>
</dl>
<p>The following <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole"><span class="pre">scheme_type</span></span></a></span></code>s generate induction principles with
given properties:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 27%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole"><span class="pre">scheme_type</span></span></a></span></code></p></th>
<th class="head"><p>Recursive</p></th>
<th class="head"><p>Dependent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Induction</span></span></span></span></code></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Minimality</span></span></span></span></code></p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Elimination</span></span></span></span></code></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Case</span></span></span></span></code></p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
<p>See examples of the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole"><span class="pre">scheme_type</span></span></a></span></code>s <a class="reference internal" href="#scheme-example"><span class="std std-ref">here</span></a>.</p>
</dd></dl>

<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Scheme-Equality">
<span id="coq:cmd.Scheme-Boolean-Equality"></span><em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Scheme</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">Boolean</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span><span class="pre">Equality</span></span></span> <span><span><span class="pre">for</span></span></span> <a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole"><span class="pre">reference</span></span></a></span></span><a class="headerlink" href="#coq:cmd.Scheme-Equality" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to generate a Boolean equality for <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole"><span class="pre">reference</span></span></a></span></code>. If
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Boolean</span></span></span></span></code> is not specified, the command also tries to generate
a proof of the decidability of propositional equality over
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><span class="hole"><span class="pre">reference</span></span></a></span></code>.
If <a class="reference internal" href="../../proof-engine/vernacular-commands.html#grammar-token-reference"><code class="xref std std-token docutils literal notranslate"><span class="pre">reference</span></code></a> involves independent constants or other
inductive types, we recommend defining their equality first.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example: Induction scheme for tree and forest</p>
<blockquote>
<div><p>Currently the automatically-generated <a class="reference internal" href="../../language/core/inductive.html#term-induction-principle"><span class="xref std std-term">induction principles</span></a>
such as <code class="docutils literal notranslate"><span class="pre">odd_ind</span></code> are not useful for mutually-inductive types such as <code class="docutils literal notranslate"><span class="pre">odd</span></code> and <code class="docutils literal notranslate"><span class="pre">even</span></code>.
You can define a mutual induction principle for tree and forest in sort <code class="docutils literal notranslate"><span class="pre">Set</span></code> with
the <a class="reference internal" href="#coq:cmd.Scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> command:</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>B is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
tree_sind is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined
forest_sind is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">tree_forest_rec</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>
  </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_tree_rec</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>forest_tree_rec is defined
tree_forest_rec is defined
tree_forest_rec, forest_tree_rec are recursively defined
</span></dd>
</dl>
</div>
</div></blockquote>
</div></blockquote>
<p>You may now look at the type of tree_forest_rec:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_forest_rec</span><span>.</span><span>
</span></dt><dd><span>tree_forest_rec
     : </span><span class="ansi-bold">forall</span><span> (P : tree</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>) (P0 : forest</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>),
       (</span><span class="ansi-bold">forall</span><span> (a : A) (f : forest), P0 f</span><span> -&gt;</span><span> P (node a f))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> b : B, P0 (leaf b))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> t : tree, P t</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> f : forest, P0 f</span><span> -&gt;</span><span> P0 (cons t f))</span><span> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> t : tree, P t
</span></dd>
</dl>
</div>
<p>This principle involves two different predicates for trees and forests;
it also has three premises each one corresponding to a constructor of
one of the inductive definitions.</p>
<p>The principle <code class="docutils literal notranslate"><span class="pre">forest_tree_rec</span></code> shares exactly the same premises, only
the conclusion now refers to the property of forests.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Predicates odd and even on naturals</p>
<p>Let odd and even be inductively defined as:</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">odd</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">oddS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">odd</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">evenO</span><span> : </span><span class="coqdoc-var">even</span><span> 0</span><span>
| </span><span class="coqdoc-var">evenS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>odd, even are defined
odd_ind is defined
odd_sind is defined
even_ind is defined
even_sind is defined
</span></dd>
</dl>
</div>
</div></blockquote>
<p>The following command generates a powerful elimination principle:</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">odd_even</span><span> := </span><span class="coqdoc-var">Minimality</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">even_odd</span><span> := </span><span class="coqdoc-var">Minimality</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>even_odd is defined
odd_even is defined
odd_even, even_odd are recursively defined
</span></dd>
</dl>
</div>
</div></blockquote>
<p>The type of odd_even for instance will be:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">odd_even</span><span>.</span><span>
</span></dt><dd><span>odd_even
     : </span><span class="ansi-bold">forall</span><span> P P0 : nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>,
       (</span><span class="ansi-bold">forall</span><span> n : nat, even n</span><span> -&gt;</span><span> P0 n</span><span> -&gt;</span><span> P (S n))</span><span> -&gt;</span><span>
       P0 0</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> n : nat, odd n</span><span> -&gt;</span><span> P n</span><span> -&gt;</span><span> P0 (S n))</span><span> -&gt;</span><span>
       </span><span class="ansi-bold">forall</span><span> n : nat, odd n</span><span> -&gt;</span><span> P n
</span></dd>
</dl>
</div>
<p>The type of <code class="docutils literal notranslate"><span class="pre">even_odd</span></code> shares the same premises but the conclusion is
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat,</span> <span class="pre">even</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">P0</span> <span class="pre">n</span></code>.</p>
</div>
<blockquote id="scheme-example">
<div><div class="admonition note">
<p class="admonition-title">Example: <code class="docutils literal notranslate"><span class="pre">Scheme</span></code> commands with various <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-scheme_type"><span class="hole"><span class="pre">scheme_type</span></span></a></span></code>s</p>
<p>Let us demonstrate the difference between the Scheme commands.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">Elimination</span><span> </span><span class="coqdoc-var">Schemes</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Nat</span><span> :=</span><span>
| </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">Nat</span><span>
| </span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">Nat</span><span> -&gt; </span><span class="coqdoc-var">Nat</span><span>.</span><span>
</span></dt><dd><span>Nat is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-comment">(* dependent, recursive *)</span></dt><dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">Nat</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>Nat_rec is defined
Nat_rec is recursively defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">Nat_rec</span><span>.</span><span>
</span></dt><dd><span>Nat_rec :
</span><span class="ansi-bold">forall</span><span> P : Nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
P z</span><span> -&gt;</span><span> (</span><span class="ansi-bold">forall</span><span> n : Nat, P n</span><span> -&gt;</span><span> P (s n))</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : Nat, P n

Nat_rec is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">Nat_rec</span><span> P%function_scope f f0%function_scope n
Nat_rec is transparent
Expands to: Constant Top.Nat_rec
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-comment">(* non-dependent, recursive *)</span></dt><dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">Minimality</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">Nat</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>Nat_rec_nodep is defined
Nat_rec_nodep is recursively defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">Nat_rec_nodep</span><span>.</span><span>
</span></dt><dd><span>Nat_rec_nodep : </span><span class="ansi-bold">forall</span><span> P : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, P</span><span> -&gt;</span><span> (Nat</span><span> -&gt;</span><span> P</span><span> -&gt;</span><span> P)</span><span> -&gt;</span><span> Nat</span><span> -&gt;</span><span> P

Nat_rec_nodep is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">Nat_rec_nodep</span><span> P%type_scope f f0%function_scope n
Nat_rec_nodep is transparent
Expands to: Constant Top.Nat_rec_nodep
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-comment">(* dependent, non-recursive *)</span></dt><dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">Elimination</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">Nat</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>Nat_case is defined
Nat_case is recursively defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">Nat_case</span><span>.</span><span>
</span></dt><dd><span>Nat_case :
</span><span class="ansi-bold">forall</span><span> P : Nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>,
P z</span><span> -&gt;</span><span> (</span><span class="ansi-bold">forall</span><span> n : Nat, P n</span><span> -&gt;</span><span> P (s n))</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> n : Nat, P n

Nat_case is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">Nat_case</span><span> P%function_scope f f0%function_scope n
Nat_case is transparent
Expands to: Constant Top.Nat_case
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-comment">(* non-dependent, non-recursive *)</span></dt><dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">Case</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">Nat</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd><span>Nat_case_nodep is defined
Nat_case_nodep is recursively defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">Nat_case_nodep</span><span>.</span><span>
</span></dt><dd><span>Nat_case_nodep : </span><span class="ansi-bold">forall</span><span> P : </span><span class="ansi-fg-yellow ansi-bold">Set</span><span>, P</span><span> -&gt;</span><span> (Nat</span><span> -&gt;</span><span> P</span><span> -&gt;</span><span> P)</span><span> -&gt;</span><span> Nat</span><span> -&gt;</span><span> P

Nat_case_nodep is not universe polymorphic
Arguments </span><span class="ansi-fg-light-green">Nat_case_nodep</span><span> P%type_scope f f0%function_scope n
Nat_case_nodep is transparent
Expands to: Constant Top.Nat_case_nodep
</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<section id="automatic-declaration-of-schemes">
<h3>Automatic declaration of schemes<a class="headerlink" href="#automatic-declaration-of-schemes" title="Permalink to this headline">¶</a></h3>
<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Elimination-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Elimination</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Elimination-Schemes" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> enables automatic declaration of induction principles when defining a new
inductive type.  Defaults to on.</p>
</dd></dl>

<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Nonrecursive-Elimination-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Nonrecursive</span></span></span> <span><span><span class="pre">Elimination</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Nonrecursive-Elimination-Schemes" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> enables automatic declaration of induction
principles for types declared with the <a class="reference internal" href="../../language/core/variants.html#coq:cmd.Variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a> and
<a class="reference internal" href="../../language/core/records.html#coq:cmd.Record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a> commands.  Defaults to off.</p>
</dd></dl>

<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Case-Analysis-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Case</span></span></span> <span><span><span class="pre">Analysis</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Case-Analysis-Schemes" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> governs the generation of case analysis lemmas for inductive types,
i.e. corresponding to the pattern matching term alone and without fixpoint.</p>
</dd></dl>

<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Boolean-Equality-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Boolean</span></span></span> <span><span><span class="pre">Equality</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Boolean-Equality-Schemes" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object coq" id="coq:flag.Decidable-Equality-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Decidable</span></span></span> <span><span><span class="pre">Equality</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Decidable-Equality-Schemes" title="Permalink to this definition">¶</a></dt>
<dd><p>These <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flags</span></a> control the automatic declaration of those Boolean equalities (see
the second variant of <code class="docutils literal notranslate"><span class="pre">Scheme</span></code>).</p>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You have to be careful with these flags since Coq may now reject well-defined
inductive types because it cannot compute a Boolean equality for them.</p>
</div>
<dl class="coq flag">
<dt class="sig sig-object coq" id="coq:flag.Rewriting-Schemes">
<em class="property"><span class="sigannot"><span class="pre">Flag</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Rewriting</span></span></span> <span><span><span class="pre">Schemes</span></span></span></span></span><a class="headerlink" href="#coq:flag.Rewriting-Schemes" title="Permalink to this definition">¶</a></dt>
<dd><p>This <a class="reference internal" href="../../language/core/basic.html#term-flag"><span class="xref std std-term">flag</span></a> governs generation of equality-related schemes such as congruence.</p>
</dd></dl>

</section>
<section id="combined-scheme">
<h3>Combined Scheme<a class="headerlink" href="#combined-scheme" title="Permalink to this headline">¶</a></h3>
<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Combined-Scheme">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Combined</span></span></span> <span><span><span class="pre">Scheme</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">def</span></sub></span></a> <span><span><span class="pre">from</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Combined-Scheme" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines induction principles generated
by the <a class="reference internal" href="#coq:cmd.Scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> command.
Each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a different inductive principle that must  belong
to the same package of mutual inductive principle definitions.
This command generates <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">def</span></sub></span></a></span></code> as the conjunction of the
principles: it is built from the common premises of the principles
and concluded by the conjunction of their conclusions.
In the case where all the inductive principles used are in sort
<code class="docutils literal notranslate"><span class="pre">Prop</span></code>, the propositional conjunction <code class="docutils literal notranslate"><span class="pre">and</span></code> is used, otherwise
the simple product <code class="docutils literal notranslate"><span class="pre">prod</span></code> is used instead.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>We can define the induction principles for trees and forests using:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">tree_forest_ind</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_tree_ind</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>forest_tree_ind is defined
tree_forest_ind is defined
tree_forest_ind, forest_tree_ind are recursively defined
</span></dd>
</dl>
</div>
<p>Then we can build the combined induction principle which gives the
conjunction of the conclusions of each individual principle:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Combined Scheme</span><span> </span><span class="coqdoc-var">tree_forest_mutind</span><span> </span><span class="coqdoc-var">from</span><span> </span><span class="coqdoc-var">tree_forest_ind</span><span>,</span><span class="coqdoc-var">forest_tree_ind</span><span>.</span><span>
</span></dt><dd><span>tree_forest_mutind is defined
tree_forest_mutind is recursively defined
</span></dd>
</dl>
</div>
<p>The type of tree_forest_mutind will be:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_forest_mutind</span><span>.</span><span>
</span></dt><dd><span>tree_forest_mutind
     : </span><span class="ansi-bold">forall</span><span> (P : tree</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>) (P0 : forest</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>),
       (</span><span class="ansi-bold">forall</span><span> (a : A) (f : forest), P0 f</span><span> -&gt;</span><span> P (node a f))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> b : B, P0 (leaf b))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> t : tree, P t</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> f : forest, P0 f</span><span> -&gt;</span><span> P0 (cons t f))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> t : tree, P t)</span><span> /\</span><span> (</span><span class="ansi-bold">forall</span><span> f : forest, P0 f)
</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>We can also combine schemes at sort <code class="docutils literal notranslate"><span class="pre">Type</span></code>:</p>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Scheme</span><span> </span><span class="coqdoc-var">tree_forest_rect</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Type</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_tree_rect</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Type</span><span>.</span><span>
</span></dt><dd><span>forest_tree_rect is defined
tree_forest_rect is defined
tree_forest_rect, forest_tree_rect are recursively defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Combined Scheme</span><span> </span><span class="coqdoc-var">tree_forest_mutrect</span><span> </span><span class="coqdoc-var">from</span><span> </span><span class="coqdoc-var">tree_forest_rect</span><span>, </span><span class="coqdoc-var">forest_tree_rect</span><span>.</span><span>
</span></dt><dd><span>tree_forest_mutrect is defined
tree_forest_mutrect is recursively defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_forest_mutrect</span><span>.</span><span>
</span></dt><dd><span>tree_forest_mutrect
     : </span><span class="ansi-bold">forall</span><span> (P : tree</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>) (P0 : forest</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Type</span><span>),
       (</span><span class="ansi-bold">forall</span><span> (a : A) (f : forest), P0 f</span><span> -&gt;</span><span> P (node a f))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> b : B, P0 (leaf b))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> t : tree, P t</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> f : forest, P0 f</span><span> -&gt;</span><span> P0 (cons t f))</span><span> -&gt;</span><span>
       (</span><span class="ansi-bold">forall</span><span> t : tree, P t)</span><span> *</span><span> (</span><span class="ansi-bold">forall</span><span> f : forest, P0 f)
</span></dd>
</dl>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../using/libraries/funind.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a></p>
</div>
</section>
</section>
<section id="generation-of-inversion-principles-with-derive-inversion">
<span id="derive-inversion"></span><h2>Generation of inversion principles with <code class="docutils literal notranslate"><span class="pre">Derive</span></code> <code class="docutils literal notranslate"><span class="pre">Inversion</span></code><a class="headerlink" href="#generation-of-inversion-principles-with-derive-inversion" title="Permalink to this headline">¶</a></h2>
<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Derive-Inversion">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Derive</span></span></span> <span><span><span class="pre">Inversion</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">Sort</span></span></span> <a class="reference internal" href="#grammar-token-sort_family"><span class="hole"><span class="pre">sort_family</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Derive-Inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an inversion lemma for the
<a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactic.  <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name
of the generated lemma.  <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a> should be in the form
<a class="reference internal" href="../../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> or <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(forall</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="../../language/core/modules.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> where
<a class="reference internal" href="../../language/core/modules.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> is the name of an inductive
predicate and <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../../language/core/assumptions.html#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> binds the variables occurring in the term
<a class="reference internal" href="../../language/core/basic.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. The lemma is generated for the sort
<a class="reference internal" href="#grammar-token-sort_family"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort_family</span></code></a> corresponding to <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><code class="xref std std-token docutils literal notranslate"><span class="pre">one_term</span></code></a>.
Applying the lemma is equivalent to inverting the instance with the
<a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactic.</p>
</dd></dl>

<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Derive-Inversion_clear">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Derive</span></span></span> <span><span><span class="pre">Inversion</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">clear</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">Sort</span></span></span> <a class="reference internal" href="#grammar-token-sort_family"><span class="hole"><span class="pre">sort_family</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#coq:cmd.Derive-Inversion_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>When applied, it is equivalent to having inverted the instance with the
tactic inversion replaced by the tactic <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code>.</p>
</dd></dl>

<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Derive-Dependent-Inversion">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Derive</span></span></span> <span><span><span class="pre">Dependent</span></span></span> <span><span><span class="pre">Inversion</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span><span><span class="pre">Sort</span></span></span> <a class="reference internal" href="#grammar-token-sort_family"><span class="hole"><span class="pre">sort_family</span></span></a></span></span><a class="headerlink" href="#coq:cmd.Derive-Dependent-Inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>When applied, it is equivalent to having inverted the instance with
the tactic <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code>.</p>
</dd></dl>

<dl class="coq cmd">
<dt class="sig sig-object coq" id="coq:cmd.Derive-Dependent-Inversion_clear">
<em class="property"><span class="sigannot"><span class="pre">Command</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Derive</span></span></span> <span><span><span class="pre">Dependent</span></span></span> <span><span><span class="pre">Inversion</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">clear</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span><span class="pre">with</span></span></span> <a class="reference internal" href="../../language/core/basic.html#grammar-token-one_term"><span class="hole"><span class="pre">one_term</span></span></a> <span><span><span class="pre">Sort</span></span></span> <a class="reference internal" href="#grammar-token-sort_family"><span class="hole"><span class="pre">sort_family</span></span></a></span></span><a class="headerlink" href="#coq:cmd.Derive-Dependent-Inversion_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>When applied, it is equivalent to having inverted the instance
with the tactic <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion_clear</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Consider the relation <code class="docutils literal notranslate"><span class="pre">Le</span></code> over natural numbers and the following
parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Le</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">LeO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> 0 </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">LeS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span><span>
</span></dt><dd><span>Le is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>P is declared
</span></dd>
</dl>
</div>
<p>To generate the inversion lemma for the instance <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">Le</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> and the
sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, we do:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Derive</span><span> </span><span class="coqdoc-var">Inversion_clear</span><span> </span><span class="coqdoc-var">leminv</span><span> </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd><span>leminv is defined
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">leminv</span><span>.</span><span>
</span></dt><dd><span>leminv
     : </span><span class="ansi-bold">forall</span><span> (n m : nat) (P : nat</span><span> -&gt;</span><span> nat</span><span> -&gt;</span><span> </span><span class="ansi-fg-yellow ansi-bold">Prop</span><span>),
       (</span><span class="ansi-bold">forall</span><span> m0 : nat, Le n m0</span><span> -&gt;</span><span> P n (S m0))</span><span> -&gt;</span><span> Le (S n) m</span><span> -&gt;</span><span> P n m
</span></dd>
</dl>
</div>
<p>Then we can use the proven inversion lemma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span>), </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n m : nat, Le (S n) m</span><span> -&gt;</span><span> P n m
</span></dd>
<dt class="coqtop-hidden"><span></span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Show</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">leminv</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : Le (S n) m
  ============================
  </span><span class="ansi-bold">forall</span><span> m0 : nat, Le n m0</span><span> -&gt;</span><span> P n (S m0)
</span></dd>
</dl>
</div>
</div>
</section>
<section id="examples-of-dependent-destruction-dependent-induction">
<span id="dependent-induction-examples"></span><h2>Examples of <a class="reference internal" href="#coq:tacn.dependent-destruction" title="dependent destruction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code></a> / <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a><a class="headerlink" href="#examples-of-dependent-destruction-dependent-induction" title="Permalink to this headline">¶</a></h2>
<p>The tactics <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> and <a class="reference internal" href="#coq:tacn.dependent-destruction" title="dependent destruction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code></a> are another
solution for inverting inductive predicate instances and potentially
doing induction at the same time. It is based on the <code class="docutils literal notranslate"><span class="pre">BasicElim</span></code> tactic
of Conor McBride which works by abstracting each argument of an
inductive instance by a variable and constraining it by equalities
afterwards. This way, the usual induction and destruct tactics can be
applied to the abstracted instance and after simplification of the
equalities we get the expected goals.</p>
<p>The abstracting tactic is called generalize_eqs and it takes as
argument a hypothesis to generalize. It uses the JMeq datatype
defined in Coq.Logic.JMeq, hence we need to require it before. For
example, revisiting the first example of the inversion documentation:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Logic.JMeq</span><span>.</span><span>
</span></dt><dt><span></span><span>
</span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Le</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
     | </span><span class="coqdoc-var">LeO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> 0 </span><span class="coqdoc-var">n</span><span>
     | </span><span class="coqdoc-var">LeS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>Le is defined
Le_rect is defined
Le_ind is defined
Le_rec is defined
Le_sind is defined
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>P is declared
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n m : nat, Le (S n) m</span><span> -&gt;</span><span> P n m
</span></dd>
<dt><span></span><span>
</span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">generalize_eqs</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m, gen_x : nat
  H : Le gen_x m
  ============================
  gen_x</span><span> =</span><span> S n</span><span> -&gt;</span><span> P n m
</span></dd>
</dl>
</div>
<p>The index <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code> gets abstracted by a variable here, but a corresponding
equality is added under the abstract instance so that no information
is actually lost. The goal is now almost amenable to do induction or
case analysis. One should indeed first move <code class="docutils literal notranslate"><span class="pre">n</span></code> into the goal to
strengthen it before doing induction, or <code class="docutils literal notranslate"><span class="pre">n</span></code> will be fixed in the
inductive hypotheses (this does not matter for case analysis). As a
rule of thumb, all the variables that appear inside constructors in
the indices of the hypothesis should be generalized. This is exactly
what the <code class="docutils literal notranslate"><span class="pre">generalize_eqs_vars</span></code> variant does:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">generalize_eqs_vars</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>2 goals
  
  n, n0 : nat
  ============================
  0</span><span> =</span><span> S n</span><span> -&gt;</span><span> P n n0

goal 2 is:
 S n0</span><span> =</span><span> S n</span><span> -&gt;</span><span> P n (S m)
</span></dd>
</dl>
</div>
<p>As the hypothesis itself did not appear in the goal, we did not need
to use an heterogeneous equality to relate the new hypothesis to the
old one (which just disappeared here). However, the tactic works just
as well in this case, e.g.:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt class="coqtop-hidden"><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Program.Equality</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">nat</span><span>), </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>Q is declared
</span></dd>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span>), </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (n m : nat) (p : Le (S n) m), Q (S n) m p
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  p : Le (S n) m
  ============================
  Q (S n) m p
</span></dd>
<dt><span></span><span class="coqdoc-tactic">generalize_eqs_vars</span><span> </span><span class="coqdoc-var">p</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  m, gen_x : nat
  p : Le gen_x m
  ============================
  </span><span class="ansi-bold">forall</span><span> (n : nat) (p0 : Le (S n) m), gen_x</span><span> =</span><span> S n</span><span> -&gt;</span><span> p</span><span> ~=</span><span> p0</span><span> -&gt;</span><span> Q (S n) m p0
</span></dd>
</dl>
</div>
<p>One drawback of this approach is that in the branches one will have to
substitute the equalities back into the instance to get the right
assumptions. Sometimes injection of constructors will also be needed
to recover the needed equalities. Also, some subgoals should be
directly solved because of inconsistent contexts arising from the
constraints on indexes. The nice thing is that we can make a tactic
based on discriminate, injection and variants of substitution to
automatically do such simplifications (which may involve the axiom K).
This is what the <code class="docutils literal notranslate"><span class="pre">simplify_dep_elim</span></code> tactic from <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>
does. For example, we might simplify the previous goals considerably:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">p</span><span> ; </span><span class="coqdoc-var">simplify_dep_elim</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  p : Le n m
  IHp : </span><span class="ansi-bold">forall</span><span> (n0 : nat) (p0 : Le (S n0) m),
        n</span><span> =</span><span> S n0</span><span> -&gt;</span><span> p</span><span> ~=</span><span> p0</span><span> -&gt;</span><span> Q (S n0) m p0
  ============================
  Q (S n) (S m) (LeS n m p)
</span></dd>
</dl>
</div>
<p>The higher-order tactic <code class="docutils literal notranslate"><span class="pre">do_depind</span></code> defined in <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>
takes a tactic and combines the building blocks we have seen with it:
generalizing by equalities calling the given tactic with the
generalized induction hypothesis as argument and cleaning the subgoals
with respect to equalities. Its most important instantiations
are <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> and <a class="reference internal" href="#coq:tacn.dependent-destruction" title="dependent destruction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">destruction</span></code></a> that do induction or
simply case analysis on the generalized hypothesis. For example we can
redo what we've done manually with dependent destruction:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">ex</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> n m : nat, Le (S n) m</span><span> -&gt;</span><span> P n m
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  n, m : nat
  H : Le (S n) m
  ============================
  P n m
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">destruction</span><span> </span><span class="coqdoc-var">H</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n, m : nat
  H : Le n m
  ============================
  P n (S m)
</span></dd>
</dl>
</div>
<p>This gives essentially the same result as inversion. Now if the
destructed hypothesis actually appeared in the goal, the tactic would
still be able to invert it, contrary to dependent inversion. Consider
the following example on vectors:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>A is declared
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">vector</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
         | </span><span class="coqdoc-var">vnil</span><span> : </span><span class="coqdoc-var">vector</span><span> 0</span><span>
         | </span><span class="coqdoc-var">vcons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">vector</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">vector</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span><span>
</span></dt><dd class="coqtop-hidden"><span>vector is defined
vector_rect is defined
vector_ind is defined
vector_rec is defined
vector_sind is defined
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">v</span><span> : </span><span class="coqdoc-var">vector</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>),</span><span>
         </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">v'</span><span> : </span><span class="coqdoc-var">vector</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">A</span><span>, </span><span class="coqdoc-var">v</span><span> = </span><span class="coqdoc-var">vcons</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">v'</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (n : nat) (v : vector (S n)),
  </span><span>exists</span><span> (v' : vector n)</span><span> </span><span>(a : A)</span><span>,</span><span> v</span><span> =</span><span> vcons a v'
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">v</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  n : nat
  v : vector (S n)
  ============================
  </span><span>exists</span><span> (v' : vector n)</span><span> </span><span>(a : A)</span><span>,</span><span> v</span><span> =</span><span> vcons a v'
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">destruction</span><span> </span><span class="coqdoc-var">v</span><span>.</span><span>
</span></dt><dd><span>1 goal
  
  n : nat
  a : A
  v : vector n
  ============================
  </span><span>exists</span><span> (v' : vector n)</span><span> </span><span>(a0 : A)</span><span>,</span><span> vcons a v</span><span> =</span><span> vcons a0 v'
</span></dd>
</dl>
</div>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">v</span></code> variable can be replaced in the goal by the
generalized hypothesis only when it has a type of the form <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">(S</span> <span class="pre">n)</span></code>,
that is only in the second case of the destruct. The first one is
dismissed because <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span> <span class="pre">&lt;&gt;</span> <span class="pre">0</span></code>.</p>
<section id="a-larger-example">
<h3>A larger example<a class="headerlink" href="#a-larger-example" title="Permalink to this headline">¶</a></h3>
<p>Let's see how the technique works with induction on inductive
predicates on a real example. We will develop an example application
to the theory of simply-typed lambda-calculus formalized in a
dependently-typed style:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-keyword">type</span><span> : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
         | </span><span class="coqdoc-var">base</span><span> : </span><span class="coqdoc-keyword">type</span><span>
         | </span><span class="coqdoc-var">arrow</span><span> : </span><span class="coqdoc-keyword">type</span><span> -&gt; </span><span class="coqdoc-keyword">type</span><span> -&gt; </span><span class="coqdoc-keyword">type</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>type is defined
type_rect is defined
type_ind is defined
type_rec is defined
type_sind is defined
</span></dd>
</dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot; t --&gt; t' &quot; := (</span><span class="coqdoc-var">arrow</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">t'</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 20, </span><span class="coqdoc-var">t'</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-var">next</span><span> </span><span class="coqdoc-keyword">level</span><span>).</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">ctx</span><span> : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
         | </span><span class="coqdoc-var">empty</span><span> : </span><span class="coqdoc-var">ctx</span><span>
         | </span><span class="coqdoc-var">snoc</span><span> : </span><span class="coqdoc-var">ctx</span><span> -&gt; </span><span class="coqdoc-keyword">type</span><span> -&gt; </span><span class="coqdoc-var">ctx</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>ctx is defined
ctx_rect is defined
ctx_ind is defined
ctx_rec is defined
ctx_sind is defined
</span></dd>
</dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot; G , tau &quot; := (</span><span class="coqdoc-var">snoc</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 20, </span><span class="coqdoc-var">tau</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-var">next</span><span> </span><span class="coqdoc-keyword">level</span><span>).</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">conc</span><span> (</span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span> : </span><span class="coqdoc-var">ctx</span><span>) : </span><span class="coqdoc-var">ctx</span><span> :=</span><span>
         </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">D</span><span> </span><span class="coqdoc-keyword">with</span><span>
         | </span><span class="coqdoc-var">empty</span><span> =&gt; </span><span class="coqdoc-var">G</span><span>
         | </span><span class="coqdoc-var">snoc</span><span> </span><span class="coqdoc-var">D'</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">snoc</span><span> (</span><span class="coqdoc-var">conc</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D'</span><span>) </span><span class="coqdoc-var">x</span><span>
         </span><span class="coqdoc-keyword">end</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>conc is defined
conc is recursively defined (guarded on 2nd argument)
</span></dd>
</dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Notation</span><span> &quot; G ; D &quot; := (</span><span class="coqdoc-var">conc</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 20).</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">term</span><span> : </span><span class="coqdoc-var">ctx</span><span> -&gt; </span><span class="coqdoc-keyword">type</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
         | </span><span class="coqdoc-var">ax</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span>, </span><span class="coqdoc-var">tau</span><span>) </span><span class="coqdoc-var">tau</span><span>
         | </span><span class="coqdoc-var">weak</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span>,</span><span>
                    </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span> -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">tau'</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span>, </span><span class="coqdoc-var">tau'</span><span>) </span><span class="coqdoc-var">tau</span><span>
         | </span><span class="coqdoc-var">abs</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span> </span><span class="coqdoc-var">tau'</span><span>,</span><span>
                   </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span> , </span><span class="coqdoc-var">tau</span><span>) </span><span class="coqdoc-var">tau'</span><span> -&gt; </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G</span><span> (</span><span class="coqdoc-var">tau</span><span> --&gt; </span><span class="coqdoc-var">tau'</span><span>)</span><span>
         | </span><span class="coqdoc-var">app</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span> </span><span class="coqdoc-var">tau'</span><span>,</span><span>
                   </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G</span><span> (</span><span class="coqdoc-var">tau</span><span> --&gt; </span><span class="coqdoc-var">tau'</span><span>) -&gt; </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau</span><span> -&gt; </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">tau'</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>term is defined
term_rect is defined
term_ind is defined
term_rec is defined
term_sind is defined
</span></dd>
</dl>
</div>
<p>We have defined types and contexts which are snoc-lists of types. We
also have a <code class="docutils literal notranslate"><span class="pre">conc</span></code> operation that concatenates two contexts. The <code class="docutils literal notranslate"><span class="pre">term</span></code>
datatype represents in fact the possible typing derivations of the
calculus, which are isomorphic to the well-typed terms, hence the
name. A term is either an application of:</p>
<ul class="simple">
<li><p>the axiom rule to type a reference to the first variable in a
context</p></li>
<li><p>the weakening rule to type an object in a larger context</p></li>
<li><p>the abstraction or lambda rule to type a function</p></li>
<li><p>the application to type an application of a function to an argument</p></li>
</ul>
<p>Once we have this datatype we want to do proofs on it, like weakening:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">weakening</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span> </span><span class="coqdoc-var">tau</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span> ; </span><span class="coqdoc-var">D</span><span>) </span><span class="coqdoc-var">tau</span><span> -&gt;</span><span>
                  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">tau'</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span> , </span><span class="coqdoc-var">tau'</span><span> ; </span><span class="coqdoc-var">D</span><span>) </span><span class="coqdoc-var">tau</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (G D : ctx) (tau : type),
  term (G</span><span>;</span><span> D) tau</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
</span></dd>
</dl>
</div>
<p>The problem here is that we can't just use induction on the typing
derivation because it will forget about the <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">;</span> <span class="pre">D</span></code> constraint appearing
in the instance. A solution would be to rewrite the goal as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">weakening'</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G'</span><span> </span><span class="coqdoc-var">tau</span><span>, </span><span class="coqdoc-var">term</span><span> </span><span class="coqdoc-var">G'</span><span> </span><span class="coqdoc-var">tau</span><span> -&gt;</span><span>
                   </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span>, (</span><span class="coqdoc-var">G</span><span> ; </span><span class="coqdoc-var">D</span><span>) = </span><span class="coqdoc-var">G'</span><span> -&gt;</span><span>
                   </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">tau'</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span>, </span><span class="coqdoc-var">tau'</span><span> ; </span><span class="coqdoc-var">D</span><span>) </span><span class="coqdoc-var">tau</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (G' : ctx) (tau : type),
  term G' tau</span><span> -&gt;</span><span>
  </span><span class="ansi-bold">forall</span><span> G D : ctx, G</span><span>;</span><span> D</span><span> =</span><span> G'</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
</span></dd>
</dl>
</div>
<p>With this proper separation of the index from the instance and the
right induction loading (putting <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code> after the inducted-on
hypothesis), the proof will go through, but it is a very tedious
process. One is also forced to make a wrapper lemma to get back the
more natural statement. The <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> tactic alleviates this
trouble by doing all of this plumbing of generalizing and substituting
back automatically. Indeed we can simply write:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Program.Tactics</span><span>.</span><span>
</span></dt><dt><span></span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Program.Equality</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">weakening</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span> </span><span class="coqdoc-var">tau</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span> ; </span><span class="coqdoc-var">D</span><span>) </span><span class="coqdoc-var">tau</span><span> -&gt;</span><span>
                  </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">tau'</span><span>, </span><span class="coqdoc-var">term</span><span> (</span><span class="coqdoc-var">G</span><span> , </span><span class="coqdoc-var">tau'</span><span> ; </span><span class="coqdoc-var">D</span><span>) </span><span class="coqdoc-var">tau</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  ============================
  </span><span class="ansi-bold">forall</span><span> (G D : ctx) (tau : type),
  term (G</span><span>;</span><span> D) tau</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
</span></dd>
</dl>
<span></span><dl class="simple">
<dt><span></span><span class="coqdoc-keyword">Proof</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-tactic">simpl</span><span> </span><span class="coqdoc-tactic">in</span><span> * ; </span><span class="coqdoc-var">simpl_depind</span><span> ; </span><span class="coqdoc-tactic">auto</span><span>.</span><span>
</span></dt></dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span> </span><span class="coqdoc-var">tau</span><span> </span><span class="coqdoc-var">H</span><span>. </span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">generalizing</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">D</span><span> ; </span><span class="coqdoc-tactic">intros</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>1 goal
  
  G, D : ctx
  tau : type
  H : term (G</span><span>;</span><span> D) tau
  ============================
  </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau

4 goals
  
  G0 : ctx
  tau : type
  G, D : ctx
  x : G0</span><span>,</span><span> tau</span><span> =</span><span> G</span><span>;</span><span> D
  tau' : type
  ============================
  term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
</div>
<p>This call to <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a> has an additional arguments which is
a list of variables appearing in the instance that should be
generalized in the goal, so that they can vary in the induction
hypotheses. By default, all variables appearing inside constructors
(except in a parameter position) of the instantiated hypothesis will
be generalized automatically but one can always give the list
explicitly.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Show</span><span>.</span><span>
</span></dt><dd><span>4 goals
  
  G0 : ctx
  tau : type
  G, D : ctx
  x : G0</span><span>,</span><span> tau</span><span> =</span><span> G</span><span>;</span><span> D
  tau' : type
  ============================
  term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">simpl_depind</span></code> tactic includes an automatic tactic that tries to
simplify equalities appearing at the beginning of induction
hypotheses, generally using trivial applications of <code class="docutils literal notranslate"><span class="pre">reflexivity</span></code>. In
cases where the equality is not between constructor forms though, one
must help the automation by giving some arguments, using the
<code class="docutils literal notranslate"><span class="pre">specialize</span></code> tactic for example.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">D</span><span>... </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">weak</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">ax</span><span>. </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">ax</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>5 goals
  
  G0 : ctx
  tau, tau' : type
  ============================
  term ((G0</span><span>,</span><span> tau)</span><span>,</span><span> tau') tau

goal 2 is:
 term (((G</span><span>,</span><span> tau')</span><span>;</span><span> D)</span><span>,</span><span> t) t
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 5 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'

4 goals
  
  G, D : ctx
  t, tau' : type
  ============================
  term (((G</span><span>,</span><span> tau')</span><span>;</span><span> D)</span><span>,</span><span> t) t

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'

3 goals
  
  G0 : ctx
  tau : type
  H : term G0 tau
  tau' : type
  IHterm : </span><span class="ansi-bold">forall</span><span> G D : ctx,
           G0</span><span> =</span><span> G</span><span>;</span><span> D</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
  G, D : ctx
  x : G0</span><span>,</span><span> tau'</span><span> =</span><span> G</span><span>;</span><span> D
  tau'0 : type
  ============================
  term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">destruct</span><span> </span><span class="coqdoc-var">D</span><span>...</span><span>
</span></dt><dd class="coqtop-hidden"><span>4 goals
  
  G0 : ctx
  tau : type
  H : term G0 tau
  tau' : type
  IHterm : </span><span class="ansi-bold">forall</span><span> G D : ctx,
           G0</span><span> =</span><span> G</span><span>;</span><span> D</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
  tau'0 : type
  ============================
  term ((G0</span><span>,</span><span> tau')</span><span>,</span><span> tau'0) tau

goal 2 is:
 term (((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D)</span><span>,</span><span> t) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-keyword">Show</span><span>.</span><span>
</span></dt><dd><span>4 goals
  
  G0 : ctx
  tau : type
  H : term G0 tau
  tau' : type
  IHterm : </span><span class="ansi-bold">forall</span><span> G D : ctx,
           G0</span><span> =</span><span> G</span><span>;</span><span> D</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G</span><span>,</span><span> tau')</span><span>;</span><span> D) tau
  tau'0 : type
  ============================
  term ((G0</span><span>,</span><span> tau')</span><span>,</span><span> tau'0) tau

goal 2 is:
 term (((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D)</span><span>,</span><span> t) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">specialize</span><span> (</span><span class="coqdoc-var">IHterm</span><span> </span><span class="coqdoc-var">G0</span><span> </span><span class="coqdoc-var">empty</span><span> </span><span class="coqdoc-var">eq_refl</span><span>).</span><span>
</span></dt><dd><span>4 goals
  
  G0 : ctx
  tau : type
  H : term G0 tau
  tau' : type
  IHterm : </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G0</span><span>,</span><span> tau')</span><span>;</span><span> empty) tau
  tau'0 : type
  ============================
  term ((G0</span><span>,</span><span> tau')</span><span>,</span><span> tau'0) tau

goal 2 is:
 term (((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D)</span><span>,</span><span> t) tau
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 4 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
</div>
<p>Once the induction hypothesis has been narrowed to the right equality,
it can be used directly.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">weak</span><span>, </span><span class="coqdoc-var">IHterm</span><span>.</span><span>
</span></dt><dd><span>3 goals
  
  tau : type
  G, D : ctx
  IHterm : </span><span class="ansi-bold">forall</span><span> G0 D0 : ctx,
           G</span><span>;</span><span> D</span><span> =</span><span> G0</span><span>;</span><span> D0</span><span> -&gt;</span><span> </span><span class="ansi-bold">forall</span><span> tau' : type, term ((G0</span><span>,</span><span> tau')</span><span>;</span><span> D0) tau
  H : term (G</span><span>;</span><span> D) tau
  t, tau'0 : type
  ============================
  term (((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D)</span><span>,</span><span> t) tau

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')
goal 3 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
</div>
<p>Now concluding this subgoal is easy.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span></span><span class="coqdoc-tactic">constructor</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">IHterm</span><span>; </span><span class="coqdoc-tactic">reflexivity</span><span>.</span><span>
</span></dt><dd class="coqtop-hidden"><span>2 goals
  
  G, D : ctx
  tau, tau' : type
  H : term ((G</span><span>;</span><span> D)</span><span>,</span><span> tau) tau'
  IHterm : </span><span class="ansi-bold">forall</span><span> G0 D0 : ctx,
           (G</span><span>;</span><span> D)</span><span>,</span><span> tau</span><span> =</span><span> G0</span><span>;</span><span> D0</span><span> -&gt;</span><span>
           </span><span class="ansi-bold">forall</span><span> tau'0 : type, term ((G0</span><span>,</span><span> tau'0)</span><span>;</span><span> D0) tau'
  tau'0 : type
  ============================
  term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) (tau</span><span> --&gt;</span><span> tau')

goal 2 is:
 term ((G</span><span>,</span><span> tau'0)</span><span>;</span><span> D) tau'
</span></dd>
</dl>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="equality.html" class="btn btn-neutral float-left" title="Reasoning with equalities" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../proof-engine/ssreflect-proof-language.html" class="btn btn-neutral float-right" title="The SSReflect proof language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2021, Inria, CNRS and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  




  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Other versions</span>
      v: 8.18.0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://coq.github.io/doc/master/refman/">dev</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/current/refman/">stable</a></dd>
        
          <dd><a href="https://coq.github.io/doc/v8.18/refman/">8.18</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.17.1/refman/">8.17</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.16.1/refman/">8.16</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.15.2/refman/">8.15</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.14.1/refman/">8.14</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.13.2/refman/">8.13</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.12.2/refman/">8.12</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.11.2/refman/">8.11</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.10.2/refman/">8.10</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.9.1/refman/">8.9</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.8.2/refman/">8.8</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.7.2/refman/">8.7</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.6.1/refman/">8.6</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.5pl3/refman/">8.5</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.4pl6/refman/">8.4</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.3pl5/refman/">8.3</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.2pl3/refman/">8.2</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.1pl6/refman/">8.1</a></dd>
        
          <dd><a href="https://coq.inria.fr/distrib/V8.0/doc/">8.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="https://github.com/coq/coq/releases/download/V8.18.0/coq-8.18.0-reference-manual.pdf">PDF</a></dd>
        
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>